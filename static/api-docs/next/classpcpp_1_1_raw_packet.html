<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "https://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=9"/>
<meta name="generator" content="Doxygen 1.9.1"/>
<meta name="viewport" content="width=device-width, initial-scale=1"/>
<title>PcapPlusPlus: pcpp::RawPacket Class Reference</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<link href="navtree.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="resize.js"></script>
<script type="text/javascript" src="navtreedata.js"></script>
<script type="text/javascript" src="navtree.js"></script>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/searchdata.js"></script>
<script type="text/javascript" src="search/search.js"></script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
<link href="doxygen-mobile.css" rel="stylesheet" type="text/css"/>
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr style="height: 56px;">
  <td id="projectlogo"><img alt="Logo" src="logo_icon_large.ico"/></td>
  <td id="projectalign" style="padding-left: 0.5em;">
   <div id="projectname">PcapPlusPlus
   &#160;<span id="projectnumber">Next</span>
   </div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.9.1 -->
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:cf05388f2679ee054f2beb29a391d25f4e673ac3&amp;dn=gpl-2.0.txt GPL-v2 */
var searchBox = new SearchBox("searchBox", "search",false,'Search','.html');
/* @license-end */
</script>
<script type="text/javascript" src="menudata.js"></script>
<script type="text/javascript" src="menu.js"></script>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:cf05388f2679ee054f2beb29a391d25f4e673ac3&amp;dn=gpl-2.0.txt GPL-v2 */
$(function() {
  initMenu('',true,false,'search.php','Search');
  $(document).ready(function() { init_search(); });
});
/* @license-end */</script>
<div id="main-nav"></div>
</div><!-- top -->
<div id="side-nav" class="ui-resizable side-nav-resizable">
  <div id="nav-tree">
    <div id="nav-tree-contents">
      <div id="nav-sync" class="sync"></div>
    </div>
  </div>
  <div id="splitbar" style="-moz-user-select:none;" 
       class="ui-resizable-handle">
  </div>
</div>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:cf05388f2679ee054f2beb29a391d25f4e673ac3&amp;dn=gpl-2.0.txt GPL-v2 */
$(document).ready(function(){initNavTree('classpcpp_1_1_raw_packet.html',''); initResizable(); });
/* @license-end */
</script>
<div id="doc-content">
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
</div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<iframe src="javascript:void(0)" frameborder="0" 
        name="MSearchResults" id="MSearchResults">
</iframe>
</div>

<div class="header">
  <div class="summary">
<a href="#pub-methods">Public Member Functions</a> &#124;
<a href="#pub-static-methods">Static Public Member Functions</a> &#124;
<a href="classpcpp_1_1_raw_packet-members.html">List of all members</a>  </div>
  <div class="headertitle">
<div class="title">pcpp::RawPacket Class Reference</div>  </div>
</div><!--header-->
<div class="contents">

<p><code>#include &lt;<a class="el" href="_raw_packet_8h_source.html">RawPacket.h</a>&gt;</code></p>
<div class="dynheader">
Inheritance diagram for pcpp::RawPacket:</div>
<div class="dyncontent">
 <div class="center">
  <img src="classpcpp_1_1_raw_packet.png" usemap="#pcpp::RawPacket_map" alt=""/>
  <map id="pcpp::RawPacket_map" name="pcpp::RawPacket_map">
<area href="classpcpp_1_1_m_buf_raw_packet.html" alt="pcpp::MBufRawPacket" shape="rect" coords="0,56,138,80"/>
  </map>
</div></div>
<table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="pub-methods"></a>
Public Member Functions</h2></td></tr>
<tr class="memitem:a8834cea9fc72516c3d22a841479ee684"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classpcpp_1_1_raw_packet.html#a8834cea9fc72516c3d22a841479ee684">RawPacket</a> (const uint8_t *pRawData, int rawDataLen, timeval timestamp, bool deleteRawDataAtDestructor, <a class="el" href="namespacepcpp.html#ab3f43dd3ccd8c93acac8b67909be02be">LinkLayerType</a> layerType=<a class="el" href="namespacepcpp.html#ab3f43dd3ccd8c93acac8b67909be02bea4a7bd3283e7f9b30aa9e71e7807de215">LINKTYPE_ETHERNET</a>)</td></tr>
<tr class="separator:a8834cea9fc72516c3d22a841479ee684"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a76475bd10f2bda34a6fee2686a26c475"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classpcpp_1_1_raw_packet.html#a76475bd10f2bda34a6fee2686a26c475">RawPacket</a> (const uint8_t *pRawData, int rawDataLen, timespec timestamp, bool deleteRawDataAtDestructor, <a class="el" href="namespacepcpp.html#ab3f43dd3ccd8c93acac8b67909be02be">LinkLayerType</a> layerType=<a class="el" href="namespacepcpp.html#ab3f43dd3ccd8c93acac8b67909be02bea4a7bd3283e7f9b30aa9e71e7807de215">LINKTYPE_ETHERNET</a>)</td></tr>
<tr class="separator:a76475bd10f2bda34a6fee2686a26c475"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:acc12f855f36a798ce0e8c7dc8a4618f9"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classpcpp_1_1_raw_packet.html#acc12f855f36a798ce0e8c7dc8a4618f9">RawPacket</a> ()</td></tr>
<tr class="separator:acc12f855f36a798ce0e8c7dc8a4618f9"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:abb8b8a3574217ab88b406cba3d2551fb"><td class="memItemLeft" align="right" valign="top"><a id="abb8b8a3574217ab88b406cba3d2551fb"></a>
virtual&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classpcpp_1_1_raw_packet.html#abb8b8a3574217ab88b406cba3d2551fb">~RawPacket</a> ()</td></tr>
<tr class="memdesc:abb8b8a3574217ab88b406cba3d2551fb"><td class="mdescLeft">&#160;</td><td class="mdescRight">A destructor for this class. Frees the raw data if deleteRawDataAtDestructor was set to 'true'. <br /></td></tr>
<tr class="separator:abb8b8a3574217ab88b406cba3d2551fb"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a38d24eda21061c53f0801f3bcbe34193"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classpcpp_1_1_raw_packet.html#a38d24eda21061c53f0801f3bcbe34193">RawPacket</a> (const <a class="el" href="classpcpp_1_1_raw_packet.html">RawPacket</a> &amp;other)</td></tr>
<tr class="separator:a38d24eda21061c53f0801f3bcbe34193"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:afc8278a0208727a579a122f197c4d02e"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classpcpp_1_1_raw_packet.html">RawPacket</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classpcpp_1_1_raw_packet.html#afc8278a0208727a579a122f197c4d02e">operator=</a> (const <a class="el" href="classpcpp_1_1_raw_packet.html">RawPacket</a> &amp;other)</td></tr>
<tr class="separator:afc8278a0208727a579a122f197c4d02e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af7fea4b64de7faf8313436adc8668a6d"><td class="memItemLeft" align="right" valign="top">virtual <a class="el" href="classpcpp_1_1_raw_packet.html">RawPacket</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classpcpp_1_1_raw_packet.html#af7fea4b64de7faf8313436adc8668a6d">clone</a> () const</td></tr>
<tr class="memdesc:af7fea4b64de7faf8313436adc8668a6d"><td class="mdescLeft">&#160;</td><td class="mdescRight">Clones the current packet. Caller is responsible for deallocation of the memory.  <a href="classpcpp_1_1_raw_packet.html#af7fea4b64de7faf8313436adc8668a6d">More...</a><br /></td></tr>
<tr class="separator:af7fea4b64de7faf8313436adc8668a6d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a84cca99a63eeaa7653e984462686f2bc"><td class="memItemLeft" align="right" valign="top">virtual uint8_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classpcpp_1_1_raw_packet.html#a84cca99a63eeaa7653e984462686f2bc">getObjectType</a> () const</td></tr>
<tr class="separator:a84cca99a63eeaa7653e984462686f2bc"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6babfc371bd3b9eac8c741cba5e097f6"><td class="memItemLeft" align="right" valign="top">virtual bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classpcpp_1_1_raw_packet.html#a6babfc371bd3b9eac8c741cba5e097f6">setRawData</a> (const uint8_t *pRawData, int rawDataLen, timeval timestamp, <a class="el" href="namespacepcpp.html#ab3f43dd3ccd8c93acac8b67909be02be">LinkLayerType</a> layerType=<a class="el" href="namespacepcpp.html#ab3f43dd3ccd8c93acac8b67909be02bea4a7bd3283e7f9b30aa9e71e7807de215">LINKTYPE_ETHERNET</a>, int frameLength=-1)</td></tr>
<tr class="separator:a6babfc371bd3b9eac8c741cba5e097f6"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa11e800ab071df0a3c1c329868aea5a7"><td class="memItemLeft" align="right" valign="top">virtual bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classpcpp_1_1_raw_packet.html#aa11e800ab071df0a3c1c329868aea5a7">setRawData</a> (const uint8_t *pRawData, int rawDataLen, timespec timestamp, <a class="el" href="namespacepcpp.html#ab3f43dd3ccd8c93acac8b67909be02be">LinkLayerType</a> layerType=<a class="el" href="namespacepcpp.html#ab3f43dd3ccd8c93acac8b67909be02bea4a7bd3283e7f9b30aa9e71e7807de215">LINKTYPE_ETHERNET</a>, int frameLength=-1)</td></tr>
<tr class="separator:aa11e800ab071df0a3c1c329868aea5a7"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a74ac9d1097c7714f0fc23c6e8198a2a8"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classpcpp_1_1_raw_packet.html#a74ac9d1097c7714f0fc23c6e8198a2a8">initWithRawData</a> (const uint8_t *pRawData, int rawDataLen, timespec timestamp, <a class="el" href="namespacepcpp.html#ab3f43dd3ccd8c93acac8b67909be02be">LinkLayerType</a> layerType=<a class="el" href="namespacepcpp.html#ab3f43dd3ccd8c93acac8b67909be02bea4a7bd3283e7f9b30aa9e71e7807de215">LINKTYPE_ETHERNET</a>)</td></tr>
<tr class="separator:a74ac9d1097c7714f0fc23c6e8198a2a8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a095f2d3a3ac095b23c07af2bf095653f"><td class="memItemLeft" align="right" valign="top">const uint8_t *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classpcpp_1_1_raw_packet.html#a095f2d3a3ac095b23c07af2bf095653f">getRawData</a> () const</td></tr>
<tr class="separator:a095f2d3a3ac095b23c07af2bf095653f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad3cd4246f2c2e6a7d4238a02b28771ba"><td class="memItemLeft" align="right" valign="top"><a class="el" href="namespacepcpp.html#ab3f43dd3ccd8c93acac8b67909be02be">LinkLayerType</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classpcpp_1_1_raw_packet.html#ad3cd4246f2c2e6a7d4238a02b28771ba">getLinkLayerType</a> () const</td></tr>
<tr class="separator:ad3cd4246f2c2e6a7d4238a02b28771ba"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a15e5700fb9d76cdfbcb3c3d505f22904"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classpcpp_1_1_raw_packet.html#a15e5700fb9d76cdfbcb3c3d505f22904">getRawDataLen</a> () const</td></tr>
<tr class="separator:a15e5700fb9d76cdfbcb3c3d505f22904"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a19819af25bdac6217aad301b7b243b15"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classpcpp_1_1_raw_packet.html#a19819af25bdac6217aad301b7b243b15">getFrameLength</a> () const</td></tr>
<tr class="separator:a19819af25bdac6217aad301b7b243b15"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6ccee8471600cd6ed14c184b3252b469"><td class="memItemLeft" align="right" valign="top">timespec&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classpcpp_1_1_raw_packet.html#a6ccee8471600cd6ed14c184b3252b469">getPacketTimeStamp</a> () const</td></tr>
<tr class="separator:a6ccee8471600cd6ed14c184b3252b469"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af487937f955cf1597772228e9ae99729"><td class="memItemLeft" align="right" valign="top">virtual bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classpcpp_1_1_raw_packet.html#af487937f955cf1597772228e9ae99729">setPacketTimeStamp</a> (timeval timestamp)</td></tr>
<tr class="separator:af487937f955cf1597772228e9ae99729"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ade226b4fed36009d01190439430e48a2"><td class="memItemLeft" align="right" valign="top">virtual bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classpcpp_1_1_raw_packet.html#ade226b4fed36009d01190439430e48a2">setPacketTimeStamp</a> (timespec timestamp)</td></tr>
<tr class="separator:ade226b4fed36009d01190439430e48a2"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad2de0b9094569c2505cf590d8ab50f45"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classpcpp_1_1_raw_packet.html#ad2de0b9094569c2505cf590d8ab50f45">isPacketSet</a> () const</td></tr>
<tr class="separator:ad2de0b9094569c2505cf590d8ab50f45"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab6b169b02bda40e90279e7d8f6816e41"><td class="memItemLeft" align="right" valign="top">virtual void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classpcpp_1_1_raw_packet.html#ab6b169b02bda40e90279e7d8f6816e41">clear</a> ()</td></tr>
<tr class="separator:ab6b169b02bda40e90279e7d8f6816e41"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6ed098d0dfcf60fa561b56e6c73bed9c"><td class="memItemLeft" align="right" valign="top">virtual void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classpcpp_1_1_raw_packet.html#a6ed098d0dfcf60fa561b56e6c73bed9c">appendData</a> (const uint8_t *dataToAppend, size_t dataToAppendLen)</td></tr>
<tr class="separator:a6ed098d0dfcf60fa561b56e6c73bed9c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3563f649177826c9e4f649eec7b35887"><td class="memItemLeft" align="right" valign="top">virtual void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classpcpp_1_1_raw_packet.html#a3563f649177826c9e4f649eec7b35887">insertData</a> (int atIndex, const uint8_t *dataToInsert, size_t dataToInsertLen)</td></tr>
<tr class="separator:a3563f649177826c9e4f649eec7b35887"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9cf289e6bbf461f55c20784615c899ce"><td class="memItemLeft" align="right" valign="top">virtual bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classpcpp_1_1_raw_packet.html#a9cf289e6bbf461f55c20784615c899ce">removeData</a> (int atIndex, size_t numOfBytesToRemove)</td></tr>
<tr class="separator:a9cf289e6bbf461f55c20784615c899ce"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:acd9248a47bd60427e2a3ef34b379a28e"><td class="memItemLeft" align="right" valign="top">virtual bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classpcpp_1_1_raw_packet.html#acd9248a47bd60427e2a3ef34b379a28e">reallocateData</a> (size_t newBufferLength)</td></tr>
<tr class="separator:acd9248a47bd60427e2a3ef34b379a28e"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="pub-static-methods"></a>
Static Public Member Functions</h2></td></tr>
<tr class="memitem:a23e6987060255d210f0fac7db63b07a6"><td class="memItemLeft" align="right" valign="top">static bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classpcpp_1_1_raw_packet.html#a23e6987060255d210f0fac7db63b07a6">isLinkTypeValid</a> (int linkTypeValue)</td></tr>
<tr class="separator:a23e6987060255d210f0fac7db63b07a6"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table>
<a name="details" id="details"></a><h2 class="groupheader">Detailed Description</h2>
<div class="textblock"><p>This class holds the packet as raw (not parsed) data. The data is held as byte array. In addition to the data itself every instance also holds a timestamp representing the time the packet was received by the NIC. <a class="el" href="classpcpp_1_1_raw_packet.html">RawPacket</a> instance isn't read only. The user can change the packet data, add or remove data, etc. </p>
</div><h2 class="groupheader">Constructor &amp; Destructor Documentation</h2>
<a id="a8834cea9fc72516c3d22a841479ee684"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a8834cea9fc72516c3d22a841479ee684">&#9670;&nbsp;</a></span>RawPacket() <span class="overload">[1/4]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">pcpp::RawPacket::RawPacket </td>
          <td>(</td>
          <td class="paramtype">const uint8_t *&#160;</td>
          <td class="paramname"><em>pRawData</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>rawDataLen</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">timeval&#160;</td>
          <td class="paramname"><em>timestamp</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>deleteRawDataAtDestructor</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="namespacepcpp.html#ab3f43dd3ccd8c93acac8b67909be02be">LinkLayerType</a>&#160;</td>
          <td class="paramname"><em>layerType</em> = <code><a class="el" href="namespacepcpp.html#ab3f43dd3ccd8c93acac8b67909be02bea4a7bd3283e7f9b30aa9e71e7807de215">LINKTYPE_ETHERNET</a></code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>A constructor that receives a pointer to the raw data (allocated elsewhere). This constructor is usually used when packet is captured using a packet capturing engine (like libPcap. WinPcap, Npcap, PF_RING, etc.). The capturing engine allocates the raw data memory and give the user a pointer to it + a timestamp it has arrived to the device </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">pRawData</td><td>A pointer to the raw data </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">rawDataLen</td><td>The raw data length in bytes </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">timestamp</td><td>The timestamp packet was received by the NIC (in usec precision) </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">deleteRawDataAtDestructor</td><td>An indicator whether raw data pointer should be freed when the instance is freed or not. If set to 'true' than pRawData will be freed when instanced is being freed </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">layerType</td><td>The link layer type of this raw packet. The default is Ethernet </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a76475bd10f2bda34a6fee2686a26c475"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a76475bd10f2bda34a6fee2686a26c475">&#9670;&nbsp;</a></span>RawPacket() <span class="overload">[2/4]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">pcpp::RawPacket::RawPacket </td>
          <td>(</td>
          <td class="paramtype">const uint8_t *&#160;</td>
          <td class="paramname"><em>pRawData</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>rawDataLen</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">timespec&#160;</td>
          <td class="paramname"><em>timestamp</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>deleteRawDataAtDestructor</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="namespacepcpp.html#ab3f43dd3ccd8c93acac8b67909be02be">LinkLayerType</a>&#160;</td>
          <td class="paramname"><em>layerType</em> = <code><a class="el" href="namespacepcpp.html#ab3f43dd3ccd8c93acac8b67909be02bea4a7bd3283e7f9b30aa9e71e7807de215">LINKTYPE_ETHERNET</a></code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>A constructor that receives a pointer to the raw data (allocated elsewhere). This constructor is usually used when packet is captured using a packet capturing engine (like libPcap. WinPcap, Npcap, PF_RING, etc.). The capturing engine allocates the raw data memory and give the user a pointer to it + a timestamp it has arrived to the device </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">pRawData</td><td>A pointer to the raw data </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">rawDataLen</td><td>The raw data length in bytes </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">timestamp</td><td>The timestamp packet was received by the NIC (in nsec precision) </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">deleteRawDataAtDestructor</td><td>An indicator whether raw data pointer should be freed when the instance is freed or not. If set to 'true' than pRawData will be freed when instanced is being freed </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">layerType</td><td>The link layer type of this raw packet. The default is Ethernet </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="acc12f855f36a798ce0e8c7dc8a4618f9"></a>
<h2 class="memtitle"><span class="permalink"><a href="#acc12f855f36a798ce0e8c7dc8a4618f9">&#9670;&nbsp;</a></span>RawPacket() <span class="overload">[3/4]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">pcpp::RawPacket::RawPacket </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>A default constructor that initializes class'es attributes to default value:</p><ul>
<li>data pointer is set to nullptr</li>
<li>data length is set to 0</li>
<li>deleteRawDataAtDestructor is set to 'true'  </li>
</ul>

</div>
</div>
<a id="a38d24eda21061c53f0801f3bcbe34193"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a38d24eda21061c53f0801f3bcbe34193">&#9670;&nbsp;</a></span>RawPacket() <span class="overload">[4/4]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">pcpp::RawPacket::RawPacket </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classpcpp_1_1_raw_packet.html">RawPacket</a> &amp;&#160;</td>
          <td class="paramname"><em>other</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>A copy constructor that copies all data from another instance. Notice all raw data is copied (using memcpy), so when the original or the other instance are freed, the other won't be affected </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">other</td><td>The instance to copy from </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<h2 class="groupheader">Member Function Documentation</h2>
<a id="a6ed098d0dfcf60fa561b56e6c73bed9c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a6ed098d0dfcf60fa561b56e6c73bed9c">&#9670;&nbsp;</a></span>appendData()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual void pcpp::RawPacket::appendData </td>
          <td>(</td>
          <td class="paramtype">const uint8_t *&#160;</td>
          <td class="paramname"><em>dataToAppend</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>dataToAppendLen</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Append data to the end of current data. This method works without allocating more memory, it just uses memcpy() to copy dataToAppend at the end of the current data. This means that the method assumes this memory was already allocated by the user. If it isn't the case then this method will cause memory corruption </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">dataToAppend</td><td>A pointer to the data to append to current raw data </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">dataToAppendLen</td><td>Length in bytes of dataToAppend </td></tr>
  </table>
  </dd>
</dl>

<p>Reimplemented in <a class="el" href="classpcpp_1_1_m_buf_raw_packet.html#af1c5144634729ce1ab2da2aa89946e89">pcpp::MBufRawPacket</a>.</p>

</div>
</div>
<a id="ab6b169b02bda40e90279e7d8f6816e41"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ab6b169b02bda40e90279e7d8f6816e41">&#9670;&nbsp;</a></span>clear()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual void pcpp::RawPacket::clear </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Clears all members of this instance, meaning setting raw data to nullptr, raw data length to 0, etc. Frees the raw data if deleteRawDataAtDestructor was set to 'true'  </p>

<p>Reimplemented in <a class="el" href="classpcpp_1_1_m_buf_raw_packet.html#a265214f9d02a63d0cff85b4e1a93c396">pcpp::MBufRawPacket</a>.</p>

</div>
</div>
<a id="af7fea4b64de7faf8313436adc8668a6d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#af7fea4b64de7faf8313436adc8668a6d">&#9670;&nbsp;</a></span>clone()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual <a class="el" href="classpcpp_1_1_raw_packet.html">RawPacket</a>* pcpp::RawPacket::clone </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Clones the current packet. Caller is responsible for deallocation of the memory. </p>
<dl class="section return"><dt>Returns</dt><dd>A pointer to the new <a class="el" href="classpcpp_1_1_raw_packet.html">RawPacket</a> object which is a clone of this object </dd></dl>

<p>Reimplemented in <a class="el" href="classpcpp_1_1_m_buf_raw_packet.html#a74e4efa1c3f7c4b8a16561ecbba73fbf">pcpp::MBufRawPacket</a>.</p>

</div>
</div>
<a id="a19819af25bdac6217aad301b7b243b15"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a19819af25bdac6217aad301b7b243b15">&#9670;&nbsp;</a></span>getFrameLength()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">int pcpp::RawPacket::getFrameLength </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Get frame length in bytes </p><dl class="section return"><dt>Returns</dt><dd>frame length in bytes </dd></dl>

</div>
</div>
<a id="ad3cd4246f2c2e6a7d4238a02b28771ba"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ad3cd4246f2c2e6a7d4238a02b28771ba">&#9670;&nbsp;</a></span>getLinkLayerType()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="namespacepcpp.html#ab3f43dd3ccd8c93acac8b67909be02be">LinkLayerType</a> pcpp::RawPacket::getLinkLayerType </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Get the link layer type </p><dl class="section return"><dt>Returns</dt><dd>the type of the link layer </dd></dl>

</div>
</div>
<a id="a84cca99a63eeaa7653e984462686f2bc"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a84cca99a63eeaa7653e984462686f2bc">&#9670;&nbsp;</a></span>getObjectType()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual uint8_t pcpp::RawPacket::getObjectType </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<dl class="section return"><dt>Returns</dt><dd><a class="el" href="classpcpp_1_1_raw_packet.html">RawPacket</a> object type. Each derived class should return a different value </dd></dl>

<p>Reimplemented in <a class="el" href="classpcpp_1_1_m_buf_raw_packet.html#a75ff3b18bc4510106ae045e711fb1827">pcpp::MBufRawPacket</a>.</p>

</div>
</div>
<a id="a6ccee8471600cd6ed14c184b3252b469"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a6ccee8471600cd6ed14c184b3252b469">&#9670;&nbsp;</a></span>getPacketTimeStamp()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">timespec pcpp::RawPacket::getPacketTimeStamp </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Get raw data timestamp </p><dl class="section return"><dt>Returns</dt><dd>Raw data timestamp </dd></dl>

</div>
</div>
<a id="a095f2d3a3ac095b23c07af2bf095653f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a095f2d3a3ac095b23c07af2bf095653f">&#9670;&nbsp;</a></span>getRawData()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">const uint8_t* pcpp::RawPacket::getRawData </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Get raw data pointer </p><dl class="section return"><dt>Returns</dt><dd>A read-only pointer to the raw data </dd></dl>

</div>
</div>
<a id="a15e5700fb9d76cdfbcb3c3d505f22904"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a15e5700fb9d76cdfbcb3c3d505f22904">&#9670;&nbsp;</a></span>getRawDataLen()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">int pcpp::RawPacket::getRawDataLen </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Get raw data length in bytes </p><dl class="section return"><dt>Returns</dt><dd>Raw data length in bytes </dd></dl>

</div>
</div>
<a id="a74ac9d1097c7714f0fc23c6e8198a2a8"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a74ac9d1097c7714f0fc23c6e8198a2a8">&#9670;&nbsp;</a></span>initWithRawData()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool pcpp::RawPacket::initWithRawData </td>
          <td>(</td>
          <td class="paramtype">const uint8_t *&#160;</td>
          <td class="paramname"><em>pRawData</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>rawDataLen</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">timespec&#160;</td>
          <td class="paramname"><em>timestamp</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="namespacepcpp.html#ab3f43dd3ccd8c93acac8b67909be02be">LinkLayerType</a>&#160;</td>
          <td class="paramname"><em>layerType</em> = <code><a class="el" href="namespacepcpp.html#ab3f43dd3ccd8c93acac8b67909be02bea4a7bd3283e7f9b30aa9e71e7807de215">LINKTYPE_ETHERNET</a></code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Initialize a raw packet with data. The main difference between this method and <a class="el" href="classpcpp_1_1_raw_packet.html#a6babfc371bd3b9eac8c741cba5e097f6">setRawData()</a> is that <a class="el" href="classpcpp_1_1_raw_packet.html#a6babfc371bd3b9eac8c741cba5e097f6">setRawData()</a> is meant for replacing the data in an existing raw packet, whereas this method is meant to be used right after constructing a raw packet using the default c'tor, before setting any data </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">pRawData</td><td>A pointer to the new raw data </td></tr>
    <tr><td class="paramname">rawDataLen</td><td>The new raw data length in bytes </td></tr>
    <tr><td class="paramname">timestamp</td><td>The timestamp packet was received by the NIC (in nsec precision) </td></tr>
    <tr><td class="paramname">layerType</td><td>The link layer type for this raw data </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>True if raw data was set successfully, false otherwise </dd></dl>

</div>
</div>
<a id="a3563f649177826c9e4f649eec7b35887"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a3563f649177826c9e4f649eec7b35887">&#9670;&nbsp;</a></span>insertData()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual void pcpp::RawPacket::insertData </td>
          <td>(</td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>atIndex</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const uint8_t *&#160;</td>
          <td class="paramname"><em>dataToInsert</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>dataToInsertLen</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Insert new data at some index of the current data and shift the remaining old data to the end. This method works without allocating more memory, it just copies dataToAppend at the relevant index and shifts the remaining data to the end. This means that the method assumes this memory was already allocated by the user. If it isn't the case then this method will cause memory corruption </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">atIndex</td><td>The index to insert the new data to </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">dataToInsert</td><td>A pointer to the new data to insert </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">dataToInsertLen</td><td>Length in bytes of dataToInsert </td></tr>
  </table>
  </dd>
</dl>

<p>Reimplemented in <a class="el" href="classpcpp_1_1_m_buf_raw_packet.html#a12e04aa6f066e6971946cc033fb2bdf9">pcpp::MBufRawPacket</a>.</p>

</div>
</div>
<a id="a23e6987060255d210f0fac7db63b07a6"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a23e6987060255d210f0fac7db63b07a6">&#9670;&nbsp;</a></span>isLinkTypeValid()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static bool pcpp::RawPacket::isLinkTypeValid </td>
          <td>(</td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>linkTypeValue</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>This static method validates whether a link type integer value is valid </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">linkTypeValue</td><td>Link type integer value </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>True if the link type value is valid and can be casted into LinkLayerType enum, false otherwise </dd></dl>

</div>
</div>
<a id="ad2de0b9094569c2505cf590d8ab50f45"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ad2de0b9094569c2505cf590d8ab50f45">&#9670;&nbsp;</a></span>isPacketSet()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool pcpp::RawPacket::isPacketSet </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Get an indication whether raw data was already set for this instance. </p><dl class="section return"><dt>Returns</dt><dd>True if raw data was set for this instance. Raw data can be set using the non-default constructor, using <a class="el" href="classpcpp_1_1_raw_packet.html#a6babfc371bd3b9eac8c741cba5e097f6">setRawData()</a>, using the copy constructor or using the assignment operator. Returns false otherwise, for example: if the instance was created using the default constructor or <a class="el" href="classpcpp_1_1_raw_packet.html#ab6b169b02bda40e90279e7d8f6816e41">clear()</a> was called </dd></dl>

</div>
</div>
<a id="afc8278a0208727a579a122f197c4d02e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#afc8278a0208727a579a122f197c4d02e">&#9670;&nbsp;</a></span>operator=()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classpcpp_1_1_raw_packet.html">RawPacket</a>&amp; pcpp::RawPacket::operator= </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classpcpp_1_1_raw_packet.html">RawPacket</a> &amp;&#160;</td>
          <td class="paramname"><em>other</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Assignment operator overload for this class. When using this operator on an already initialized <a class="el" href="classpcpp_1_1_raw_packet.html">RawPacket</a> instance, the original raw data is freed first if deleteRawDataAtDestructor was set to 'true'. Then the other instance is copied to this instance, the same way the copy constructor works </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">other</td><td>The instance to copy from </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="acd9248a47bd60427e2a3ef34b379a28e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#acd9248a47bd60427e2a3ef34b379a28e">&#9670;&nbsp;</a></span>reallocateData()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual bool pcpp::RawPacket::reallocateData </td>
          <td>(</td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>newBufferLength</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Re-allocate raw packet buffer meaning add size to it without losing the current packet data. This method allocates the required buffer size as instructed by the use and then copies the raw data from the current allocated buffer to the new one. This method can become useful if the user wants to insert or append data to the raw data, and the previous allocated buffer is too small, so the user wants to allocate a larger buffer and get <a class="el" href="classpcpp_1_1_raw_packet.html">RawPacket</a> instance to point to it </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">newBufferLength</td><td>The new buffer length as required by the user. The method is responsible to allocate the memory </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>True if data was reallocated successfully, false otherwise </dd></dl>

<p>Reimplemented in <a class="el" href="classpcpp_1_1_m_buf_raw_packet.html#ac8984ba4413680165a38d13bdd853987">pcpp::MBufRawPacket</a>.</p>

</div>
</div>
<a id="a9cf289e6bbf461f55c20784615c899ce"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a9cf289e6bbf461f55c20784615c899ce">&#9670;&nbsp;</a></span>removeData()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual bool pcpp::RawPacket::removeData </td>
          <td>(</td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>atIndex</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>numOfBytesToRemove</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Remove certain number of bytes from current raw data buffer. All data after the removed bytes will be shifted back </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">atIndex</td><td>The index to start removing bytes from </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">numOfBytesToRemove</td><td>Number of bytes to remove </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>True if all bytes were removed successfully, or false if atIndex+numOfBytesToRemove is out-of-bounds of the raw data buffer </dd></dl>

<p>Reimplemented in <a class="el" href="classpcpp_1_1_m_buf_raw_packet.html#a3895fef553d8345e18b7f97e52f1a10d">pcpp::MBufRawPacket</a>.</p>

</div>
</div>
<a id="ade226b4fed36009d01190439430e48a2"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ade226b4fed36009d01190439430e48a2">&#9670;&nbsp;</a></span>setPacketTimeStamp() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual bool pcpp::RawPacket::setPacketTimeStamp </td>
          <td>(</td>
          <td class="paramtype">timespec&#160;</td>
          <td class="paramname"><em>timestamp</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Set raw packet timestamp with nsec precision </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">timestamp</td><td>The timestamp to set (with nsec precision) </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>True if timestamp was set successfully, false otherwise </dd></dl>

</div>
</div>
<a id="af487937f955cf1597772228e9ae99729"></a>
<h2 class="memtitle"><span class="permalink"><a href="#af487937f955cf1597772228e9ae99729">&#9670;&nbsp;</a></span>setPacketTimeStamp() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual bool pcpp::RawPacket::setPacketTimeStamp </td>
          <td>(</td>
          <td class="paramtype">timeval&#160;</td>
          <td class="paramname"><em>timestamp</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Set raw packet timestamp with usec precision </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">timestamp</td><td>The timestamp to set (with usec precision) </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>True if timestamp was set successfully, false otherwise </dd></dl>

</div>
</div>
<a id="aa11e800ab071df0a3c1c329868aea5a7"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aa11e800ab071df0a3c1c329868aea5a7">&#9670;&nbsp;</a></span>setRawData() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual bool pcpp::RawPacket::setRawData </td>
          <td>(</td>
          <td class="paramtype">const uint8_t *&#160;</td>
          <td class="paramname"><em>pRawData</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>rawDataLen</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">timespec&#160;</td>
          <td class="paramname"><em>timestamp</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="namespacepcpp.html#ab3f43dd3ccd8c93acac8b67909be02be">LinkLayerType</a>&#160;</td>
          <td class="paramname"><em>layerType</em> = <code><a class="el" href="namespacepcpp.html#ab3f43dd3ccd8c93acac8b67909be02bea4a7bd3283e7f9b30aa9e71e7807de215">LINKTYPE_ETHERNET</a></code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>frameLength</em> = <code>-1</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Set a raw data. If data was already set and deleteRawDataAtDestructor was set to 'true' the old data will be freed first </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">pRawData</td><td>A pointer to the new raw data </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">rawDataLen</td><td>The new raw data length in bytes </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">timestamp</td><td>The timestamp packet was received by the NIC (in nsec precision) </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">layerType</td><td>The link layer type for this raw data </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">frameLength</td><td>When reading from pcap files, sometimes the captured length is different from the actual packet length. This parameter represents the packet length. This parameter is optional, if not set or set to -1 it is assumed both lengths are equal </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>True if raw data was set successfully, false otherwise </dd></dl>

<p>Reimplemented in <a class="el" href="classpcpp_1_1_m_buf_raw_packet.html#ab2a9026bb43a9255fadb43ca5c398dfd">pcpp::MBufRawPacket</a>.</p>

</div>
</div>
<a id="a6babfc371bd3b9eac8c741cba5e097f6"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a6babfc371bd3b9eac8c741cba5e097f6">&#9670;&nbsp;</a></span>setRawData() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual bool pcpp::RawPacket::setRawData </td>
          <td>(</td>
          <td class="paramtype">const uint8_t *&#160;</td>
          <td class="paramname"><em>pRawData</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>rawDataLen</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">timeval&#160;</td>
          <td class="paramname"><em>timestamp</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="namespacepcpp.html#ab3f43dd3ccd8c93acac8b67909be02be">LinkLayerType</a>&#160;</td>
          <td class="paramname"><em>layerType</em> = <code><a class="el" href="namespacepcpp.html#ab3f43dd3ccd8c93acac8b67909be02bea4a7bd3283e7f9b30aa9e71e7807de215">LINKTYPE_ETHERNET</a></code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>frameLength</em> = <code>-1</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Set a raw data. If data was already set and deleteRawDataAtDestructor was set to 'true' the old data will be freed first </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">pRawData</td><td>A pointer to the new raw data </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">rawDataLen</td><td>The new raw data length in bytes </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">timestamp</td><td>The timestamp packet was received by the NIC (in usec precision) </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">layerType</td><td>The link layer type for this raw data </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">frameLength</td><td>When reading from pcap files, sometimes the captured length is different from the actual packet length. This parameter represents the packet length. This parameter is optional, if not set or set to -1 it is assumed both lengths are equal </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>True if raw data was set successfully, false otherwise </dd></dl>

</div>
</div>
</div><!-- contents -->
</div><!-- doc-content -->
<!-- start footer part -->
<div id="nav-path" class="navpath"><!-- id is needed for treeview function! -->
  <ul>
    <li class="navelem"><a class="el" href="namespacepcpp.html">pcpp</a></li><li class="navelem"><a class="el" href="classpcpp_1_1_raw_packet.html">RawPacket</a></li>
    <li class="footer">Generated on Sun Apr 20 2025 22:29:56 for PcapPlusPlus by <a href="https://www.doxygen.org/index.html"><img class="footer" src="doxygen.svg" width="104" height="31" alt="doxygen"/></a> 1.9.1 </li>
  </ul>
</div>
</body>
</html>
