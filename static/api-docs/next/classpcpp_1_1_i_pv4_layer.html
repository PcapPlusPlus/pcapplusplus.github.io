<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "https://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=9"/>
<meta name="generator" content="Doxygen 1.9.1"/>
<meta name="viewport" content="width=device-width, initial-scale=1"/>
<title>PcapPlusPlus: pcpp::IPv4Layer Class Reference</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<link href="navtree.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="resize.js"></script>
<script type="text/javascript" src="navtreedata.js"></script>
<script type="text/javascript" src="navtree.js"></script>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/searchdata.js"></script>
<script type="text/javascript" src="search/search.js"></script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
<link href="doxygen-mobile.css" rel="stylesheet" type="text/css"/>
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr style="height: 56px;">
  <td id="projectlogo"><img alt="Logo" src="logo_icon_large.ico"/></td>
  <td id="projectalign" style="padding-left: 0.5em;">
   <div id="projectname">PcapPlusPlus
   &#160;<span id="projectnumber">Next</span>
   </div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.9.1 -->
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:cf05388f2679ee054f2beb29a391d25f4e673ac3&amp;dn=gpl-2.0.txt GPL-v2 */
var searchBox = new SearchBox("searchBox", "search",false,'Search','.html');
/* @license-end */
</script>
<script type="text/javascript" src="menudata.js"></script>
<script type="text/javascript" src="menu.js"></script>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:cf05388f2679ee054f2beb29a391d25f4e673ac3&amp;dn=gpl-2.0.txt GPL-v2 */
$(function() {
  initMenu('',true,false,'search.php','Search');
  $(document).ready(function() { init_search(); });
});
/* @license-end */</script>
<div id="main-nav"></div>
</div><!-- top -->
<div id="side-nav" class="ui-resizable side-nav-resizable">
  <div id="nav-tree">
    <div id="nav-tree-contents">
      <div id="nav-sync" class="sync"></div>
    </div>
  </div>
  <div id="splitbar" style="-moz-user-select:none;" 
       class="ui-resizable-handle">
  </div>
</div>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:cf05388f2679ee054f2beb29a391d25f4e673ac3&amp;dn=gpl-2.0.txt GPL-v2 */
$(document).ready(function(){initNavTree('classpcpp_1_1_i_pv4_layer.html',''); initResizable(); });
/* @license-end */
</script>
<div id="doc-content">
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
</div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<iframe src="javascript:void(0)" frameborder="0" 
        name="MSearchResults" id="MSearchResults">
</iframe>
</div>

<div class="header">
  <div class="summary">
<a href="#pub-methods">Public Member Functions</a> &#124;
<a href="#pub-static-methods">Static Public Member Functions</a> &#124;
<a href="classpcpp_1_1_i_pv4_layer-members.html">List of all members</a>  </div>
  <div class="headertitle">
<div class="title">pcpp::IPv4Layer Class Reference</div>  </div>
</div><!--header-->
<div class="contents">

<p><code>#include &lt;<a class="el" href="_i_pv4_layer_8h_source.html">IPv4Layer.h</a>&gt;</code></p>
<div class="dynheader">
Inheritance diagram for pcpp::IPv4Layer:</div>
<div class="dyncontent">
 <div class="center">
  <img src="classpcpp_1_1_i_pv4_layer.png" usemap="#pcpp::IPv4Layer_map" alt=""/>
  <map id="pcpp::IPv4Layer_map" name="pcpp::IPv4Layer_map">
<area href="classpcpp_1_1_layer.html" alt="pcpp::Layer" shape="rect" coords="0,56,130,80"/>
<area href="classpcpp_1_1_i_p_layer.html" alt="pcpp::IPLayer" shape="rect" coords="140,56,270,80"/>
<area href="classpcpp_1_1_i_data_container.html" alt="pcpp::IDataContainer" shape="rect" coords="0,0,130,24"/>
  </map>
</div></div>
<table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="pub-methods"></a>
Public Member Functions</h2></td></tr>
<tr class="memitem:a4f0053a3866503b87803140b5ea2b8fe"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classpcpp_1_1_i_pv4_layer.html#a4f0053a3866503b87803140b5ea2b8fe">IPv4Layer</a> (uint8_t *data, size_t dataLen, <a class="el" href="classpcpp_1_1_layer.html">Layer</a> *prevLayer, <a class="el" href="classpcpp_1_1_packet.html">Packet</a> *packet)</td></tr>
<tr class="separator:a4f0053a3866503b87803140b5ea2b8fe"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7a61390d0fe81e53fc92e5ddf4037c7e"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classpcpp_1_1_i_pv4_layer.html#a7a61390d0fe81e53fc92e5ddf4037c7e">IPv4Layer</a> (uint8_t *data, size_t dataLen, <a class="el" href="classpcpp_1_1_layer.html">Layer</a> *prevLayer, <a class="el" href="classpcpp_1_1_packet.html">Packet</a> *packet, bool setTotalLenAsDataLen)</td></tr>
<tr class="separator:a7a61390d0fe81e53fc92e5ddf4037c7e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0e84eff3c7ac732a1a934ee507fdb2ce"><td class="memItemLeft" align="right" valign="top"><a id="a0e84eff3c7ac732a1a934ee507fdb2ce"></a>
&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classpcpp_1_1_i_pv4_layer.html#a0e84eff3c7ac732a1a934ee507fdb2ce">IPv4Layer</a> ()</td></tr>
<tr class="memdesc:a0e84eff3c7ac732a1a934ee507fdb2ce"><td class="mdescLeft">&#160;</td><td class="mdescRight">A constructor that allocates a new IPv4 header with empty fields. <br /></td></tr>
<tr class="separator:a0e84eff3c7ac732a1a934ee507fdb2ce"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4adc5b7767e069f468a70f63a798088b"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classpcpp_1_1_i_pv4_layer.html#a4adc5b7767e069f468a70f63a798088b">IPv4Layer</a> (const <a class="el" href="classpcpp_1_1_i_pv4_address.html">IPv4Address</a> &amp;srcIP, const <a class="el" href="classpcpp_1_1_i_pv4_address.html">IPv4Address</a> &amp;dstIP)</td></tr>
<tr class="separator:a4adc5b7767e069f468a70f63a798088b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9ca12d7881cdc6bf3dca277e57cb2b79"><td class="memItemLeft" align="right" valign="top"><a id="a9ca12d7881cdc6bf3dca277e57cb2b79"></a>
&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classpcpp_1_1_i_pv4_layer.html#a9ca12d7881cdc6bf3dca277e57cb2b79">IPv4Layer</a> (const <a class="el" href="classpcpp_1_1_i_pv4_layer.html">IPv4Layer</a> &amp;other)</td></tr>
<tr class="memdesc:a9ca12d7881cdc6bf3dca277e57cb2b79"><td class="mdescLeft">&#160;</td><td class="mdescRight">A copy constructor that copy the entire header from the other <a class="el" href="classpcpp_1_1_i_pv4_layer.html">IPv4Layer</a> (including IPv4 options) <br /></td></tr>
<tr class="separator:a9ca12d7881cdc6bf3dca277e57cb2b79"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a970afc622e4984256059ae80031dd38d"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classpcpp_1_1_i_pv4_layer.html">IPv4Layer</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classpcpp_1_1_i_pv4_layer.html#a970afc622e4984256059ae80031dd38d">operator=</a> (const <a class="el" href="classpcpp_1_1_i_pv4_layer.html">IPv4Layer</a> &amp;other)</td></tr>
<tr class="separator:a970afc622e4984256059ae80031dd38d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0586c258ff6ad5b051cdfab23449b9e0"><td class="memItemLeft" align="right" valign="top"><a class="el" href="structpcpp_1_1iphdr.html">iphdr</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classpcpp_1_1_i_pv4_layer.html#a0586c258ff6ad5b051cdfab23449b9e0">getIPv4Header</a> () const</td></tr>
<tr class="separator:a0586c258ff6ad5b051cdfab23449b9e0"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a28a052e25199e7be029851006af0073b"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classpcpp_1_1_i_p_address.html">IPAddress</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classpcpp_1_1_i_pv4_layer.html#a28a052e25199e7be029851006af0073b">getSrcIPAddress</a> () const override</td></tr>
<tr class="separator:a28a052e25199e7be029851006af0073b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1726f094f39326d963d7343022764937"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classpcpp_1_1_i_pv4_address.html">IPv4Address</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classpcpp_1_1_i_pv4_layer.html#a1726f094f39326d963d7343022764937">getSrcIPv4Address</a> () const</td></tr>
<tr class="separator:a1726f094f39326d963d7343022764937"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a73890160a9c3a32df28aa6cb0f4a752f"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classpcpp_1_1_i_pv4_layer.html#a73890160a9c3a32df28aa6cb0f4a752f">setSrcIPv4Address</a> (const <a class="el" href="classpcpp_1_1_i_pv4_address.html">IPv4Address</a> &amp;ipAddr)</td></tr>
<tr class="separator:a73890160a9c3a32df28aa6cb0f4a752f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a25aeb8c75b4a5b16e679a4fb48ca144a"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classpcpp_1_1_i_p_address.html">IPAddress</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classpcpp_1_1_i_pv4_layer.html#a25aeb8c75b4a5b16e679a4fb48ca144a">getDstIPAddress</a> () const override</td></tr>
<tr class="separator:a25aeb8c75b4a5b16e679a4fb48ca144a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9a132f5bd5b57037429322a44208f2fd"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classpcpp_1_1_i_pv4_address.html">IPv4Address</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classpcpp_1_1_i_pv4_layer.html#a9a132f5bd5b57037429322a44208f2fd">getDstIPv4Address</a> () const</td></tr>
<tr class="separator:a9a132f5bd5b57037429322a44208f2fd"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6dfa29c3f8e93ce0e72d5abb96e59ce8"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classpcpp_1_1_i_pv4_layer.html#a6dfa29c3f8e93ce0e72d5abb96e59ce8">setDstIPv4Address</a> (const <a class="el" href="classpcpp_1_1_i_pv4_address.html">IPv4Address</a> &amp;ipAddr)</td></tr>
<tr class="separator:a6dfa29c3f8e93ce0e72d5abb96e59ce8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5cf53b28a9dea46455a757c008a16382"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classpcpp_1_1_i_pv4_layer.html#a5cf53b28a9dea46455a757c008a16382">isFragment</a> () const</td></tr>
<tr class="separator:a5cf53b28a9dea46455a757c008a16382"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad225191b00811a73536485846fd9936d"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classpcpp_1_1_i_pv4_layer.html#ad225191b00811a73536485846fd9936d">isFirstFragment</a> () const</td></tr>
<tr class="separator:ad225191b00811a73536485846fd9936d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8a681d88811ec5256efd270edf2b943d"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classpcpp_1_1_i_pv4_layer.html#a8a681d88811ec5256efd270edf2b943d">isLastFragment</a> () const</td></tr>
<tr class="separator:a8a681d88811ec5256efd270edf2b943d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1365c034a409a90ef101c336b744980c"><td class="memItemLeft" align="right" valign="top">uint8_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classpcpp_1_1_i_pv4_layer.html#a1365c034a409a90ef101c336b744980c">getFragmentFlags</a> () const</td></tr>
<tr class="separator:a1365c034a409a90ef101c336b744980c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ace85267d49ce9ba18d3cbadf4b259296"><td class="memItemLeft" align="right" valign="top">uint16_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classpcpp_1_1_i_pv4_layer.html#ace85267d49ce9ba18d3cbadf4b259296">getFragmentOffset</a> () const</td></tr>
<tr class="separator:ace85267d49ce9ba18d3cbadf4b259296"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4fe5a0b8e3de349a6a9bbc941f0d9dd1"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classpcpp_1_1_i_pv4_option.html">IPv4Option</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classpcpp_1_1_i_pv4_layer.html#a4fe5a0b8e3de349a6a9bbc941f0d9dd1">getOption</a> (<a class="el" href="namespacepcpp.html#a4ac8e7540b72db061b0078f1e2ca2b68">IPv4OptionTypes</a> option) const</td></tr>
<tr class="separator:a4fe5a0b8e3de349a6a9bbc941f0d9dd1"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac4134a33a0fa2991db8243072620c27e"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classpcpp_1_1_i_pv4_option.html">IPv4Option</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classpcpp_1_1_i_pv4_layer.html#ac4134a33a0fa2991db8243072620c27e">getFirstOption</a> () const</td></tr>
<tr class="separator:ac4134a33a0fa2991db8243072620c27e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a04713b91c69ba6eee1f7243b7ccba118"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classpcpp_1_1_i_pv4_option.html">IPv4Option</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classpcpp_1_1_i_pv4_layer.html#a04713b91c69ba6eee1f7243b7ccba118">getNextOption</a> (<a class="el" href="classpcpp_1_1_i_pv4_option.html">IPv4Option</a> &amp;option) const</td></tr>
<tr class="separator:a04713b91c69ba6eee1f7243b7ccba118"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab7f15e771c6eba1b28432b9d4d97b642"><td class="memItemLeft" align="right" valign="top">size_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classpcpp_1_1_i_pv4_layer.html#ab7f15e771c6eba1b28432b9d4d97b642">getOptionCount</a> () const</td></tr>
<tr class="separator:ab7f15e771c6eba1b28432b9d4d97b642"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3582be94404086c66a1432eef261e888"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classpcpp_1_1_i_pv4_option.html">IPv4Option</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classpcpp_1_1_i_pv4_layer.html#a3582be94404086c66a1432eef261e888">addOption</a> (const <a class="el" href="classpcpp_1_1_i_pv4_option_builder.html">IPv4OptionBuilder</a> &amp;optionBuilder)</td></tr>
<tr class="separator:a3582be94404086c66a1432eef261e888"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac2c675c0aae851a13565f614b89e412f"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classpcpp_1_1_i_pv4_option.html">IPv4Option</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classpcpp_1_1_i_pv4_layer.html#ac2c675c0aae851a13565f614b89e412f">addOptionAfter</a> (const <a class="el" href="classpcpp_1_1_i_pv4_option_builder.html">IPv4OptionBuilder</a> &amp;optionBuilder, <a class="el" href="namespacepcpp.html#a4ac8e7540b72db061b0078f1e2ca2b68">IPv4OptionTypes</a> prevOptionType=<a class="el" href="namespacepcpp.html#a4ac8e7540b72db061b0078f1e2ca2b68aad0353574fe158b11da6113b7b129d0d">IPV4OPT_Unknown</a>)</td></tr>
<tr class="separator:ac2c675c0aae851a13565f614b89e412f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac99e55cc416df24b19241493fe4d9906"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classpcpp_1_1_i_pv4_layer.html#ac99e55cc416df24b19241493fe4d9906">removeOption</a> (<a class="el" href="namespacepcpp.html#a4ac8e7540b72db061b0078f1e2ca2b68">IPv4OptionTypes</a> option)</td></tr>
<tr class="separator:ac99e55cc416df24b19241493fe4d9906"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a03640d65fc57a0b78541a369eec391c2"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classpcpp_1_1_i_pv4_layer.html#a03640d65fc57a0b78541a369eec391c2">removeAllOptions</a> ()</td></tr>
<tr class="separator:a03640d65fc57a0b78541a369eec391c2"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2f15a23dd9617ef6c639679acc16b06a"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classpcpp_1_1_i_pv4_layer.html#a2f15a23dd9617ef6c639679acc16b06a">parseNextLayer</a> () override</td></tr>
<tr class="separator:a2f15a23dd9617ef6c639679acc16b06a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a07a6607ab7cfdf10ffef94f0b1e81541"><td class="memItemLeft" align="right" valign="top">size_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classpcpp_1_1_i_pv4_layer.html#a07a6607ab7cfdf10ffef94f0b1e81541">getHeaderLen</a> () const override</td></tr>
<tr class="separator:a07a6607ab7cfdf10ffef94f0b1e81541"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7d2d3220e332c0b69d890a2dccfdc9da"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classpcpp_1_1_i_pv4_layer.html#a7d2d3220e332c0b69d890a2dccfdc9da">computeCalculateFields</a> () override</td></tr>
<tr class="separator:a7d2d3220e332c0b69d890a2dccfdc9da"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae8fb318c4185d63e55ee08f1991529be"><td class="memItemLeft" align="right" valign="top">std::string&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classpcpp_1_1_i_pv4_layer.html#ae8fb318c4185d63e55ee08f1991529be">toString</a> () const override</td></tr>
<tr class="separator:ae8fb318c4185d63e55ee08f1991529be"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a86b9683e20dc9b78ec7c885b2f5ff87c"><td class="memItemLeft" align="right" valign="top"><a class="el" href="namespacepcpp.html#a69e2ee6a9dc68797612cf8dc38461025">OsiModelLayer</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classpcpp_1_1_i_pv4_layer.html#a86b9683e20dc9b78ec7c885b2f5ff87c">getOsiModelLayer</a> () const override</td></tr>
<tr class="separator:a86b9683e20dc9b78ec7c885b2f5ff87c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="inherit_header pub_methods_classpcpp_1_1_layer"><td colspan="2" onclick="javascript:toggleInherit('pub_methods_classpcpp_1_1_layer')"><img src="closed.png" alt="-"/>&#160;Public Member Functions inherited from <a class="el" href="classpcpp_1_1_layer.html">pcpp::Layer</a></td></tr>
<tr class="memitem:adc5fdf997375b58400a55fdcc3bdff87 inherit pub_methods_classpcpp_1_1_layer"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classpcpp_1_1_layer.html#adc5fdf997375b58400a55fdcc3bdff87">~Layer</a> () override</td></tr>
<tr class="separator:adc5fdf997375b58400a55fdcc3bdff87 inherit pub_methods_classpcpp_1_1_layer"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a73b23d182802ec4ac4021042897eb410 inherit pub_methods_classpcpp_1_1_layer"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classpcpp_1_1_layer.html">Layer</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classpcpp_1_1_layer.html#a73b23d182802ec4ac4021042897eb410">getNextLayer</a> () const</td></tr>
<tr class="separator:a73b23d182802ec4ac4021042897eb410 inherit pub_methods_classpcpp_1_1_layer"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9ff77f4ee3f160057f49db645a5c19bd inherit pub_methods_classpcpp_1_1_layer"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classpcpp_1_1_layer.html">Layer</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classpcpp_1_1_layer.html#a9ff77f4ee3f160057f49db645a5c19bd">getPrevLayer</a> () const</td></tr>
<tr class="separator:a9ff77f4ee3f160057f49db645a5c19bd inherit pub_methods_classpcpp_1_1_layer"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab8c7cc855405c99b5fdfd778324241ef inherit pub_methods_classpcpp_1_1_layer"><td class="memItemLeft" align="right" valign="top"><a class="el" href="namespacepcpp.html#a1d761f7cf37d3b1efb1574fb1177e6eb">ProtocolType</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classpcpp_1_1_layer.html#ab8c7cc855405c99b5fdfd778324241ef">getProtocol</a> () const</td></tr>
<tr class="separator:ab8c7cc855405c99b5fdfd778324241ef inherit pub_methods_classpcpp_1_1_layer"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a73339cf991e01301a34ec602ba9ec7d9 inherit pub_methods_classpcpp_1_1_layer"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classpcpp_1_1_layer.html#a73339cf991e01301a34ec602ba9ec7d9">isMemberOfProtocolFamily</a> (<a class="el" href="namespacepcpp.html#aa26bae020a295f1089e08c390fb21c52">ProtocolTypeFamily</a> protocolTypeFamily) const</td></tr>
<tr class="separator:a73339cf991e01301a34ec602ba9ec7d9 inherit pub_methods_classpcpp_1_1_layer"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4e3c72d568a8d43c0fd82d781255e98f inherit pub_methods_classpcpp_1_1_layer"><td class="memItemLeft" align="right" valign="top">uint8_t *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classpcpp_1_1_layer.html#a4e3c72d568a8d43c0fd82d781255e98f">getData</a> () const</td></tr>
<tr class="separator:a4e3c72d568a8d43c0fd82d781255e98f inherit pub_methods_classpcpp_1_1_layer"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a33e4747c33cba0050ac90beeda45aa7b inherit pub_methods_classpcpp_1_1_layer"><td class="memItemLeft" align="right" valign="top">size_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classpcpp_1_1_layer.html#a33e4747c33cba0050ac90beeda45aa7b">getDataLen</a> () const</td></tr>
<tr class="separator:a33e4747c33cba0050ac90beeda45aa7b inherit pub_methods_classpcpp_1_1_layer"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0bd73bce6a07ea942d3d88bd472944ec inherit pub_methods_classpcpp_1_1_layer"><td class="memItemLeft" align="right" valign="top">uint8_t *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classpcpp_1_1_layer.html#a0bd73bce6a07ea942d3d88bd472944ec">getLayerPayload</a> () const</td></tr>
<tr class="separator:a0bd73bce6a07ea942d3d88bd472944ec inherit pub_methods_classpcpp_1_1_layer"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:abd87dfe9272183c2ea1c00752d7144c8 inherit pub_methods_classpcpp_1_1_layer"><td class="memItemLeft" align="right" valign="top">size_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classpcpp_1_1_layer.html#abd87dfe9272183c2ea1c00752d7144c8">getLayerPayloadSize</a> () const</td></tr>
<tr class="separator:abd87dfe9272183c2ea1c00752d7144c8 inherit pub_methods_classpcpp_1_1_layer"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8f9d719253a30852620f9595a99956ed inherit pub_methods_classpcpp_1_1_layer"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classpcpp_1_1_layer.html#a8f9d719253a30852620f9595a99956ed">isAllocatedToPacket</a> () const</td></tr>
<tr class="separator:a8f9d719253a30852620f9595a99956ed inherit pub_methods_classpcpp_1_1_layer"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a019a07d6f9d8fc7eb233e61826b11964 inherit pub_methods_classpcpp_1_1_layer"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classpcpp_1_1_layer.html#a019a07d6f9d8fc7eb233e61826b11964">copyData</a> (uint8_t *toArr) const</td></tr>
<tr class="separator:a019a07d6f9d8fc7eb233e61826b11964 inherit pub_methods_classpcpp_1_1_layer"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4c5d6f648a6878895a714004f937830d inherit pub_methods_classpcpp_1_1_layer"><td class="memItemLeft" align="right" valign="top">uint8_t *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classpcpp_1_1_layer.html#a4c5d6f648a6878895a714004f937830d">getDataPtr</a> (size_t offset=0) const override</td></tr>
<tr class="separator:a4c5d6f648a6878895a714004f937830d inherit pub_methods_classpcpp_1_1_layer"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="inherit_header pub_methods_classpcpp_1_1_i_p_layer"><td colspan="2" onclick="javascript:toggleInherit('pub_methods_classpcpp_1_1_i_p_layer')"><img src="closed.png" alt="-"/>&#160;Public Member Functions inherited from <a class="el" href="classpcpp_1_1_i_p_layer.html">pcpp::IPLayer</a></td></tr>
<tr class="memitem:a48d71e484fd49e9bd0d273dea6f77946 inherit pub_methods_classpcpp_1_1_i_p_layer"><td class="memItemLeft" align="right" valign="top"><a id="a48d71e484fd49e9bd0d273dea6f77946"></a>
virtual&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classpcpp_1_1_i_p_layer.html#a48d71e484fd49e9bd0d273dea6f77946">~IPLayer</a> ()=default</td></tr>
<tr class="memdesc:a48d71e484fd49e9bd0d273dea6f77946 inherit pub_methods_classpcpp_1_1_i_p_layer"><td class="mdescLeft">&#160;</td><td class="mdescRight">An empty destructor. <br /></td></tr>
<tr class="separator:a48d71e484fd49e9bd0d273dea6f77946 inherit pub_methods_classpcpp_1_1_i_p_layer"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="pub-static-methods"></a>
Static Public Member Functions</h2></td></tr>
<tr class="memitem:a30a31b2faebb821b09567a3d310e2b46"><td class="memItemLeft" align="right" valign="top">static bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classpcpp_1_1_i_pv4_layer.html#a30a31b2faebb821b09567a3d310e2b46">isDataValid</a> (const uint8_t *data, size_t dataLen)</td></tr>
<tr class="separator:a30a31b2faebb821b09567a3d310e2b46"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="inherit_header pub_static_methods_classpcpp_1_1_i_p_layer"><td colspan="2" onclick="javascript:toggleInherit('pub_static_methods_classpcpp_1_1_i_p_layer')"><img src="closed.png" alt="-"/>&#160;Static Public Member Functions inherited from <a class="el" href="classpcpp_1_1_i_p_layer.html">pcpp::IPLayer</a></td></tr>
<tr class="memitem:abccf0a0d8b1cb2769a6ac76821e60287 inherit pub_static_methods_classpcpp_1_1_i_p_layer"><td class="memItemLeft" align="right" valign="top">static <a class="el" href="namespacepcpp.html#a1d761f7cf37d3b1efb1574fb1177e6eb">ProtocolType</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classpcpp_1_1_i_p_layer.html#abccf0a0d8b1cb2769a6ac76821e60287">getIPVersion</a> (uint8_t const *data, size_t dataLen)</td></tr>
<tr class="memdesc:abccf0a0d8b1cb2769a6ac76821e60287 inherit pub_static_methods_classpcpp_1_1_i_p_layer"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get the IP version of a given packet data.  <a href="classpcpp_1_1_i_p_layer.html#abccf0a0d8b1cb2769a6ac76821e60287">More...</a><br /></td></tr>
<tr class="separator:abccf0a0d8b1cb2769a6ac76821e60287 inherit pub_static_methods_classpcpp_1_1_i_p_layer"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="inherited"></a>
Additional Inherited Members</h2></td></tr>
<tr class="inherit_header pro_methods_classpcpp_1_1_layer"><td colspan="2" onclick="javascript:toggleInherit('pro_methods_classpcpp_1_1_layer')"><img src="closed.png" alt="-"/>&#160;Protected Member Functions inherited from <a class="el" href="classpcpp_1_1_layer.html">pcpp::Layer</a></td></tr>
<tr class="memitem:a73210de1c3e4361189be96b40bf109d9 inherit pro_methods_classpcpp_1_1_layer"><td class="memTemplParams" colspan="2">template&lt;typename T , typename... Args&gt; </td></tr>
<tr class="memitem:a73210de1c3e4361189be96b40bf109d9 inherit pro_methods_classpcpp_1_1_layer"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="classpcpp_1_1_layer.html">Layer</a> *&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classpcpp_1_1_layer.html#a73210de1c3e4361189be96b40bf109d9">constructNextLayer</a> (uint8_t *data, size_t dataLen, <a class="el" href="classpcpp_1_1_packet.html">Packet</a> *packet, Args &amp;&amp;... extraArgs)</td></tr>
<tr class="separator:a73210de1c3e4361189be96b40bf109d9 inherit pro_methods_classpcpp_1_1_layer"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac180476870fbef9a104d775d81c70c74 inherit pro_methods_classpcpp_1_1_layer"><td class="memTemplParams" colspan="2">template&lt;typename T , typename TFallback , typename... Args&gt; </td></tr>
<tr class="memitem:ac180476870fbef9a104d775d81c70c74 inherit pro_methods_classpcpp_1_1_layer"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="classpcpp_1_1_layer.html">Layer</a> *&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classpcpp_1_1_layer.html#ac180476870fbef9a104d775d81c70c74">tryConstructNextLayerWithFallback</a> (uint8_t *data, size_t dataLen, <a class="el" href="classpcpp_1_1_packet.html">Packet</a> *packet, Args &amp;&amp;... extraArgs)</td></tr>
<tr class="separator:ac180476870fbef9a104d775d81c70c74 inherit pro_methods_classpcpp_1_1_layer"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="inherit_header pro_static_methods_classpcpp_1_1_layer"><td colspan="2" onclick="javascript:toggleInherit('pro_static_methods_classpcpp_1_1_layer')"><img src="closed.png" alt="-"/>&#160;Static Protected Member Functions inherited from <a class="el" href="classpcpp_1_1_layer.html">pcpp::Layer</a></td></tr>
<tr class="memitem:acb031e00ee13b0c299cc6c0458a61a18 inherit pro_static_methods_classpcpp_1_1_layer"><td class="memTemplParams" colspan="2">template&lt;typename T &gt; </td></tr>
<tr class="memitem:acb031e00ee13b0c299cc6c0458a61a18 inherit pro_static_methods_classpcpp_1_1_layer"><td class="memTemplItemLeft" align="right" valign="top">static bool&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classpcpp_1_1_layer.html#acb031e00ee13b0c299cc6c0458a61a18">canReinterpretAs</a> (const uint8_t *data, size_t dataLen)</td></tr>
<tr class="memdesc:acb031e00ee13b0c299cc6c0458a61a18 inherit pro_static_methods_classpcpp_1_1_layer"><td class="mdescLeft">&#160;</td><td class="mdescRight">Check if the data is large enough to reinterpret as a type.  <a href="classpcpp_1_1_layer.html#acb031e00ee13b0c299cc6c0458a61a18">More...</a><br /></td></tr>
<tr class="separator:acb031e00ee13b0c299cc6c0458a61a18 inherit pro_static_methods_classpcpp_1_1_layer"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table>
<a name="details" id="details"></a><h2 class="groupheader">Detailed Description</h2>
<div class="textblock"><p>Represents an IPv4 protocol layer </p>
</div><h2 class="groupheader">Constructor &amp; Destructor Documentation</h2>
<a id="a4f0053a3866503b87803140b5ea2b8fe"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a4f0053a3866503b87803140b5ea2b8fe">&#9670;&nbsp;</a></span>IPv4Layer() <span class="overload">[1/3]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">pcpp::IPv4Layer::IPv4Layer </td>
          <td>(</td>
          <td class="paramtype">uint8_t *&#160;</td>
          <td class="paramname"><em>data</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>dataLen</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classpcpp_1_1_layer.html">Layer</a> *&#160;</td>
          <td class="paramname"><em>prevLayer</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classpcpp_1_1_packet.html">Packet</a> *&#160;</td>
          <td class="paramname"><em>packet</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>A constructor that creates the layer from an existing packet raw data </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">data</td><td>A pointer to the raw data (will be casted to <a class="el" href="structpcpp_1_1iphdr.html">iphdr</a>) </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">dataLen</td><td>Size of the data in bytes </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">prevLayer</td><td>A pointer to the previous layer </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">packet</td><td>A pointer to the <a class="el" href="classpcpp_1_1_packet.html">Packet</a> instance where layer will be stored in </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a7a61390d0fe81e53fc92e5ddf4037c7e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a7a61390d0fe81e53fc92e5ddf4037c7e">&#9670;&nbsp;</a></span>IPv4Layer() <span class="overload">[2/3]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">pcpp::IPv4Layer::IPv4Layer </td>
          <td>(</td>
          <td class="paramtype">uint8_t *&#160;</td>
          <td class="paramname"><em>data</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>dataLen</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classpcpp_1_1_layer.html">Layer</a> *&#160;</td>
          <td class="paramname"><em>prevLayer</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classpcpp_1_1_packet.html">Packet</a> *&#160;</td>
          <td class="paramname"><em>packet</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>setTotalLenAsDataLen</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>A constructor that creates the layer from an existing packet raw data </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">data</td><td>A pointer to the raw data (will be casted to <a class="el" href="structpcpp_1_1iphdr.html">iphdr</a>) </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">dataLen</td><td>Size of the data in bytes </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">prevLayer</td><td>A pointer to the previous layer </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">packet</td><td>A pointer to the <a class="el" href="classpcpp_1_1_packet.html">Packet</a> instance where layer will be stored in </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">setTotalLenAsDataLen</td><td>When setting this value to "true" or when using the other c'tor, the layer data length is calculated from <a class="el" href="structpcpp_1_1iphdr.html#aab4d8ad9872f38be7fb53dd2ec45c63a" title="Entire packet (fragment) size, including header and data, in bytes.">iphdr::totalLength</a> field. When setting to "false" the data length is set as the value of dataLen parameter. Please notice that if <a class="el" href="structpcpp_1_1iphdr.html#aab4d8ad9872f38be7fb53dd2ec45c63a" title="Entire packet (fragment) size, including header and data, in bytes.">iphdr::totalLength</a> is equal to zero (which can happen in TCP Segmentation Offloading), this flag is ignored and the layer data length is calculated by the actual data captured on the wire </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a4adc5b7767e069f468a70f63a798088b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a4adc5b7767e069f468a70f63a798088b">&#9670;&nbsp;</a></span>IPv4Layer() <span class="overload">[3/3]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">pcpp::IPv4Layer::IPv4Layer </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classpcpp_1_1_i_pv4_address.html">IPv4Address</a> &amp;&#160;</td>
          <td class="paramname"><em>srcIP</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classpcpp_1_1_i_pv4_address.html">IPv4Address</a> &amp;&#160;</td>
          <td class="paramname"><em>dstIP</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>A constructor that allocates a new IPv4 header with source and destination IPv4 addresses </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">srcIP</td><td>Source IPv4 address </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">dstIP</td><td>Destination IPv4 address </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<h2 class="groupheader">Member Function Documentation</h2>
<a id="a3582be94404086c66a1432eef261e888"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a3582be94404086c66a1432eef261e888">&#9670;&nbsp;</a></span>addOption()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classpcpp_1_1_i_pv4_option.html">IPv4Option</a> pcpp::IPv4Layer::addOption </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classpcpp_1_1_i_pv4_option_builder.html">IPv4OptionBuilder</a> &amp;&#160;</td>
          <td class="paramname"><em>optionBuilder</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Add a new IPv4 option at the end of the layer (after the last IPv4 option) </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">optionBuilder</td><td>An <a class="el" href="classpcpp_1_1_i_pv4_option_builder.html">IPv4OptionBuilder</a> object that contains the IPv4 option data to be added </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>A <a class="el" href="classpcpp_1_1_i_pv4_option.html">IPv4Option</a> object that contains the newly added IPv4 option data or logical null (<a class="el" href="classpcpp_1_1_t_l_v_record.html#ac645af1daf82e0062d3c15fe92418801">IPv4Option::isNull()</a> == true) if addition failed. In case of a failure a corresponding error message will be printed to log </dd></dl>

</div>
</div>
<a id="ac2c675c0aae851a13565f614b89e412f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ac2c675c0aae851a13565f614b89e412f">&#9670;&nbsp;</a></span>addOptionAfter()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classpcpp_1_1_i_pv4_option.html">IPv4Option</a> pcpp::IPv4Layer::addOptionAfter </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classpcpp_1_1_i_pv4_option_builder.html">IPv4OptionBuilder</a> &amp;&#160;</td>
          <td class="paramname"><em>optionBuilder</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="namespacepcpp.html#a4ac8e7540b72db061b0078f1e2ca2b68">IPv4OptionTypes</a>&#160;</td>
          <td class="paramname"><em>prevOptionType</em> = <code><a class="el" href="namespacepcpp.html#a4ac8e7540b72db061b0078f1e2ca2b68aad0353574fe158b11da6113b7b129d0d">IPV4OPT_Unknown</a></code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Add a new IPv4 option after an existing one </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">optionBuilder</td><td>An <a class="el" href="classpcpp_1_1_i_pv4_option_builder.html">IPv4OptionBuilder</a> object that contains the requested IPv4 option data to be added </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">prevOptionType</td><td>The IPv4 option which the newly added option should come after. This is an optional parameter which gets a default value of <a class="el" href="namespacepcpp.html#a4ac8e7540b72db061b0078f1e2ca2b68aad0353574fe158b11da6113b7b129d0d" title="Unknown IPv4 option.">IPV4OPT_Unknown</a> if omitted, which means the new option will be added as the first option in the layer </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>A <a class="el" href="classpcpp_1_1_i_pv4_option.html">IPv4Option</a> object containing the newly added IPv4 option data or logical null (<a class="el" href="classpcpp_1_1_t_l_v_record.html#ac645af1daf82e0062d3c15fe92418801">IPv4Option::isNull()</a> == true) if addition failed. In case of a failure a corresponding error message will be printed to log </dd></dl>

</div>
</div>
<a id="a7d2d3220e332c0b69d890a2dccfdc9da"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a7d2d3220e332c0b69d890a2dccfdc9da">&#9670;&nbsp;</a></span>computeCalculateFields()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void pcpp::IPv4Layer::computeCalculateFields </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">override</span><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Calculate the following fields:</p><ul>
<li><a class="el" href="structpcpp_1_1iphdr.html#a74b5c1fbf03d4ebbd3d6ea2d263237b7" title="IP version number, has the value of 4 for IPv4.">iphdr::ipVersion</a> = 4;</li>
<li><a class="el" href="structpcpp_1_1iphdr.html#aab4d8ad9872f38be7fb53dd2ec45c63a" title="Entire packet (fragment) size, including header and data, in bytes.">iphdr::totalLength</a> = total packet length</li>
<li><a class="el" href="structpcpp_1_1iphdr.html#a724ead037aaf6310e5b9ebceba77f922" title="Error-checking of the header.">iphdr::headerChecksum</a> = calculated</li>
<li><a class="el" href="structpcpp_1_1iphdr.html#a9600c9b8e380ba5468763cdf648d043c" title="Defines the protocol used in the data portion of the IP datagram. Must be one of IPProtocolTypes.">iphdr::protocol</a> = calculated if next layer is known: <a class="el" href="namespacepcpp.html#ace8e2e21b82a8adc602f561e1e612fb0a5dffe1f660439e4cbde02f6df7125c05" title="Transmission Control Protocol.">PACKETPP_IPPROTO_TCP</a> for TCP, <a class="el" href="namespacepcpp.html#ace8e2e21b82a8adc602f561e1e612fb0a37bdb863a039ad4072f57ab7c10f9d5d" title="User Datagram Protocol.">PACKETPP_IPPROTO_UDP</a> for UDP, <a class="el" href="namespacepcpp.html#ace8e2e21b82a8adc602f561e1e612fb0a027db1494ff303416341ffb814c17dfa" title="Internet Control Message Protocol.">PACKETPP_IPPROTO_ICMP</a> for ICMP </li>
</ul>

<p>Implements <a class="el" href="classpcpp_1_1_layer.html#abea112176d18e896f48214ca7accac71">pcpp::Layer</a>.</p>

</div>
</div>
<a id="a25aeb8c75b4a5b16e679a4fb48ca144a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a25aeb8c75b4a5b16e679a4fb48ca144a">&#9670;&nbsp;</a></span>getDstIPAddress()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classpcpp_1_1_i_p_address.html">IPAddress</a> pcpp::IPv4Layer::getDstIPAddress </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">override</span><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Get the destination IP address in the form of <a class="el" href="classpcpp_1_1_i_p_address.html">IPAddress</a>. This method is very similar to <a class="el" href="classpcpp_1_1_i_pv4_layer.html#a9a132f5bd5b57037429322a44208f2fd">getDstIPv4Address()</a>, but adds a level of abstraction because <a class="el" href="classpcpp_1_1_i_p_address.html">IPAddress</a> can be used for both IPv4 and IPv6 addresses </p><dl class="section return"><dt>Returns</dt><dd>An <a class="el" href="classpcpp_1_1_i_p_address.html">IPAddress</a> containing the destination address </dd></dl>

<p>Implements <a class="el" href="classpcpp_1_1_i_p_layer.html#a6c493d8d47346fc9770e01c01eb534ab">pcpp::IPLayer</a>.</p>

</div>
</div>
<a id="a9a132f5bd5b57037429322a44208f2fd"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a9a132f5bd5b57037429322a44208f2fd">&#9670;&nbsp;</a></span>getDstIPv4Address()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classpcpp_1_1_i_pv4_address.html">IPv4Address</a> pcpp::IPv4Layer::getDstIPv4Address </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Get the destination IP address in the form of <a class="el" href="classpcpp_1_1_i_pv4_address.html">IPv4Address</a> </p><dl class="section return"><dt>Returns</dt><dd>An <a class="el" href="classpcpp_1_1_i_pv4_address.html">IPv4Address</a> containing the destination address </dd></dl>

</div>
</div>
<a id="ac4134a33a0fa2991db8243072620c27e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ac4134a33a0fa2991db8243072620c27e">&#9670;&nbsp;</a></span>getFirstOption()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classpcpp_1_1_i_pv4_option.html">IPv4Option</a> pcpp::IPv4Layer::getFirstOption </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">
<dl class="section return"><dt>Returns</dt><dd>The first IPv4 option in the packet. If the current layer contains no options the returned value will contain a logical null (<a class="el" href="classpcpp_1_1_t_l_v_record.html#ac645af1daf82e0062d3c15fe92418801">IPv4Option::isNull()</a> == true) </dd></dl>

</div>
</div>
<a id="a1365c034a409a90ef101c336b744980c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a1365c034a409a90ef101c336b744980c">&#9670;&nbsp;</a></span>getFragmentFlags()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">uint8_t pcpp::IPv4Layer::getFragmentFlags </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">
<dl class="section return"><dt>Returns</dt><dd>A bitmask containing the fragmentation flags (e.g IP_DONT_FRAGMENT or IP_MORE_FRAGMENTS) </dd></dl>

</div>
</div>
<a id="ace85267d49ce9ba18d3cbadf4b259296"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ace85267d49ce9ba18d3cbadf4b259296">&#9670;&nbsp;</a></span>getFragmentOffset()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">uint16_t pcpp::IPv4Layer::getFragmentOffset </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">
<dl class="section return"><dt>Returns</dt><dd>The fragment offset in case this packet is a fragment, 0 otherwise </dd></dl>

</div>
</div>
<a id="a07a6607ab7cfdf10ffef94f0b1e81541"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a07a6607ab7cfdf10ffef94f0b1e81541">&#9670;&nbsp;</a></span>getHeaderLen()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">size_t pcpp::IPv4Layer::getHeaderLen </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">override</span><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<dl class="section return"><dt>Returns</dt><dd>Size of IPv4 header (including IPv4 options if exist) </dd></dl>

<p>Implements <a class="el" href="classpcpp_1_1_layer.html#acabe7022caf7cf5fabcad4b5a0eec832">pcpp::Layer</a>.</p>

</div>
</div>
<a id="a0586c258ff6ad5b051cdfab23449b9e0"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a0586c258ff6ad5b051cdfab23449b9e0">&#9670;&nbsp;</a></span>getIPv4Header()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structpcpp_1_1iphdr.html">iphdr</a>* pcpp::IPv4Layer::getIPv4Header </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Get a pointer to the IPv4 header. Notice this points directly to the data, so every change will change the actual packet data </p><dl class="section return"><dt>Returns</dt><dd>A pointer to the <a class="el" href="structpcpp_1_1iphdr.html">iphdr</a> </dd></dl>

</div>
</div>
<a id="a04713b91c69ba6eee1f7243b7ccba118"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a04713b91c69ba6eee1f7243b7ccba118">&#9670;&nbsp;</a></span>getNextOption()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classpcpp_1_1_i_pv4_option.html">IPv4Option</a> pcpp::IPv4Layer::getNextOption </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classpcpp_1_1_i_pv4_option.html">IPv4Option</a> &amp;&#160;</td>
          <td class="paramname"><em>option</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Get the IPv4 option that comes after a given option. If the given option was the last one, the returned value will contain a logical null (<a class="el" href="classpcpp_1_1_t_l_v_record.html#ac645af1daf82e0062d3c15fe92418801">IPv4Option::isNull()</a> == true) </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">option</td><td>An IPv4 option object that exists in the current layer </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>A <a class="el" href="classpcpp_1_1_i_pv4_option.html">IPv4Option</a> object that contains the IPv4 option data that comes next, or logical null if the given IPv4 option: (1) was the last one; or (2) contains a logical null; or (3) doesn't belong to this packet </dd></dl>

</div>
</div>
<a id="a4fe5a0b8e3de349a6a9bbc941f0d9dd1"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a4fe5a0b8e3de349a6a9bbc941f0d9dd1">&#9670;&nbsp;</a></span>getOption()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classpcpp_1_1_i_pv4_option.html">IPv4Option</a> pcpp::IPv4Layer::getOption </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="namespacepcpp.html#a4ac8e7540b72db061b0078f1e2ca2b68">IPv4OptionTypes</a>&#160;</td>
          <td class="paramname"><em>option</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Get an IPv4 option by type. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">option</td><td>IPv4 option type </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>An <a class="el" href="classpcpp_1_1_i_pv4_option.html">IPv4Option</a> object that contains the first option that matches this type, or logical null (<a class="el" href="classpcpp_1_1_t_l_v_record.html#ac645af1daf82e0062d3c15fe92418801">IPv4Option::isNull()</a> == true) if no such option found </dd></dl>

</div>
</div>
<a id="ab7f15e771c6eba1b28432b9d4d97b642"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ab7f15e771c6eba1b28432b9d4d97b642">&#9670;&nbsp;</a></span>getOptionCount()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">size_t pcpp::IPv4Layer::getOptionCount </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">
<dl class="section return"><dt>Returns</dt><dd>The number of IPv4 options in this layer </dd></dl>

</div>
</div>
<a id="a86b9683e20dc9b78ec7c885b2f5ff87c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a86b9683e20dc9b78ec7c885b2f5ff87c">&#9670;&nbsp;</a></span>getOsiModelLayer()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="namespacepcpp.html#a69e2ee6a9dc68797612cf8dc38461025">OsiModelLayer</a> pcpp::IPv4Layer::getOsiModelLayer </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">override</span><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<dl class="section return"><dt>Returns</dt><dd>The OSI Model layer this protocol belongs to </dd></dl>

<p>Implements <a class="el" href="classpcpp_1_1_layer.html#af9e51f48a58a3b0dcd1a7341111c66e0">pcpp::Layer</a>.</p>

</div>
</div>
<a id="a28a052e25199e7be029851006af0073b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a28a052e25199e7be029851006af0073b">&#9670;&nbsp;</a></span>getSrcIPAddress()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classpcpp_1_1_i_p_address.html">IPAddress</a> pcpp::IPv4Layer::getSrcIPAddress </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">override</span><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Get the source IP address in the form of <a class="el" href="classpcpp_1_1_i_p_address.html">IPAddress</a>. This method is very similar to <a class="el" href="classpcpp_1_1_i_pv4_layer.html#a1726f094f39326d963d7343022764937">getSrcIPv4Address()</a>, but adds a level of abstraction because <a class="el" href="classpcpp_1_1_i_p_address.html">IPAddress</a> can be used for both IPv4 and IPv6 addresses </p><dl class="section return"><dt>Returns</dt><dd>An <a class="el" href="classpcpp_1_1_i_p_address.html">IPAddress</a> containing the source address </dd></dl>

<p>Implements <a class="el" href="classpcpp_1_1_i_p_layer.html#a7afd6c9806facdb60435968120925e7d">pcpp::IPLayer</a>.</p>

</div>
</div>
<a id="a1726f094f39326d963d7343022764937"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a1726f094f39326d963d7343022764937">&#9670;&nbsp;</a></span>getSrcIPv4Address()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classpcpp_1_1_i_pv4_address.html">IPv4Address</a> pcpp::IPv4Layer::getSrcIPv4Address </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Get the source IP address in the form of <a class="el" href="classpcpp_1_1_i_pv4_address.html">IPv4Address</a> </p><dl class="section return"><dt>Returns</dt><dd>An <a class="el" href="classpcpp_1_1_i_pv4_address.html">IPv4Address</a> containing the source address </dd></dl>

</div>
</div>
<a id="a30a31b2faebb821b09567a3d310e2b46"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a30a31b2faebb821b09567a3d310e2b46">&#9670;&nbsp;</a></span>isDataValid()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool pcpp::IPv4Layer::isDataValid </td>
          <td>(</td>
          <td class="paramtype">const uint8_t *&#160;</td>
          <td class="paramname"><em>data</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>dataLen</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>A static method that validates the input data </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">data</td><td>The pointer to the beginning of a byte stream of IP packet </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">dataLen</td><td>The length of the byte stream </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>True if the data is valid and can represent an IPv4 packet </dd></dl>

</div>
</div>
<a id="ad225191b00811a73536485846fd9936d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ad225191b00811a73536485846fd9936d">&#9670;&nbsp;</a></span>isFirstFragment()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool pcpp::IPv4Layer::isFirstFragment </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">
<dl class="section return"><dt>Returns</dt><dd>True if this packet is a fragment (in sense of IP fragmentation) and is the first fragment (which usually contains the L4 header). Return false otherwise (not a fragment or not the first fragment) </dd></dl>

</div>
</div>
<a id="a5cf53b28a9dea46455a757c008a16382"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a5cf53b28a9dea46455a757c008a16382">&#9670;&nbsp;</a></span>isFragment()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool pcpp::IPv4Layer::isFragment </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">
<dl class="section return"><dt>Returns</dt><dd>True if this packet is a fragment (in sense of IP fragmentation), false otherwise </dd></dl>

</div>
</div>
<a id="a8a681d88811ec5256efd270edf2b943d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a8a681d88811ec5256efd270edf2b943d">&#9670;&nbsp;</a></span>isLastFragment()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool pcpp::IPv4Layer::isLastFragment </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">
<dl class="section return"><dt>Returns</dt><dd>True if this packet is a fragment (in sense of IP fragmentation) and is the last fragment. Return false otherwise (not a fragment or not the last fragment) </dd></dl>

</div>
</div>
<a id="a970afc622e4984256059ae80031dd38d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a970afc622e4984256059ae80031dd38d">&#9670;&nbsp;</a></span>operator=()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classpcpp_1_1_i_pv4_layer.html">IPv4Layer</a>&amp; pcpp::IPv4Layer::operator= </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classpcpp_1_1_i_pv4_layer.html">IPv4Layer</a> &amp;&#160;</td>
          <td class="paramname"><em>other</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>An assignment operator that first delete all data from current layer and then copy the entire header from the other <a class="el" href="classpcpp_1_1_i_pv4_layer.html">IPv4Layer</a> (including IPv4 options) </p>

</div>
</div>
<a id="a2f15a23dd9617ef6c639679acc16b06a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a2f15a23dd9617ef6c639679acc16b06a">&#9670;&nbsp;</a></span>parseNextLayer()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void pcpp::IPv4Layer::parseNextLayer </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">override</span><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Currently identifies the following next layers:</p><ul>
<li><a class="el" href="classpcpp_1_1_udp_layer.html">UdpLayer</a></li>
<li><a class="el" href="classpcpp_1_1_tcp_layer.html">TcpLayer</a></li>
<li><a class="el" href="classpcpp_1_1_icmp_layer.html">IcmpLayer</a></li>
<li><a class="el" href="classpcpp_1_1_i_pv4_layer.html">IPv4Layer</a> (IP-in-IP)</li>
<li><a class="el" href="classpcpp_1_1_i_pv6_layer.html">IPv6Layer</a> (IP-in-IP)</li>
<li><a class="el" href="classpcpp_1_1_gre_layer.html">GreLayer</a></li>
<li><a class="el" href="classpcpp_1_1_igmp_layer.html">IgmpLayer</a></li>
<li><a class="el" href="classpcpp_1_1_authentication_header_layer.html">AuthenticationHeaderLayer</a> (IPSec)</li>
<li><a class="el" href="classpcpp_1_1_e_s_p_layer.html">ESPLayer</a> (IPSec)</li>
</ul>
<p>Otherwise sets <a class="el" href="classpcpp_1_1_payload_layer.html">PayloadLayer</a> </p>

<p>Implements <a class="el" href="classpcpp_1_1_layer.html#a6a8410015168a7fa42a7d71ac5b86673">pcpp::Layer</a>.</p>

</div>
</div>
<a id="a03640d65fc57a0b78541a369eec391c2"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a03640d65fc57a0b78541a369eec391c2">&#9670;&nbsp;</a></span>removeAllOptions()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool pcpp::IPv4Layer::removeAllOptions </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Remove all IPv4 options from the layer </p><dl class="section return"><dt>Returns</dt><dd>True if options removed successfully or false if some error occurred (an appropriate error message will be printed to log) </dd></dl>

</div>
</div>
<a id="ac99e55cc416df24b19241493fe4d9906"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ac99e55cc416df24b19241493fe4d9906">&#9670;&nbsp;</a></span>removeOption()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool pcpp::IPv4Layer::removeOption </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="namespacepcpp.html#a4ac8e7540b72db061b0078f1e2ca2b68">IPv4OptionTypes</a>&#160;</td>
          <td class="paramname"><em>option</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Remove an IPv4 option </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">option</td><td>The option type to remove </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>True if option was removed successfully or false if option type wasn't found or failed to shorten the layer. If an option appears twice in the layer, its first instance will be removed </dd></dl>

</div>
</div>
<a id="a6dfa29c3f8e93ce0e72d5abb96e59ce8"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a6dfa29c3f8e93ce0e72d5abb96e59ce8">&#9670;&nbsp;</a></span>setDstIPv4Address()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void pcpp::IPv4Layer::setDstIPv4Address </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classpcpp_1_1_i_pv4_address.html">IPv4Address</a> &amp;&#160;</td>
          <td class="paramname"><em>ipAddr</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Set the dest IP address </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">ipAddr</td><td>The IP address to set </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a73890160a9c3a32df28aa6cb0f4a752f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a73890160a9c3a32df28aa6cb0f4a752f">&#9670;&nbsp;</a></span>setSrcIPv4Address()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void pcpp::IPv4Layer::setSrcIPv4Address </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classpcpp_1_1_i_pv4_address.html">IPv4Address</a> &amp;&#160;</td>
          <td class="paramname"><em>ipAddr</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Set the source IP address </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">ipAddr</td><td>The IP address to set </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="ae8fb318c4185d63e55ee08f1991529be"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ae8fb318c4185d63e55ee08f1991529be">&#9670;&nbsp;</a></span>toString()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">std::string pcpp::IPv4Layer::toString </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">override</span><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<dl class="section return"><dt>Returns</dt><dd>A string representation of the layer most important data (should look like the layer description in Wireshark) </dd></dl>

<p>Implements <a class="el" href="classpcpp_1_1_layer.html#a1d07ea14d02b4a5cb383f89b3f40ed63">pcpp::Layer</a>.</p>

</div>
</div>
</div><!-- contents -->
</div><!-- doc-content -->
<!-- start footer part -->
<div id="nav-path" class="navpath"><!-- id is needed for treeview function! -->
  <ul>
    <li class="navelem"><a class="el" href="namespacepcpp.html">pcpp</a></li><li class="navelem"><a class="el" href="classpcpp_1_1_i_pv4_layer.html">IPv4Layer</a></li>
    <li class="footer">Generated on Thu Jun 12 2025 03:23:14 for PcapPlusPlus by <a href="https://www.doxygen.org/index.html"><img class="footer" src="doxygen.svg" width="104" height="31" alt="doxygen"/></a> 1.9.1 </li>
  </ul>
</div>
</body>
</html>
