<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "https://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=9"/>
<meta name="generator" content="Doxygen 1.9.1"/>
<meta name="viewport" content="width=device-width, initial-scale=1"/>
<title>PcapPlusPlus: pcpp::DnsLayer Class Reference</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<link href="navtree.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="resize.js"></script>
<script type="text/javascript" src="navtreedata.js"></script>
<script type="text/javascript" src="navtree.js"></script>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/searchdata.js"></script>
<script type="text/javascript" src="search/search.js"></script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
<link href="doxygen-mobile.css" rel="stylesheet" type="text/css"/>
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr style="height: 56px;">
  <td id="projectlogo"><img alt="Logo" src="logo_icon_large.ico"/></td>
  <td id="projectalign" style="padding-left: 0.5em;">
   <div id="projectname">PcapPlusPlus
   &#160;<span id="projectnumber">Next</span>
   </div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.9.1 -->
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:cf05388f2679ee054f2beb29a391d25f4e673ac3&amp;dn=gpl-2.0.txt GPL-v2 */
var searchBox = new SearchBox("searchBox", "search",false,'Search','.html');
/* @license-end */
</script>
<script type="text/javascript" src="menudata.js"></script>
<script type="text/javascript" src="menu.js"></script>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:cf05388f2679ee054f2beb29a391d25f4e673ac3&amp;dn=gpl-2.0.txt GPL-v2 */
$(function() {
  initMenu('',true,false,'search.php','Search');
  $(document).ready(function() { init_search(); });
});
/* @license-end */</script>
<div id="main-nav"></div>
</div><!-- top -->
<div id="side-nav" class="ui-resizable side-nav-resizable">
  <div id="nav-tree">
    <div id="nav-tree-contents">
      <div id="nav-sync" class="sync"></div>
    </div>
  </div>
  <div id="splitbar" style="-moz-user-select:none;" 
       class="ui-resizable-handle">
  </div>
</div>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:cf05388f2679ee054f2beb29a391d25f4e673ac3&amp;dn=gpl-2.0.txt GPL-v2 */
$(document).ready(function(){initNavTree('classpcpp_1_1_dns_layer.html',''); initResizable(); });
/* @license-end */
</script>
<div id="doc-content">
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
</div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<iframe src="javascript:void(0)" frameborder="0" 
        name="MSearchResults" id="MSearchResults">
</iframe>
</div>

<div class="header">
  <div class="summary">
<a href="#pub-methods">Public Member Functions</a> &#124;
<a href="#pub-static-methods">Static Public Member Functions</a> &#124;
<a href="classpcpp_1_1_dns_layer-members.html">List of all members</a>  </div>
  <div class="headertitle">
<div class="title">pcpp::DnsLayer Class Reference</div>  </div>
</div><!--header-->
<div class="contents">

<p><code>#include &lt;<a class="el" href="_dns_layer_8h_source.html">DnsLayer.h</a>&gt;</code></p>
<div class="dynheader">
Inheritance diagram for pcpp::DnsLayer:</div>
<div class="dyncontent">
 <div class="center">
  <img src="classpcpp_1_1_dns_layer.png" usemap="#pcpp::DnsLayer_map" alt=""/>
  <map id="pcpp::DnsLayer_map" name="pcpp::DnsLayer_map">
<area href="classpcpp_1_1_layer.html" alt="pcpp::Layer" shape="rect" coords="0,56,151,80"/>
<area href="classpcpp_1_1_i_data_container.html" alt="pcpp::IDataContainer" shape="rect" coords="0,0,151,24"/>
<area href="classpcpp_1_1_dns_over_tcp_layer.html" alt="pcpp::DnsOverTcpLayer" shape="rect" coords="0,168,151,192"/>
  </map>
</div></div>
<table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="pub-methods"></a>
Public Member Functions</h2></td></tr>
<tr class="memitem:a0436e0ee0837c38dea261bba282186f5"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classpcpp_1_1_dns_layer.html#a0436e0ee0837c38dea261bba282186f5">DnsLayer</a> (uint8_t *data, size_t dataLen, <a class="el" href="classpcpp_1_1_layer.html">Layer</a> *prevLayer, <a class="el" href="classpcpp_1_1_packet.html">Packet</a> *packet)</td></tr>
<tr class="separator:a0436e0ee0837c38dea261bba282186f5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a265b0721e4d566fc58a5407dd343fa14"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classpcpp_1_1_dns_layer.html#a265b0721e4d566fc58a5407dd343fa14">DnsLayer</a> ()</td></tr>
<tr class="separator:a265b0721e4d566fc58a5407dd343fa14"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a86121249746b9e95024788b6ef398a72"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classpcpp_1_1_dns_layer.html#a86121249746b9e95024788b6ef398a72">DnsLayer</a> (const <a class="el" href="classpcpp_1_1_dns_layer.html">DnsLayer</a> &amp;other)</td></tr>
<tr class="separator:a86121249746b9e95024788b6ef398a72"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae265ed7f1e5ce8b8480db3c9b0ca6c34"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classpcpp_1_1_dns_layer.html">DnsLayer</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classpcpp_1_1_dns_layer.html#ae265ed7f1e5ce8b8480db3c9b0ca6c34">operator=</a> (const <a class="el" href="classpcpp_1_1_dns_layer.html">DnsLayer</a> &amp;other)</td></tr>
<tr class="separator:ae265ed7f1e5ce8b8480db3c9b0ca6c34"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab41ca313a68af72ebdd234067c035efe"><td class="memItemLeft" align="right" valign="top"><a class="el" href="structpcpp_1_1dnshdr.html">dnshdr</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classpcpp_1_1_dns_layer.html#ab41ca313a68af72ebdd234067c035efe">getDnsHeader</a> () const</td></tr>
<tr class="separator:ab41ca313a68af72ebdd234067c035efe"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1e350c5f5c2686900c91a8753f70745b"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classpcpp_1_1_dns_query.html">DnsQuery</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classpcpp_1_1_dns_layer.html#a1e350c5f5c2686900c91a8753f70745b">getQuery</a> (const std::string &amp;name, bool exactMatch) const</td></tr>
<tr class="separator:a1e350c5f5c2686900c91a8753f70745b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ace109477462370e2142dc1ca519154ee"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classpcpp_1_1_dns_query.html">DnsQuery</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classpcpp_1_1_dns_layer.html#ace109477462370e2142dc1ca519154ee">getFirstQuery</a> () const</td></tr>
<tr class="separator:ace109477462370e2142dc1ca519154ee"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8919c2d63dca7d0653e18d0cd1081dd1"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classpcpp_1_1_dns_query.html">DnsQuery</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classpcpp_1_1_dns_layer.html#a8919c2d63dca7d0653e18d0cd1081dd1">getNextQuery</a> (<a class="el" href="classpcpp_1_1_dns_query.html">DnsQuery</a> *query) const</td></tr>
<tr class="separator:a8919c2d63dca7d0653e18d0cd1081dd1"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a647e6683f885b3b75aaacb2665af741d"><td class="memItemLeft" align="right" valign="top">size_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classpcpp_1_1_dns_layer.html#a647e6683f885b3b75aaacb2665af741d">getQueryCount</a> () const</td></tr>
<tr class="separator:a647e6683f885b3b75aaacb2665af741d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a80db9f0dfb1b6c4641a0357b54e47138"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classpcpp_1_1_dns_query.html">DnsQuery</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classpcpp_1_1_dns_layer.html#a80db9f0dfb1b6c4641a0357b54e47138">addQuery</a> (const std::string &amp;name, <a class="el" href="namespacepcpp.html#ad888578fe7df9849bbfbb10cdf245886">DnsType</a> dnsType, <a class="el" href="namespacepcpp.html#a9a53cd13fb37fed91d2acda175bee7b9">DnsClass</a> dnsClass)</td></tr>
<tr class="separator:a80db9f0dfb1b6c4641a0357b54e47138"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3d36a88b61c4cf83ef5b20748d589ab8"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classpcpp_1_1_dns_query.html">DnsQuery</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classpcpp_1_1_dns_layer.html#a3d36a88b61c4cf83ef5b20748d589ab8">addQuery</a> (<a class="el" href="classpcpp_1_1_dns_query.html">DnsQuery</a> *const copyQuery)</td></tr>
<tr class="separator:a3d36a88b61c4cf83ef5b20748d589ab8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5952988d68c6a82e38347a403f43f389"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classpcpp_1_1_dns_layer.html#a5952988d68c6a82e38347a403f43f389">removeQuery</a> (const std::string &amp;queryNameToRemove, bool exactMatch)</td></tr>
<tr class="separator:a5952988d68c6a82e38347a403f43f389"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa62ae344b6dd0ff36ac17242ba7971e2"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classpcpp_1_1_dns_layer.html#aa62ae344b6dd0ff36ac17242ba7971e2">removeQuery</a> (<a class="el" href="classpcpp_1_1_dns_query.html">DnsQuery</a> *queryToRemove)</td></tr>
<tr class="separator:aa62ae344b6dd0ff36ac17242ba7971e2"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:afaef9bb50d5fc4c2118f2b8f4b9f0ea1"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classpcpp_1_1_dns_resource.html">DnsResource</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classpcpp_1_1_dns_layer.html#afaef9bb50d5fc4c2118f2b8f4b9f0ea1">getAnswer</a> (const std::string &amp;name, bool exactMatch) const</td></tr>
<tr class="separator:afaef9bb50d5fc4c2118f2b8f4b9f0ea1"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a03dd71c23b128df508102f22f37c3e4b"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classpcpp_1_1_dns_resource.html">DnsResource</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classpcpp_1_1_dns_layer.html#a03dd71c23b128df508102f22f37c3e4b">getFirstAnswer</a> () const</td></tr>
<tr class="separator:a03dd71c23b128df508102f22f37c3e4b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7102c8ac9508e1f6117424ba88c33c3b"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classpcpp_1_1_dns_resource.html">DnsResource</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classpcpp_1_1_dns_layer.html#a7102c8ac9508e1f6117424ba88c33c3b">getNextAnswer</a> (<a class="el" href="classpcpp_1_1_dns_resource.html">DnsResource</a> *answer) const</td></tr>
<tr class="separator:a7102c8ac9508e1f6117424ba88c33c3b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab2db39d9dfa0044636b2b1a90282a90a"><td class="memItemLeft" align="right" valign="top">size_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classpcpp_1_1_dns_layer.html#ab2db39d9dfa0044636b2b1a90282a90a">getAnswerCount</a> () const</td></tr>
<tr class="separator:ab2db39d9dfa0044636b2b1a90282a90a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ace54e503fc50bdb783230cbcdd32d71a"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classpcpp_1_1_dns_resource.html">DnsResource</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classpcpp_1_1_dns_layer.html#ace54e503fc50bdb783230cbcdd32d71a">addAnswer</a> (const std::string &amp;name, <a class="el" href="namespacepcpp.html#ad888578fe7df9849bbfbb10cdf245886">DnsType</a> dnsType, <a class="el" href="namespacepcpp.html#a9a53cd13fb37fed91d2acda175bee7b9">DnsClass</a> dnsClass, uint32_t ttl, <a class="el" href="classpcpp_1_1_i_dns_resource_data.html">IDnsResourceData</a> *data)</td></tr>
<tr class="separator:ace54e503fc50bdb783230cbcdd32d71a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a54f0f2f9e7e087b51e8c0737fdbd6e4e"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classpcpp_1_1_dns_resource.html">DnsResource</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classpcpp_1_1_dns_layer.html#a54f0f2f9e7e087b51e8c0737fdbd6e4e">addAnswer</a> (<a class="el" href="classpcpp_1_1_dns_resource.html">DnsResource</a> *const copyAnswer)</td></tr>
<tr class="separator:a54f0f2f9e7e087b51e8c0737fdbd6e4e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:adad4f490b373d2f5ecc70ceebdb2cf11"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classpcpp_1_1_dns_layer.html#adad4f490b373d2f5ecc70ceebdb2cf11">removeAnswer</a> (const std::string &amp;answerNameToRemove, bool exactMatch)</td></tr>
<tr class="separator:adad4f490b373d2f5ecc70ceebdb2cf11"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac8d534e0aac68d7b07af23f50dfb7c3d"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classpcpp_1_1_dns_layer.html#ac8d534e0aac68d7b07af23f50dfb7c3d">removeAnswer</a> (<a class="el" href="classpcpp_1_1_dns_resource.html">DnsResource</a> *answerToRemove)</td></tr>
<tr class="separator:ac8d534e0aac68d7b07af23f50dfb7c3d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a48c69904b29447a47b4042424e7fb932"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classpcpp_1_1_dns_resource.html">DnsResource</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classpcpp_1_1_dns_layer.html#a48c69904b29447a47b4042424e7fb932">getAuthority</a> (const std::string &amp;name, bool exactMatch) const</td></tr>
<tr class="separator:a48c69904b29447a47b4042424e7fb932"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9d3eb712860aa5858952e34fd97a6267"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classpcpp_1_1_dns_resource.html">DnsResource</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classpcpp_1_1_dns_layer.html#a9d3eb712860aa5858952e34fd97a6267">getFirstAuthority</a> () const</td></tr>
<tr class="separator:a9d3eb712860aa5858952e34fd97a6267"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a687ae5806f248d36ce3ca9b7e7191ef4"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classpcpp_1_1_dns_resource.html">DnsResource</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classpcpp_1_1_dns_layer.html#a687ae5806f248d36ce3ca9b7e7191ef4">getNextAuthority</a> (<a class="el" href="classpcpp_1_1_dns_resource.html">DnsResource</a> *authority) const</td></tr>
<tr class="separator:a687ae5806f248d36ce3ca9b7e7191ef4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa67e72b9b1a28340b2c0f3fc7216524a"><td class="memItemLeft" align="right" valign="top">size_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classpcpp_1_1_dns_layer.html#aa67e72b9b1a28340b2c0f3fc7216524a">getAuthorityCount</a> () const</td></tr>
<tr class="separator:aa67e72b9b1a28340b2c0f3fc7216524a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab82d02a7bd0add2923b77739d807f00f"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classpcpp_1_1_dns_resource.html">DnsResource</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classpcpp_1_1_dns_layer.html#ab82d02a7bd0add2923b77739d807f00f">addAuthority</a> (const std::string &amp;name, <a class="el" href="namespacepcpp.html#ad888578fe7df9849bbfbb10cdf245886">DnsType</a> dnsType, <a class="el" href="namespacepcpp.html#a9a53cd13fb37fed91d2acda175bee7b9">DnsClass</a> dnsClass, uint32_t ttl, <a class="el" href="classpcpp_1_1_i_dns_resource_data.html">IDnsResourceData</a> *data)</td></tr>
<tr class="separator:ab82d02a7bd0add2923b77739d807f00f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a368f61a098f65ee8f07f9e6dd6de08b4"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classpcpp_1_1_dns_resource.html">DnsResource</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classpcpp_1_1_dns_layer.html#a368f61a098f65ee8f07f9e6dd6de08b4">addAuthority</a> (<a class="el" href="classpcpp_1_1_dns_resource.html">DnsResource</a> *const copyAuthority)</td></tr>
<tr class="separator:a368f61a098f65ee8f07f9e6dd6de08b4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9274ccfb5fe3f407e8b05367f59072c7"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classpcpp_1_1_dns_layer.html#a9274ccfb5fe3f407e8b05367f59072c7">removeAuthority</a> (const std::string &amp;authorityNameToRemove, bool exactMatch)</td></tr>
<tr class="separator:a9274ccfb5fe3f407e8b05367f59072c7"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae957f7b50adade0c014ab8007f4009bd"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classpcpp_1_1_dns_layer.html#ae957f7b50adade0c014ab8007f4009bd">removeAuthority</a> (<a class="el" href="classpcpp_1_1_dns_resource.html">DnsResource</a> *authorityToRemove)</td></tr>
<tr class="separator:ae957f7b50adade0c014ab8007f4009bd"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5f5c565893d83e77bfd9c8d1bdbc6138"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classpcpp_1_1_dns_resource.html">DnsResource</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classpcpp_1_1_dns_layer.html#a5f5c565893d83e77bfd9c8d1bdbc6138">getAdditionalRecord</a> (const std::string &amp;name, bool exactMatch) const</td></tr>
<tr class="separator:a5f5c565893d83e77bfd9c8d1bdbc6138"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a89344ae5f11f82fd8ec39286c2c6155c"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classpcpp_1_1_dns_resource.html">DnsResource</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classpcpp_1_1_dns_layer.html#a89344ae5f11f82fd8ec39286c2c6155c">getFirstAdditionalRecord</a> () const</td></tr>
<tr class="separator:a89344ae5f11f82fd8ec39286c2c6155c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac9f8e189bbce677dfbf0508c45bb3310"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classpcpp_1_1_dns_resource.html">DnsResource</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classpcpp_1_1_dns_layer.html#ac9f8e189bbce677dfbf0508c45bb3310">getNextAdditionalRecord</a> (<a class="el" href="classpcpp_1_1_dns_resource.html">DnsResource</a> *additionalRecord) const</td></tr>
<tr class="separator:ac9f8e189bbce677dfbf0508c45bb3310"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af097c5a204e4f1c5d44615ac55e220b3"><td class="memItemLeft" align="right" valign="top">size_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classpcpp_1_1_dns_layer.html#af097c5a204e4f1c5d44615ac55e220b3">getAdditionalRecordCount</a> () const</td></tr>
<tr class="separator:af097c5a204e4f1c5d44615ac55e220b3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0dd1af1576d477b722995c94a15c94f5"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classpcpp_1_1_dns_resource.html">DnsResource</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classpcpp_1_1_dns_layer.html#a0dd1af1576d477b722995c94a15c94f5">addAdditionalRecord</a> (const std::string &amp;name, <a class="el" href="namespacepcpp.html#ad888578fe7df9849bbfbb10cdf245886">DnsType</a> dnsType, <a class="el" href="namespacepcpp.html#a9a53cd13fb37fed91d2acda175bee7b9">DnsClass</a> dnsClass, uint32_t ttl, <a class="el" href="classpcpp_1_1_i_dns_resource_data.html">IDnsResourceData</a> *data)</td></tr>
<tr class="separator:a0dd1af1576d477b722995c94a15c94f5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1e9dee5f5a0433290c5c0bb3f149c30c"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classpcpp_1_1_dns_resource.html">DnsResource</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classpcpp_1_1_dns_layer.html#a1e9dee5f5a0433290c5c0bb3f149c30c">addAdditionalRecord</a> (const std::string &amp;name, <a class="el" href="namespacepcpp.html#ad888578fe7df9849bbfbb10cdf245886">DnsType</a> dnsType, uint16_t customData1, uint32_t customData2, <a class="el" href="classpcpp_1_1_i_dns_resource_data.html">IDnsResourceData</a> *data)</td></tr>
<tr class="separator:a1e9dee5f5a0433290c5c0bb3f149c30c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a54bc27af135cbe058ebc9ad14664841c"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classpcpp_1_1_dns_resource.html">DnsResource</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classpcpp_1_1_dns_layer.html#a54bc27af135cbe058ebc9ad14664841c">addAdditionalRecord</a> (<a class="el" href="classpcpp_1_1_dns_resource.html">DnsResource</a> *const copyAdditionalRecord)</td></tr>
<tr class="separator:a54bc27af135cbe058ebc9ad14664841c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad8bf786e4e820138e07eb1a242d7af20"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classpcpp_1_1_dns_layer.html#ad8bf786e4e820138e07eb1a242d7af20">removeAdditionalRecord</a> (const std::string &amp;additionalRecordNameToRemove, bool exactMatch)</td></tr>
<tr class="separator:ad8bf786e4e820138e07eb1a242d7af20"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a523b41db73c4105c0d9627cd2b02294d"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classpcpp_1_1_dns_layer.html#a523b41db73c4105c0d9627cd2b02294d">removeAdditionalRecord</a> (<a class="el" href="classpcpp_1_1_dns_resource.html">DnsResource</a> *additionalRecordToRemove)</td></tr>
<tr class="separator:a523b41db73c4105c0d9627cd2b02294d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab627b59fa753737f4fd8f61a961f1c3b"><td class="memItemLeft" align="right" valign="top"><a id="ab627b59fa753737f4fd8f61a961f1c3b"></a>
void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classpcpp_1_1_dns_layer.html#ab627b59fa753737f4fd8f61a961f1c3b">parseNextLayer</a> () override</td></tr>
<tr class="memdesc:ab627b59fa753737f4fd8f61a961f1c3b"><td class="mdescLeft">&#160;</td><td class="mdescRight">Does nothing for this layer (<a class="el" href="classpcpp_1_1_dns_layer.html">DnsLayer</a> is always last) <br /></td></tr>
<tr class="separator:ab627b59fa753737f4fd8f61a961f1c3b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a133cb88fd6984bdc4a48a60c143f2ff7"><td class="memItemLeft" align="right" valign="top">size_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classpcpp_1_1_dns_layer.html#a133cb88fd6984bdc4a48a60c143f2ff7">getHeaderLen</a> () const override</td></tr>
<tr class="separator:a133cb88fd6984bdc4a48a60c143f2ff7"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a73c2d8737c0dd6593def4bedcefc0003"><td class="memItemLeft" align="right" valign="top"><a id="a73c2d8737c0dd6593def4bedcefc0003"></a>
void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classpcpp_1_1_dns_layer.html#a73c2d8737c0dd6593def4bedcefc0003">computeCalculateFields</a> () override</td></tr>
<tr class="memdesc:a73c2d8737c0dd6593def4bedcefc0003"><td class="mdescLeft">&#160;</td><td class="mdescRight">Does nothing for this layer. <br /></td></tr>
<tr class="separator:a73c2d8737c0dd6593def4bedcefc0003"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6baa949f6174f120cb2c911ac77fcb92"><td class="memItemLeft" align="right" valign="top">std::string&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classpcpp_1_1_dns_layer.html#a6baa949f6174f120cb2c911ac77fcb92">toString</a> () const override</td></tr>
<tr class="separator:a6baa949f6174f120cb2c911ac77fcb92"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aee533934d4b8e65ffe7aca9d81910b1f"><td class="memItemLeft" align="right" valign="top"><a class="el" href="namespacepcpp.html#a69e2ee6a9dc68797612cf8dc38461025">OsiModelLayer</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classpcpp_1_1_dns_layer.html#aee533934d4b8e65ffe7aca9d81910b1f">getOsiModelLayer</a> () const override</td></tr>
<tr class="separator:aee533934d4b8e65ffe7aca9d81910b1f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="inherit_header pub_methods_classpcpp_1_1_layer"><td colspan="2" onclick="javascript:toggleInherit('pub_methods_classpcpp_1_1_layer')"><img src="closed.png" alt="-"/>&#160;Public Member Functions inherited from <a class="el" href="classpcpp_1_1_layer.html">pcpp::Layer</a></td></tr>
<tr class="memitem:adc5fdf997375b58400a55fdcc3bdff87 inherit pub_methods_classpcpp_1_1_layer"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classpcpp_1_1_layer.html#adc5fdf997375b58400a55fdcc3bdff87">~Layer</a> () override</td></tr>
<tr class="separator:adc5fdf997375b58400a55fdcc3bdff87 inherit pub_methods_classpcpp_1_1_layer"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a73b23d182802ec4ac4021042897eb410 inherit pub_methods_classpcpp_1_1_layer"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classpcpp_1_1_layer.html">Layer</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classpcpp_1_1_layer.html#a73b23d182802ec4ac4021042897eb410">getNextLayer</a> () const</td></tr>
<tr class="separator:a73b23d182802ec4ac4021042897eb410 inherit pub_methods_classpcpp_1_1_layer"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9ff77f4ee3f160057f49db645a5c19bd inherit pub_methods_classpcpp_1_1_layer"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classpcpp_1_1_layer.html">Layer</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classpcpp_1_1_layer.html#a9ff77f4ee3f160057f49db645a5c19bd">getPrevLayer</a> () const</td></tr>
<tr class="separator:a9ff77f4ee3f160057f49db645a5c19bd inherit pub_methods_classpcpp_1_1_layer"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab8c7cc855405c99b5fdfd778324241ef inherit pub_methods_classpcpp_1_1_layer"><td class="memItemLeft" align="right" valign="top"><a class="el" href="namespacepcpp.html#a1d761f7cf37d3b1efb1574fb1177e6eb">ProtocolType</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classpcpp_1_1_layer.html#ab8c7cc855405c99b5fdfd778324241ef">getProtocol</a> () const</td></tr>
<tr class="separator:ab8c7cc855405c99b5fdfd778324241ef inherit pub_methods_classpcpp_1_1_layer"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a73339cf991e01301a34ec602ba9ec7d9 inherit pub_methods_classpcpp_1_1_layer"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classpcpp_1_1_layer.html#a73339cf991e01301a34ec602ba9ec7d9">isMemberOfProtocolFamily</a> (<a class="el" href="namespacepcpp.html#aa26bae020a295f1089e08c390fb21c52">ProtocolTypeFamily</a> protocolTypeFamily) const</td></tr>
<tr class="separator:a73339cf991e01301a34ec602ba9ec7d9 inherit pub_methods_classpcpp_1_1_layer"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4e3c72d568a8d43c0fd82d781255e98f inherit pub_methods_classpcpp_1_1_layer"><td class="memItemLeft" align="right" valign="top">uint8_t *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classpcpp_1_1_layer.html#a4e3c72d568a8d43c0fd82d781255e98f">getData</a> () const</td></tr>
<tr class="separator:a4e3c72d568a8d43c0fd82d781255e98f inherit pub_methods_classpcpp_1_1_layer"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a33e4747c33cba0050ac90beeda45aa7b inherit pub_methods_classpcpp_1_1_layer"><td class="memItemLeft" align="right" valign="top">size_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classpcpp_1_1_layer.html#a33e4747c33cba0050ac90beeda45aa7b">getDataLen</a> () const</td></tr>
<tr class="separator:a33e4747c33cba0050ac90beeda45aa7b inherit pub_methods_classpcpp_1_1_layer"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0bd73bce6a07ea942d3d88bd472944ec inherit pub_methods_classpcpp_1_1_layer"><td class="memItemLeft" align="right" valign="top">uint8_t *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classpcpp_1_1_layer.html#a0bd73bce6a07ea942d3d88bd472944ec">getLayerPayload</a> () const</td></tr>
<tr class="separator:a0bd73bce6a07ea942d3d88bd472944ec inherit pub_methods_classpcpp_1_1_layer"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:abd87dfe9272183c2ea1c00752d7144c8 inherit pub_methods_classpcpp_1_1_layer"><td class="memItemLeft" align="right" valign="top">size_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classpcpp_1_1_layer.html#abd87dfe9272183c2ea1c00752d7144c8">getLayerPayloadSize</a> () const</td></tr>
<tr class="separator:abd87dfe9272183c2ea1c00752d7144c8 inherit pub_methods_classpcpp_1_1_layer"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8f9d719253a30852620f9595a99956ed inherit pub_methods_classpcpp_1_1_layer"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classpcpp_1_1_layer.html#a8f9d719253a30852620f9595a99956ed">isAllocatedToPacket</a> () const</td></tr>
<tr class="separator:a8f9d719253a30852620f9595a99956ed inherit pub_methods_classpcpp_1_1_layer"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a019a07d6f9d8fc7eb233e61826b11964 inherit pub_methods_classpcpp_1_1_layer"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classpcpp_1_1_layer.html#a019a07d6f9d8fc7eb233e61826b11964">copyData</a> (uint8_t *toArr) const</td></tr>
<tr class="separator:a019a07d6f9d8fc7eb233e61826b11964 inherit pub_methods_classpcpp_1_1_layer"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4c5d6f648a6878895a714004f937830d inherit pub_methods_classpcpp_1_1_layer"><td class="memItemLeft" align="right" valign="top">uint8_t *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classpcpp_1_1_layer.html#a4c5d6f648a6878895a714004f937830d">getDataPtr</a> (size_t offset=0) const override</td></tr>
<tr class="separator:a4c5d6f648a6878895a714004f937830d inherit pub_methods_classpcpp_1_1_layer"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="pub-static-methods"></a>
Static Public Member Functions</h2></td></tr>
<tr class="memitem:adc75f267b44dc4b8d42524aecc684fdd"><td class="memItemLeft" align="right" valign="top">static bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classpcpp_1_1_dns_layer.html#adc75f267b44dc4b8d42524aecc684fdd">isDnsPort</a> (uint16_t port)</td></tr>
<tr class="separator:adc75f267b44dc4b8d42524aecc684fdd"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3c3fa3e42b1d3f2b92128f06aa025a51"><td class="memItemLeft" align="right" valign="top">static bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classpcpp_1_1_dns_layer.html#a3c3fa3e42b1d3f2b92128f06aa025a51">isDataValid</a> (const uint8_t *data, size_t dataLen, bool dnsOverTcp=false)</td></tr>
<tr class="separator:a3c3fa3e42b1d3f2b92128f06aa025a51"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="inherited"></a>
Additional Inherited Members</h2></td></tr>
<tr class="inherit_header pro_methods_classpcpp_1_1_layer"><td colspan="2" onclick="javascript:toggleInherit('pro_methods_classpcpp_1_1_layer')"><img src="closed.png" alt="-"/>&#160;Protected Member Functions inherited from <a class="el" href="classpcpp_1_1_layer.html">pcpp::Layer</a></td></tr>
<tr class="memitem:a73210de1c3e4361189be96b40bf109d9 inherit pro_methods_classpcpp_1_1_layer"><td class="memTemplParams" colspan="2">template&lt;typename T , typename... Args&gt; </td></tr>
<tr class="memitem:a73210de1c3e4361189be96b40bf109d9 inherit pro_methods_classpcpp_1_1_layer"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="classpcpp_1_1_layer.html">Layer</a> *&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classpcpp_1_1_layer.html#a73210de1c3e4361189be96b40bf109d9">constructNextLayer</a> (uint8_t *data, size_t dataLen, <a class="el" href="classpcpp_1_1_packet.html">Packet</a> *packet, Args &amp;&amp;... extraArgs)</td></tr>
<tr class="separator:a73210de1c3e4361189be96b40bf109d9 inherit pro_methods_classpcpp_1_1_layer"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac180476870fbef9a104d775d81c70c74 inherit pro_methods_classpcpp_1_1_layer"><td class="memTemplParams" colspan="2">template&lt;typename T , typename TFallback , typename... Args&gt; </td></tr>
<tr class="memitem:ac180476870fbef9a104d775d81c70c74 inherit pro_methods_classpcpp_1_1_layer"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="classpcpp_1_1_layer.html">Layer</a> *&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classpcpp_1_1_layer.html#ac180476870fbef9a104d775d81c70c74">tryConstructNextLayerWithFallback</a> (uint8_t *data, size_t dataLen, <a class="el" href="classpcpp_1_1_packet.html">Packet</a> *packet, Args &amp;&amp;... extraArgs)</td></tr>
<tr class="separator:ac180476870fbef9a104d775d81c70c74 inherit pro_methods_classpcpp_1_1_layer"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="inherit_header pro_static_methods_classpcpp_1_1_layer"><td colspan="2" onclick="javascript:toggleInherit('pro_static_methods_classpcpp_1_1_layer')"><img src="closed.png" alt="-"/>&#160;Static Protected Member Functions inherited from <a class="el" href="classpcpp_1_1_layer.html">pcpp::Layer</a></td></tr>
<tr class="memitem:acb031e00ee13b0c299cc6c0458a61a18 inherit pro_static_methods_classpcpp_1_1_layer"><td class="memTemplParams" colspan="2">template&lt;typename T &gt; </td></tr>
<tr class="memitem:acb031e00ee13b0c299cc6c0458a61a18 inherit pro_static_methods_classpcpp_1_1_layer"><td class="memTemplItemLeft" align="right" valign="top">static bool&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classpcpp_1_1_layer.html#acb031e00ee13b0c299cc6c0458a61a18">canReinterpretAs</a> (const uint8_t *data, size_t dataLen)</td></tr>
<tr class="memdesc:acb031e00ee13b0c299cc6c0458a61a18 inherit pro_static_methods_classpcpp_1_1_layer"><td class="mdescLeft">&#160;</td><td class="mdescRight">Check if the data is large enough to reinterpret as a type.  <a href="classpcpp_1_1_layer.html#acb031e00ee13b0c299cc6c0458a61a18">More...</a><br /></td></tr>
<tr class="separator:acb031e00ee13b0c299cc6c0458a61a18 inherit pro_static_methods_classpcpp_1_1_layer"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table>
<a name="details" id="details"></a><h2 class="groupheader">Detailed Description</h2>
<div class="textblock"><p>Represents the DNS protocol layer </p>
</div><h2 class="groupheader">Constructor &amp; Destructor Documentation</h2>
<a id="a0436e0ee0837c38dea261bba282186f5"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a0436e0ee0837c38dea261bba282186f5">&#9670;&nbsp;</a></span>DnsLayer() <span class="overload">[1/3]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">pcpp::DnsLayer::DnsLayer </td>
          <td>(</td>
          <td class="paramtype">uint8_t *&#160;</td>
          <td class="paramname"><em>data</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>dataLen</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classpcpp_1_1_layer.html">Layer</a> *&#160;</td>
          <td class="paramname"><em>prevLayer</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classpcpp_1_1_packet.html">Packet</a> *&#160;</td>
          <td class="paramname"><em>packet</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>A constructor that creates the layer from an existing packet raw data </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">data</td><td>A pointer to the raw data </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">dataLen</td><td>Size of the data in bytes </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">prevLayer</td><td>A pointer to the previous layer </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">packet</td><td>A pointer to the <a class="el" href="classpcpp_1_1_packet.html">Packet</a> instance where layer will be stored in </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a265b0721e4d566fc58a5407dd343fa14"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a265b0721e4d566fc58a5407dd343fa14">&#9670;&nbsp;</a></span>DnsLayer() <span class="overload">[2/3]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">pcpp::DnsLayer::DnsLayer </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>A constructor that creates an empty DNS layer: all members of dnshdr are set to 0 and layer will contain no records </p>

</div>
</div>
<a id="a86121249746b9e95024788b6ef398a72"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a86121249746b9e95024788b6ef398a72">&#9670;&nbsp;</a></span>DnsLayer() <span class="overload">[3/3]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">pcpp::DnsLayer::DnsLayer </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classpcpp_1_1_dns_layer.html">DnsLayer</a> &amp;&#160;</td>
          <td class="paramname"><em>other</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>A copy constructor for this layer </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">other</td><td>The DNS layer to copy from </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<h2 class="groupheader">Member Function Documentation</h2>
<a id="a0dd1af1576d477b722995c94a15c94f5"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a0dd1af1576d477b722995c94a15c94f5">&#9670;&nbsp;</a></span>addAdditionalRecord() <span class="overload">[1/3]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classpcpp_1_1_dns_resource.html">DnsResource</a>* pcpp::DnsLayer::addAdditionalRecord </td>
          <td>(</td>
          <td class="paramtype">const std::string &amp;&#160;</td>
          <td class="paramname"><em>name</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="namespacepcpp.html#ad888578fe7df9849bbfbb10cdf245886">DnsType</a>&#160;</td>
          <td class="paramname"><em>dnsType</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="namespacepcpp.html#a9a53cd13fb37fed91d2acda175bee7b9">DnsClass</a>&#160;</td>
          <td class="paramname"><em>dnsClass</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint32_t&#160;</td>
          <td class="paramname"><em>ttl</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classpcpp_1_1_i_dns_resource_data.html">IDnsResourceData</a> *&#160;</td>
          <td class="paramname"><em>data</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Add a new DNS additional record to the layer </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">name</td><td>The value that shall be set in the name field of the additional record </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">dnsType</td><td>The value that shall be set in the DNS type field of the additional record </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">dnsClass</td><td>The value that shall be set in the DNS class field of the additional record </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">ttl</td><td>The value that shall be set in the 'time-to-leave' field of the additional record </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">data</td><td>The additional record data to be set. The type of the data should match the type of the DNS record (for example: DNS record of type A should have data of type <a class="el" href="classpcpp_1_1_i_pv4_dns_resource_data.html">IPv4DnsResourceData</a>. Please see <a class="el" href="classpcpp_1_1_dns_resource.html#ae2264452dae2d6df5e9d4c5f030eefad">DnsResource::setData()</a> for more info on this </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>A pointer to the newly created DNS additional record or nullptr if additional record could not be created (an appropriate error log message will be printed in this case) </dd></dl>

</div>
</div>
<a id="a1e9dee5f5a0433290c5c0bb3f149c30c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a1e9dee5f5a0433290c5c0bb3f149c30c">&#9670;&nbsp;</a></span>addAdditionalRecord() <span class="overload">[2/3]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classpcpp_1_1_dns_resource.html">DnsResource</a>* pcpp::DnsLayer::addAdditionalRecord </td>
          <td>(</td>
          <td class="paramtype">const std::string &amp;&#160;</td>
          <td class="paramname"><em>name</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="namespacepcpp.html#ad888578fe7df9849bbfbb10cdf245886">DnsType</a>&#160;</td>
          <td class="paramname"><em>dnsType</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint16_t&#160;</td>
          <td class="paramname"><em>customData1</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint32_t&#160;</td>
          <td class="paramname"><em>customData2</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classpcpp_1_1_i_dns_resource_data.html">IDnsResourceData</a> *&#160;</td>
          <td class="paramname"><em>data</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Add a new DNS additional record to the layer that doesn't have DNS class and TTL. Instead these bytes may contains some arbitrary data. In the future I may add support for these kinds of additional data records. For now, these bytes are set as raw </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">name</td><td>The value that shall be set in the name field of the additional record </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">dnsType</td><td>The value that shall be set in the DNS type field of the additional record </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">customData1</td><td>Two bytes of the arbitrary data that will be set in the offset usually used for the DNS class </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">customData2</td><td>Four bytes of the arbitrary data that will be set in the offset usually used for the TTL </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">data</td><td>The additional record data to be set. The type of the data should match the type of the DNS record. (for example: DNS record of type A should have data of type <a class="el" href="classpcpp_1_1_i_pv4_dns_resource_data.html">IPv4DnsResourceData</a>. Please see <a class="el" href="classpcpp_1_1_dns_resource.html#ae2264452dae2d6df5e9d4c5f030eefad">DnsResource::setData()</a> for more info on this </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>A pointer to the newly created DNS additional record or nullptr if additional record could not be created (an appropriate error log message will be printed in this case) </dd></dl>

</div>
</div>
<a id="a54bc27af135cbe058ebc9ad14664841c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a54bc27af135cbe058ebc9ad14664841c">&#9670;&nbsp;</a></span>addAdditionalRecord() <span class="overload">[3/3]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classpcpp_1_1_dns_resource.html">DnsResource</a>* pcpp::DnsLayer::addAdditionalRecord </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classpcpp_1_1_dns_resource.html">DnsResource</a> *const&#160;</td>
          <td class="paramname"><em>copyAdditionalRecord</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Add a new DNS additional record similar to an already existing DNS additional record. All additional record fields will be copied from the existing additional record </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">copyAdditionalRecord</td><td>The record to create the new record from. copyAdditionalRecord won't be changed in any way </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>A pointer to the newly created DNS additional record or nullptr if query could not be created (an appropriate error log message will be printed in this case) </dd></dl>

</div>
</div>
<a id="ace54e503fc50bdb783230cbcdd32d71a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ace54e503fc50bdb783230cbcdd32d71a">&#9670;&nbsp;</a></span>addAnswer() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classpcpp_1_1_dns_resource.html">DnsResource</a>* pcpp::DnsLayer::addAnswer </td>
          <td>(</td>
          <td class="paramtype">const std::string &amp;&#160;</td>
          <td class="paramname"><em>name</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="namespacepcpp.html#ad888578fe7df9849bbfbb10cdf245886">DnsType</a>&#160;</td>
          <td class="paramname"><em>dnsType</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="namespacepcpp.html#a9a53cd13fb37fed91d2acda175bee7b9">DnsClass</a>&#160;</td>
          <td class="paramname"><em>dnsClass</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint32_t&#160;</td>
          <td class="paramname"><em>ttl</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classpcpp_1_1_i_dns_resource_data.html">IDnsResourceData</a> *&#160;</td>
          <td class="paramname"><em>data</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Add a new DNS answer to the layer </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">name</td><td>The value that shall be set in the name field of the answer </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">dnsType</td><td>The value that shall be set in the DNS type field of the answer </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">dnsClass</td><td>The value that shall be set in the DNS class field of the answer </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">ttl</td><td>The value that shall be set in the 'time-to-leave' field of the answer </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">data</td><td>The answer data to be set. The type of the data should match the type of the DNS record (for example: DNS record of type A should have data of type <a class="el" href="classpcpp_1_1_i_pv4_dns_resource_data.html">IPv4DnsResourceData</a>. Please see <a class="el" href="classpcpp_1_1_dns_resource.html#ae2264452dae2d6df5e9d4c5f030eefad">DnsResource::setData()</a> for more info on this </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>A pointer to the newly created DNS answer or nullptr if answer could not be created (an appropriate error log message will be printed in this case) </dd></dl>

</div>
</div>
<a id="a54f0f2f9e7e087b51e8c0737fdbd6e4e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a54f0f2f9e7e087b51e8c0737fdbd6e4e">&#9670;&nbsp;</a></span>addAnswer() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classpcpp_1_1_dns_resource.html">DnsResource</a>* pcpp::DnsLayer::addAnswer </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classpcpp_1_1_dns_resource.html">DnsResource</a> *const&#160;</td>
          <td class="paramname"><em>copyAnswer</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Add a new DNS answer similar to an already existing DNS answer. All answer fields will be copied from the existing answer </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">copyAnswer</td><td>The record to create the new record from. copyAnswer won't be changed in any way </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>A pointer to the newly created DNS answer or nullptr if query could not be created (an appropriate error log message will be printed in this case) </dd></dl>

</div>
</div>
<a id="ab82d02a7bd0add2923b77739d807f00f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ab82d02a7bd0add2923b77739d807f00f">&#9670;&nbsp;</a></span>addAuthority() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classpcpp_1_1_dns_resource.html">DnsResource</a>* pcpp::DnsLayer::addAuthority </td>
          <td>(</td>
          <td class="paramtype">const std::string &amp;&#160;</td>
          <td class="paramname"><em>name</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="namespacepcpp.html#ad888578fe7df9849bbfbb10cdf245886">DnsType</a>&#160;</td>
          <td class="paramname"><em>dnsType</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="namespacepcpp.html#a9a53cd13fb37fed91d2acda175bee7b9">DnsClass</a>&#160;</td>
          <td class="paramname"><em>dnsClass</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint32_t&#160;</td>
          <td class="paramname"><em>ttl</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classpcpp_1_1_i_dns_resource_data.html">IDnsResourceData</a> *&#160;</td>
          <td class="paramname"><em>data</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Add a new DNS authority to the layer </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">name</td><td>The value that shall be set in the name field of the authority </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">dnsType</td><td>The value that shall be set in the DNS type field of the authority </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">dnsClass</td><td>The value that shall be set in the DNS class field of the authority </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">ttl</td><td>The value that shall be set in the 'time-to-leave' field of the authority </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">data</td><td>The authority data to be set. The type of the data should match the type of the DNS record (for example: DNS record of type A should have data of type <a class="el" href="classpcpp_1_1_i_pv4_dns_resource_data.html">IPv4DnsResourceData</a>. Please see <a class="el" href="classpcpp_1_1_dns_resource.html#ae2264452dae2d6df5e9d4c5f030eefad">DnsResource::setData()</a> for more info on this </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>A pointer to the newly created DNS authority or nullptr if authority could not be created (an appropriate error log message will be printed in this case) </dd></dl>

</div>
</div>
<a id="a368f61a098f65ee8f07f9e6dd6de08b4"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a368f61a098f65ee8f07f9e6dd6de08b4">&#9670;&nbsp;</a></span>addAuthority() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classpcpp_1_1_dns_resource.html">DnsResource</a>* pcpp::DnsLayer::addAuthority </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classpcpp_1_1_dns_resource.html">DnsResource</a> *const&#160;</td>
          <td class="paramname"><em>copyAuthority</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Add a new DNS authority similar to an already existing DNS authority. All authority fields will be copied from the existing authority </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">copyAuthority</td><td>The record to create the new record from. copyAuthority won't be changed in any way </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>A pointer to the newly created DNS authority or nullptr if query could not be created (an appropriate error log message will be printed in this case) </dd></dl>

</div>
</div>
<a id="a80db9f0dfb1b6c4641a0357b54e47138"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a80db9f0dfb1b6c4641a0357b54e47138">&#9670;&nbsp;</a></span>addQuery() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classpcpp_1_1_dns_query.html">DnsQuery</a>* pcpp::DnsLayer::addQuery </td>
          <td>(</td>
          <td class="paramtype">const std::string &amp;&#160;</td>
          <td class="paramname"><em>name</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="namespacepcpp.html#ad888578fe7df9849bbfbb10cdf245886">DnsType</a>&#160;</td>
          <td class="paramname"><em>dnsType</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="namespacepcpp.html#a9a53cd13fb37fed91d2acda175bee7b9">DnsClass</a>&#160;</td>
          <td class="paramname"><em>dnsClass</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Add a new DNS query to the layer </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">name</td><td>The value that shall be set in the name field of the query </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">dnsType</td><td>The value that shall be set in the DNS type field of the query </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">dnsClass</td><td>The value that shall be set in the DNS class field of the query </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>A pointer to the newly created DNS query or nullptr if query could not be created (an appropriate error log message will be printed in this case) </dd></dl>

</div>
</div>
<a id="a3d36a88b61c4cf83ef5b20748d589ab8"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a3d36a88b61c4cf83ef5b20748d589ab8">&#9670;&nbsp;</a></span>addQuery() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classpcpp_1_1_dns_query.html">DnsQuery</a>* pcpp::DnsLayer::addQuery </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classpcpp_1_1_dns_query.html">DnsQuery</a> *const&#160;</td>
          <td class="paramname"><em>copyQuery</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Add a new DNS query similar to an already existing DNS query. All query fields will be copied from the existing query </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">copyQuery</td><td>The record to create the new record from. copyQuery won't be changed in any way </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>A pointer to the newly created DNS query or nullptr if query could not be created (an appropriate error log message will be printed in this case) </dd></dl>

</div>
</div>
<a id="a5f5c565893d83e77bfd9c8d1bdbc6138"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a5f5c565893d83e77bfd9c8d1bdbc6138">&#9670;&nbsp;</a></span>getAdditionalRecord()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classpcpp_1_1_dns_resource.html">DnsResource</a>* pcpp::DnsLayer::getAdditionalRecord </td>
          <td>(</td>
          <td class="paramtype">const std::string &amp;&#160;</td>
          <td class="paramname"><em>name</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>exactMatch</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Searches for a DNS additional record by its name field. Notice this method returns only an additional record which its name equals to the requested name. If several additional records match the requested name, the first one will be returned. If no additional records match the requested name, nullptr will be returned </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">name</td><td>The name of the additional record to search </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">exactMatch</td><td>Indicate whether to match the whole name or just a part of it </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The first matching DNS additional record or nullptr if no additional records were found </dd></dl>

</div>
</div>
<a id="af097c5a204e4f1c5d44615ac55e220b3"></a>
<h2 class="memtitle"><span class="permalink"><a href="#af097c5a204e4f1c5d44615ac55e220b3">&#9670;&nbsp;</a></span>getAdditionalRecordCount()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">size_t pcpp::DnsLayer::getAdditionalRecordCount </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">
<dl class="section return"><dt>Returns</dt><dd>The number of DNS additional records in the packet </dd></dl>

</div>
</div>
<a id="afaef9bb50d5fc4c2118f2b8f4b9f0ea1"></a>
<h2 class="memtitle"><span class="permalink"><a href="#afaef9bb50d5fc4c2118f2b8f4b9f0ea1">&#9670;&nbsp;</a></span>getAnswer()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classpcpp_1_1_dns_resource.html">DnsResource</a>* pcpp::DnsLayer::getAnswer </td>
          <td>(</td>
          <td class="paramtype">const std::string &amp;&#160;</td>
          <td class="paramname"><em>name</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>exactMatch</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Searches for a DNS answer by its name field. Notice this method returns only an answer which its name equals to the requested name. If several answers match the requested name, the first one will be returned. If no answers match the requested name, nullptr will be returned </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">name</td><td>The name of the answer to search </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">exactMatch</td><td>Indicate whether to match the whole name or just a part of it </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The first matching DNS answer or nullptr if no answers were found </dd></dl>

</div>
</div>
<a id="ab2db39d9dfa0044636b2b1a90282a90a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ab2db39d9dfa0044636b2b1a90282a90a">&#9670;&nbsp;</a></span>getAnswerCount()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">size_t pcpp::DnsLayer::getAnswerCount </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">
<dl class="section return"><dt>Returns</dt><dd>The number of DNS answers in the packet </dd></dl>

</div>
</div>
<a id="a48c69904b29447a47b4042424e7fb932"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a48c69904b29447a47b4042424e7fb932">&#9670;&nbsp;</a></span>getAuthority()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classpcpp_1_1_dns_resource.html">DnsResource</a>* pcpp::DnsLayer::getAuthority </td>
          <td>(</td>
          <td class="paramtype">const std::string &amp;&#160;</td>
          <td class="paramname"><em>name</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>exactMatch</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Searches for a DNS authority by its name field. Notice this method returns only an authority which its name equals to the requested name. If several authorities match the requested name, the first one will be returned. If no authorities match the requested name, nullptr will be returned </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">name</td><td>The name of the authority to search </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">exactMatch</td><td>Indicate whether to match the whole name or just a part of it </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The first matching DNS authority or nullptr if no authorities were found </dd></dl>

</div>
</div>
<a id="aa67e72b9b1a28340b2c0f3fc7216524a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aa67e72b9b1a28340b2c0f3fc7216524a">&#9670;&nbsp;</a></span>getAuthorityCount()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">size_t pcpp::DnsLayer::getAuthorityCount </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">
<dl class="section return"><dt>Returns</dt><dd>The number of DNS authorities in the packet </dd></dl>

</div>
</div>
<a id="ab41ca313a68af72ebdd234067c035efe"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ab41ca313a68af72ebdd234067c035efe">&#9670;&nbsp;</a></span>getDnsHeader()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structpcpp_1_1dnshdr.html">dnshdr</a>* pcpp::DnsLayer::getDnsHeader </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Get a pointer to the DNS header (as opposed to the DNS data which is the queries, answers, etc. Data can be retrieved through the other methods of this layer. Notice the return value points directly to the data, so every change will change the actual packet data </p><dl class="section return"><dt>Returns</dt><dd>A pointer to the <a class="el" href="structpcpp_1_1dnshdr.html">dnshdr</a> </dd></dl>

</div>
</div>
<a id="a89344ae5f11f82fd8ec39286c2c6155c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a89344ae5f11f82fd8ec39286c2c6155c">&#9670;&nbsp;</a></span>getFirstAdditionalRecord()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classpcpp_1_1_dns_resource.html">DnsResource</a>* pcpp::DnsLayer::getFirstAdditionalRecord </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">
<dl class="section return"><dt>Returns</dt><dd>The first DNS additional record in the packet or nullptr if packet doesn't contain any additional records </dd></dl>

</div>
</div>
<a id="a03dd71c23b128df508102f22f37c3e4b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a03dd71c23b128df508102f22f37c3e4b">&#9670;&nbsp;</a></span>getFirstAnswer()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classpcpp_1_1_dns_resource.html">DnsResource</a>* pcpp::DnsLayer::getFirstAnswer </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">
<dl class="section return"><dt>Returns</dt><dd>The first DNS answer in the packet or nullptr if packet doesn't contain any answers </dd></dl>

</div>
</div>
<a id="a9d3eb712860aa5858952e34fd97a6267"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a9d3eb712860aa5858952e34fd97a6267">&#9670;&nbsp;</a></span>getFirstAuthority()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classpcpp_1_1_dns_resource.html">DnsResource</a>* pcpp::DnsLayer::getFirstAuthority </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">
<dl class="section return"><dt>Returns</dt><dd>The first DNS authority in the packet or nullptr if packet doesn't contain any authorities </dd></dl>

</div>
</div>
<a id="ace109477462370e2142dc1ca519154ee"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ace109477462370e2142dc1ca519154ee">&#9670;&nbsp;</a></span>getFirstQuery()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classpcpp_1_1_dns_query.html">DnsQuery</a>* pcpp::DnsLayer::getFirstQuery </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">
<dl class="section return"><dt>Returns</dt><dd>The first DNS query in the packet or nullptr if packet doesn't contain any queries </dd></dl>

</div>
</div>
<a id="a133cb88fd6984bdc4a48a60c143f2ff7"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a133cb88fd6984bdc4a48a60c143f2ff7">&#9670;&nbsp;</a></span>getHeaderLen()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">size_t pcpp::DnsLayer::getHeaderLen </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">override</span><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<dl class="section return"><dt>Returns</dt><dd>The size of the DNS data in the packet including he DNS header and size of all queries, answers, authorities and additional records </dd></dl>

<p>Implements <a class="el" href="classpcpp_1_1_layer.html#acabe7022caf7cf5fabcad4b5a0eec832">pcpp::Layer</a>.</p>

</div>
</div>
<a id="ac9f8e189bbce677dfbf0508c45bb3310"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ac9f8e189bbce677dfbf0508c45bb3310">&#9670;&nbsp;</a></span>getNextAdditionalRecord()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classpcpp_1_1_dns_resource.html">DnsResource</a>* pcpp::DnsLayer::getNextAdditionalRecord </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classpcpp_1_1_dns_resource.html">DnsResource</a> *&#160;</td>
          <td class="paramname"><em>additionalRecord</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Get the DNS additional record following a certain additional record </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">additionalRecord</td><td>A pointer to a DNS additional record that exist in the packet </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The DNS additional record following 'additionalRecord'. If 'additionalRecord' is nullptr or 'additionalRecord' is the last additional record in the packet nullptr will be returned </dd></dl>

</div>
</div>
<a id="a7102c8ac9508e1f6117424ba88c33c3b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a7102c8ac9508e1f6117424ba88c33c3b">&#9670;&nbsp;</a></span>getNextAnswer()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classpcpp_1_1_dns_resource.html">DnsResource</a>* pcpp::DnsLayer::getNextAnswer </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classpcpp_1_1_dns_resource.html">DnsResource</a> *&#160;</td>
          <td class="paramname"><em>answer</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Get the DNS answer following a certain answer </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">answer</td><td>A pointer to a DNS answer that exist in the packet </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The DNS answer following 'answer'. If 'answer' is nullptr or 'answer' is the last answer in the packet nullptr will be returned </dd></dl>

</div>
</div>
<a id="a687ae5806f248d36ce3ca9b7e7191ef4"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a687ae5806f248d36ce3ca9b7e7191ef4">&#9670;&nbsp;</a></span>getNextAuthority()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classpcpp_1_1_dns_resource.html">DnsResource</a>* pcpp::DnsLayer::getNextAuthority </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classpcpp_1_1_dns_resource.html">DnsResource</a> *&#160;</td>
          <td class="paramname"><em>authority</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Get the DNS authority following a certain authority </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">authority</td><td>A pointer to a DNS authority that exist in the packet </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The DNS authority following 'authority'. If 'authority' is nullptr or 'authority' is the last authority in the packet nullptr will be returned </dd></dl>

</div>
</div>
<a id="a8919c2d63dca7d0653e18d0cd1081dd1"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a8919c2d63dca7d0653e18d0cd1081dd1">&#9670;&nbsp;</a></span>getNextQuery()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classpcpp_1_1_dns_query.html">DnsQuery</a>* pcpp::DnsLayer::getNextQuery </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classpcpp_1_1_dns_query.html">DnsQuery</a> *&#160;</td>
          <td class="paramname"><em>query</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Get the DNS query following a certain query </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">query</td><td>A pointer to a DNS query that exist in the packet </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The DNS query following 'query'. If 'query' is nullptr or 'query' is the last query in the packet nullptr will be returned </dd></dl>

</div>
</div>
<a id="aee533934d4b8e65ffe7aca9d81910b1f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aee533934d4b8e65ffe7aca9d81910b1f">&#9670;&nbsp;</a></span>getOsiModelLayer()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="namespacepcpp.html#a69e2ee6a9dc68797612cf8dc38461025">OsiModelLayer</a> pcpp::DnsLayer::getOsiModelLayer </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">override</span><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<dl class="section return"><dt>Returns</dt><dd>The OSI Model layer this protocol belongs to </dd></dl>

<p>Implements <a class="el" href="classpcpp_1_1_layer.html#af9e51f48a58a3b0dcd1a7341111c66e0">pcpp::Layer</a>.</p>

</div>
</div>
<a id="a1e350c5f5c2686900c91a8753f70745b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a1e350c5f5c2686900c91a8753f70745b">&#9670;&nbsp;</a></span>getQuery()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classpcpp_1_1_dns_query.html">DnsQuery</a>* pcpp::DnsLayer::getQuery </td>
          <td>(</td>
          <td class="paramtype">const std::string &amp;&#160;</td>
          <td class="paramname"><em>name</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>exactMatch</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Searches for a DNS query by its name field. Notice this method returns only a query which its name equals to the requested name. If several queries match the requested name, the first one will be returned. If no queries match the requested name, nullptr will be returned </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">name</td><td>The name of the query to search </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">exactMatch</td><td>Indicate whether to match the whole name or just a part of it </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The first matching DNS query or nullptr if no queries were found </dd></dl>

</div>
</div>
<a id="a647e6683f885b3b75aaacb2665af741d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a647e6683f885b3b75aaacb2665af741d">&#9670;&nbsp;</a></span>getQueryCount()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">size_t pcpp::DnsLayer::getQueryCount </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">
<dl class="section return"><dt>Returns</dt><dd>The number of DNS queries in the packet </dd></dl>

</div>
</div>
<a id="a3c3fa3e42b1d3f2b92128f06aa025a51"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a3c3fa3e42b1d3f2b92128f06aa025a51">&#9670;&nbsp;</a></span>isDataValid()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool pcpp::DnsLayer::isDataValid </td>
          <td>(</td>
          <td class="paramtype">const uint8_t *&#160;</td>
          <td class="paramname"><em>data</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>dataLen</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>dnsOverTcp</em> = <code>false</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>A static method that validates the input data </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">data</td><td>The pointer to the beginning of a byte stream of a DNS packet </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">dataLen</td><td>The length of the byte stream </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">dnsOverTcp</td><td>Should be set to "true" if this is DNS is over TCP, otherwise set to "false" (which is also the default value) </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>True if the data is valid and can represent a DNS packet </dd></dl>

</div>
</div>
<a id="adc75f267b44dc4b8d42524aecc684fdd"></a>
<h2 class="memtitle"><span class="permalink"><a href="#adc75f267b44dc4b8d42524aecc684fdd">&#9670;&nbsp;</a></span>isDnsPort()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool pcpp::DnsLayer::isDnsPort </td>
          <td>(</td>
          <td class="paramtype">uint16_t&#160;</td>
          <td class="paramname"><em>port</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>A static method that checks whether the port is considered as DNS </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">port</td><td>The port number to be checked </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>True if the port is associated with the DNS protocol </dd></dl>

</div>
</div>
<a id="ae265ed7f1e5ce8b8480db3c9b0ca6c34"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ae265ed7f1e5ce8b8480db3c9b0ca6c34">&#9670;&nbsp;</a></span>operator=()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classpcpp_1_1_dns_layer.html">DnsLayer</a>&amp; pcpp::DnsLayer::operator= </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classpcpp_1_1_dns_layer.html">DnsLayer</a> &amp;&#160;</td>
          <td class="paramname"><em>other</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>An assignment operator for this layer </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">other</td><td>The DNS layer to assign </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>A reference to the assignee </dd></dl>

</div>
</div>
<a id="ad8bf786e4e820138e07eb1a242d7af20"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ad8bf786e4e820138e07eb1a242d7af20">&#9670;&nbsp;</a></span>removeAdditionalRecord() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool pcpp::DnsLayer::removeAdditionalRecord </td>
          <td>(</td>
          <td class="paramtype">const std::string &amp;&#160;</td>
          <td class="paramname"><em>additionalRecordNameToRemove</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>exactMatch</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Remove an existing additional record by name. If several additional records matches the name, the first match will be removed </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">additionalRecordNameToRemove</td><td>The name of the additional record to remove </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">exactMatch</td><td>Indicate whether to match the whole name or just a part of it </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>True if additional record was found and successfully removed or false if additional record was not found or couldn't be removed </dd></dl>

</div>
</div>
<a id="a523b41db73c4105c0d9627cd2b02294d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a523b41db73c4105c0d9627cd2b02294d">&#9670;&nbsp;</a></span>removeAdditionalRecord() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool pcpp::DnsLayer::removeAdditionalRecord </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classpcpp_1_1_dns_resource.html">DnsResource</a> *&#160;</td>
          <td class="paramname"><em>additionalRecordToRemove</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Remove an existing additional record </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">additionalRecordToRemove</td><td>A pointer to the additional record to remove </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>True if additional record was found and successfully removed or false if additional record was not found or couldn't be removed </dd></dl>

</div>
</div>
<a id="adad4f490b373d2f5ecc70ceebdb2cf11"></a>
<h2 class="memtitle"><span class="permalink"><a href="#adad4f490b373d2f5ecc70ceebdb2cf11">&#9670;&nbsp;</a></span>removeAnswer() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool pcpp::DnsLayer::removeAnswer </td>
          <td>(</td>
          <td class="paramtype">const std::string &amp;&#160;</td>
          <td class="paramname"><em>answerNameToRemove</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>exactMatch</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Remove an existing answer by name. If several answers matches the name, the first match will be removed </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">answerNameToRemove</td><td>The name of the answer to remove </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">exactMatch</td><td>Indicate whether to match the whole name or just a part of it </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>True if answer was found and successfully removed or false if answer was not found or couldn't be removed </dd></dl>

</div>
</div>
<a id="ac8d534e0aac68d7b07af23f50dfb7c3d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ac8d534e0aac68d7b07af23f50dfb7c3d">&#9670;&nbsp;</a></span>removeAnswer() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool pcpp::DnsLayer::removeAnswer </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classpcpp_1_1_dns_resource.html">DnsResource</a> *&#160;</td>
          <td class="paramname"><em>answerToRemove</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Remove an existing answer </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">answerToRemove</td><td>A pointer to the answer to remove </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>True if answer was found and successfully removed or false if answer was not found or couldn't be removed </dd></dl>

</div>
</div>
<a id="a9274ccfb5fe3f407e8b05367f59072c7"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a9274ccfb5fe3f407e8b05367f59072c7">&#9670;&nbsp;</a></span>removeAuthority() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool pcpp::DnsLayer::removeAuthority </td>
          <td>(</td>
          <td class="paramtype">const std::string &amp;&#160;</td>
          <td class="paramname"><em>authorityNameToRemove</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>exactMatch</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Remove an existing authority by name. If several authorities matches the name, the first match will be removed </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">authorityNameToRemove</td><td>The name of the authority to remove </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">exactMatch</td><td>Indicate whether to match the whole name or just a part of it </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>True if authority was found and successfully removed or false if authority was not found or couldn't be removed </dd></dl>

</div>
</div>
<a id="ae957f7b50adade0c014ab8007f4009bd"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ae957f7b50adade0c014ab8007f4009bd">&#9670;&nbsp;</a></span>removeAuthority() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool pcpp::DnsLayer::removeAuthority </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classpcpp_1_1_dns_resource.html">DnsResource</a> *&#160;</td>
          <td class="paramname"><em>authorityToRemove</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Remove an existing authority </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">authorityToRemove</td><td>A pointer to the authority to remove </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>True if authority was found and successfully removed or false if authority was not found or couldn't be removed </dd></dl>

</div>
</div>
<a id="a5952988d68c6a82e38347a403f43f389"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a5952988d68c6a82e38347a403f43f389">&#9670;&nbsp;</a></span>removeQuery() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool pcpp::DnsLayer::removeQuery </td>
          <td>(</td>
          <td class="paramtype">const std::string &amp;&#160;</td>
          <td class="paramname"><em>queryNameToRemove</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>exactMatch</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Remove an existing query by name. If several queries matches the name, the first match will be removed </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">queryNameToRemove</td><td>The name of the query to remove </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">exactMatch</td><td>Indicate whether to match the whole name or just a part of it </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>True if query was found and successfully removed or false if query was not found or couldn't be removed </dd></dl>

</div>
</div>
<a id="aa62ae344b6dd0ff36ac17242ba7971e2"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aa62ae344b6dd0ff36ac17242ba7971e2">&#9670;&nbsp;</a></span>removeQuery() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool pcpp::DnsLayer::removeQuery </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classpcpp_1_1_dns_query.html">DnsQuery</a> *&#160;</td>
          <td class="paramname"><em>queryToRemove</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Remove an existing query </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">queryToRemove</td><td>A pointer to the query to remove </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>True if query was found and successfully removed or false if query was not found or couldn't be removed </dd></dl>

</div>
</div>
<a id="a6baa949f6174f120cb2c911ac77fcb92"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a6baa949f6174f120cb2c911ac77fcb92">&#9670;&nbsp;</a></span>toString()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">std::string pcpp::DnsLayer::toString </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">override</span><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<dl class="section return"><dt>Returns</dt><dd>A string representation of the layer most important data (should look like the layer description in Wireshark) </dd></dl>

<p>Implements <a class="el" href="classpcpp_1_1_layer.html#a1d07ea14d02b4a5cb383f89b3f40ed63">pcpp::Layer</a>.</p>

</div>
</div>
</div><!-- contents -->
</div><!-- doc-content -->
<!-- start footer part -->
<div id="nav-path" class="navpath"><!-- id is needed for treeview function! -->
  <ul>
    <li class="navelem"><a class="el" href="namespacepcpp.html">pcpp</a></li><li class="navelem"><a class="el" href="classpcpp_1_1_dns_layer.html">DnsLayer</a></li>
    <li class="footer">Generated on Sat Apr 19 2025 09:05:18 for PcapPlusPlus by <a href="https://www.doxygen.org/index.html"><img class="footer" src="doxygen.svg" width="104" height="31" alt="doxygen"/></a> 1.9.1 </li>
  </ul>
</div>
</body>
</html>
