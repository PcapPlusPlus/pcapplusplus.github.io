<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "https://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=9"/>
<meta name="generator" content="Doxygen 1.9.1"/>
<meta name="viewport" content="width=device-width, initial-scale=1"/>
<title>PcapPlusPlus: pcpp::RawSocketDevice Class Reference</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<link href="navtree.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="resize.js"></script>
<script type="text/javascript" src="navtreedata.js"></script>
<script type="text/javascript" src="navtree.js"></script>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/searchdata.js"></script>
<script type="text/javascript" src="search/search.js"></script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
<link href="doxygen-mobile.css" rel="stylesheet" type="text/css"/>
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr style="height: 56px;">
  <td id="projectlogo"><img alt="Logo" src="logo_icon_large.ico"/></td>
  <td id="projectalign" style="padding-left: 0.5em;">
   <div id="projectname">PcapPlusPlus
   &#160;<span id="projectnumber">Next</span>
   </div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.9.1 -->
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:cf05388f2679ee054f2beb29a391d25f4e673ac3&amp;dn=gpl-2.0.txt GPL-v2 */
var searchBox = new SearchBox("searchBox", "search",false,'Search','.html');
/* @license-end */
</script>
<script type="text/javascript" src="menudata.js"></script>
<script type="text/javascript" src="menu.js"></script>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:cf05388f2679ee054f2beb29a391d25f4e673ac3&amp;dn=gpl-2.0.txt GPL-v2 */
$(function() {
  initMenu('',true,false,'search.php','Search');
  $(document).ready(function() { init_search(); });
});
/* @license-end */</script>
<div id="main-nav"></div>
</div><!-- top -->
<div id="side-nav" class="ui-resizable side-nav-resizable">
  <div id="nav-tree">
    <div id="nav-tree-contents">
      <div id="nav-sync" class="sync"></div>
    </div>
  </div>
  <div id="splitbar" style="-moz-user-select:none;" 
       class="ui-resizable-handle">
  </div>
</div>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:cf05388f2679ee054f2beb29a391d25f4e673ac3&amp;dn=gpl-2.0.txt GPL-v2 */
$(document).ready(function(){initNavTree('classpcpp_1_1_raw_socket_device.html',''); initResizable(); });
/* @license-end */
</script>
<div id="doc-content">
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
</div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<iframe src="javascript:void(0)" frameborder="0" 
        name="MSearchResults" id="MSearchResults">
</iframe>
</div>

<div class="header">
  <div class="summary">
<a href="#pub-types">Public Types</a> &#124;
<a href="#pub-methods">Public Member Functions</a> &#124;
<a href="classpcpp_1_1_raw_socket_device-members.html">List of all members</a>  </div>
  <div class="headertitle">
<div class="title">pcpp::RawSocketDevice Class Reference</div>  </div>
</div><!--header-->
<div class="contents">

<p><code>#include &lt;<a class="el" href="_raw_socket_device_8h_source.html">RawSocketDevice.h</a>&gt;</code></p>
<div class="dynheader">
Inheritance diagram for pcpp::RawSocketDevice:</div>
<div class="dyncontent">
 <div class="center">
  <img src="classpcpp_1_1_raw_socket_device.png" usemap="#pcpp::RawSocketDevice_map" alt=""/>
  <map id="pcpp::RawSocketDevice_map" name="pcpp::RawSocketDevice_map">
<area href="classpcpp_1_1_i_device.html" alt="pcpp::IDevice" shape="rect" coords="0,0,148,24"/>
  </map>
</div></div>
<table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="pub-types"></a>
Public Types</h2></td></tr>
<tr class="memitem:a06ec60dc8d38dfab0333fb793ad0da76"><td class="memItemLeft" align="right" valign="top">enum &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classpcpp_1_1_raw_socket_device.html#a06ec60dc8d38dfab0333fb793ad0da76">RecvPacketResult</a> { <a class="el" href="classpcpp_1_1_raw_socket_device.html#a06ec60dc8d38dfab0333fb793ad0da76ad36c34a2ebc972da8d8ad02b1e1d8c70">RecvSuccess</a> = 0
, <a class="el" href="classpcpp_1_1_raw_socket_device.html#a06ec60dc8d38dfab0333fb793ad0da76a0ad5957368155861234acd2c5251b95c">RecvTimeout</a> = 1
, <a class="el" href="classpcpp_1_1_raw_socket_device.html#a06ec60dc8d38dfab0333fb793ad0da76abaedaa450ddecac58433cf954fdfd8b8">RecvWouldBlock</a> = 2
, <a class="el" href="classpcpp_1_1_raw_socket_device.html#a06ec60dc8d38dfab0333fb793ad0da76adce5f5b2a3d83a5816da7520ee4228ea">RecvError</a> = 3
 }</td></tr>
<tr class="memdesc:a06ec60dc8d38dfab0333fb793ad0da76"><td class="mdescLeft">&#160;</td><td class="mdescRight">An enum for reporting packet receive results.  <a href="classpcpp_1_1_raw_socket_device.html#a06ec60dc8d38dfab0333fb793ad0da76">More...</a><br /></td></tr>
<tr class="separator:a06ec60dc8d38dfab0333fb793ad0da76"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="pub-methods"></a>
Public Member Functions</h2></td></tr>
<tr class="memitem:ad9af5cae14f4e97821e3ada6700cf035"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classpcpp_1_1_raw_socket_device.html#ad9af5cae14f4e97821e3ada6700cf035">RawSocketDevice</a> (const <a class="el" href="classpcpp_1_1_i_p_address.html">IPAddress</a> &amp;interfaceIP)</td></tr>
<tr class="separator:ad9af5cae14f4e97821e3ada6700cf035"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a16669eaf3e120d99ff07a07223aca9b6"><td class="memItemLeft" align="right" valign="top"><a id="a16669eaf3e120d99ff07a07223aca9b6"></a>
&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classpcpp_1_1_raw_socket_device.html#a16669eaf3e120d99ff07a07223aca9b6">~RawSocketDevice</a> ()</td></tr>
<tr class="memdesc:a16669eaf3e120d99ff07a07223aca9b6"><td class="mdescLeft">&#160;</td><td class="mdescRight">A d'tor for this class. It closes the raw socket if not previously closed by calling <a class="el" href="classpcpp_1_1_raw_socket_device.html#afbfa55120d23c91c9bd2e4ef11161ea3" title="Close the raw socket.">close()</a> <br /></td></tr>
<tr class="separator:a16669eaf3e120d99ff07a07223aca9b6"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad3819d6840a9d1bbdb9bd4d38c464430"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classpcpp_1_1_raw_socket_device.html#a06ec60dc8d38dfab0333fb793ad0da76">RecvPacketResult</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classpcpp_1_1_raw_socket_device.html#ad3819d6840a9d1bbdb9bd4d38c464430">receivePacket</a> (<a class="el" href="classpcpp_1_1_raw_packet.html">RawPacket</a> &amp;rawPacket, bool blocking=true, double timeout=-1)</td></tr>
<tr class="separator:ad3819d6840a9d1bbdb9bd4d38c464430"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a130fcdee203ddabc332e612e36da5b12"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classpcpp_1_1_raw_socket_device.html#a130fcdee203ddabc332e612e36da5b12">receivePackets</a> (<a class="el" href="namespacepcpp.html#a4c0775fb93a0867d2afa7992d55957f0">RawPacketVector</a> &amp;packetVec, double timeout, int &amp;failedRecv)</td></tr>
<tr class="separator:a130fcdee203ddabc332e612e36da5b12"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3a7822e719e2f5895b3bee1523327e08"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classpcpp_1_1_raw_socket_device.html#a3a7822e719e2f5895b3bee1523327e08">sendPacket</a> (const <a class="el" href="classpcpp_1_1_raw_packet.html">RawPacket</a> *rawPacket)</td></tr>
<tr class="separator:a3a7822e719e2f5895b3bee1523327e08"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a348a0cfddc2d9b04857fd8bf8402b6ba"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classpcpp_1_1_raw_socket_device.html#a348a0cfddc2d9b04857fd8bf8402b6ba">sendPackets</a> (const <a class="el" href="namespacepcpp.html#a4c0775fb93a0867d2afa7992d55957f0">RawPacketVector</a> &amp;packetVec)</td></tr>
<tr class="separator:a348a0cfddc2d9b04857fd8bf8402b6ba"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aff1eb10c3d601d602322849c31e98e10"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classpcpp_1_1_raw_socket_device.html#aff1eb10c3d601d602322849c31e98e10">open</a> () override</td></tr>
<tr class="separator:aff1eb10c3d601d602322849c31e98e10"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:afbfa55120d23c91c9bd2e4ef11161ea3"><td class="memItemLeft" align="right" valign="top"><a id="afbfa55120d23c91c9bd2e4ef11161ea3"></a>
void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classpcpp_1_1_raw_socket_device.html#afbfa55120d23c91c9bd2e4ef11161ea3">close</a> () override</td></tr>
<tr class="memdesc:afbfa55120d23c91c9bd2e4ef11161ea3"><td class="mdescLeft">&#160;</td><td class="mdescRight">Close the raw socket. <br /></td></tr>
<tr class="separator:afbfa55120d23c91c9bd2e4ef11161ea3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="inherit_header pub_methods_classpcpp_1_1_i_device"><td colspan="2" onclick="javascript:toggleInherit('pub_methods_classpcpp_1_1_i_device')"><img src="closed.png" alt="-"/>&#160;Public Member Functions inherited from <a class="el" href="classpcpp_1_1_i_device.html">pcpp::IDevice</a></td></tr>
<tr class="memitem:a5b75e7491597f271b8f29847bec2ee99 inherit pub_methods_classpcpp_1_1_i_device"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classpcpp_1_1_i_device.html#a5b75e7491597f271b8f29847bec2ee99">isOpened</a> ()</td></tr>
<tr class="separator:a5b75e7491597f271b8f29847bec2ee99 inherit pub_methods_classpcpp_1_1_i_device"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table>
<a name="details" id="details"></a><h2 class="groupheader">Detailed Description</h2>
<div class="textblock"><p>A class that wraps the raw socket functionality. A raw socket is a network socket that allows direct sending and receiving of IP packets without any protocol-specific transport layer formatting (taken from Wikipedia: <a href="https://en.wikipedia.org/wiki/Network_socket#Raw_socket">https://en.wikipedia.org/wiki/Network_socket#Raw_socket</a>). This wrapper class enables creation of a raw socket, binding it to a network interface, and then receiving and sending packets on it. Current implementation supports only Windows and Linux because other platforms provide poor support for raw sockets making them practically unusable. There are also major differences between Linux and Windows in raw socket implementation, let's mention some of the:</p><ul>
<li>On Windows administrative privileges are required for raw sockets creation, meaning the process running the code has to have these privileges. In Linux 'sudo' is required</li>
<li>On Windows raw sockets are implemented in L3, meaning the L2 (Ethernet) layer is omitted by the socket and only L3 and up are visible to the user. On Linux raw sockets are implemented on L2, meaning all layers (including the Ethernet data) are visible to the user.</li>
<li>On Windows sending packets is not supported, a raw socket can only receive packets. On Linux both send and receive are supported</li>
<li>Linux doesn't require binding to a specific network interface for receiving packets, but it does require binding for sending packets. Windows requires binding for receiving packets. For the sake of keeping a unified and simple cross-platform interface this class requires binding for both Linux and Windows, on both send and receive</li>
</ul>
<p>More details about opening the raw socket, receiving and sending packets are explained in the corresponding class methods. Raw sockets are supported for both IPv4 and IPv6, so you can create and bind raw sockets to each of the two. Also, there is no limit on the number of sockets opened for a specific IP address or network interface, so you can create multiple instances of this class and bind all of them to the same interface and IP address. </p>
</div><h2 class="groupheader">Member Enumeration Documentation</h2>
<a id="a06ec60dc8d38dfab0333fb793ad0da76"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a06ec60dc8d38dfab0333fb793ad0da76">&#9670;&nbsp;</a></span>RecvPacketResult</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">enum <a class="el" href="classpcpp_1_1_raw_socket_device.html#a06ec60dc8d38dfab0333fb793ad0da76">pcpp::RawSocketDevice::RecvPacketResult</a></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>An enum for reporting packet receive results. </p>
<table class="fieldtable">
<tr><th colspan="2">Enumerator</th></tr><tr><td class="fieldname"><a id="a06ec60dc8d38dfab0333fb793ad0da76ad36c34a2ebc972da8d8ad02b1e1d8c70"></a>RecvSuccess&#160;</td><td class="fielddoc"><p>Receive success. </p>
</td></tr>
<tr><td class="fieldname"><a id="a06ec60dc8d38dfab0333fb793ad0da76a0ad5957368155861234acd2c5251b95c"></a>RecvTimeout&#160;</td><td class="fielddoc"><p>Receive timeout - timeout expired without any packets being captured. </p>
</td></tr>
<tr><td class="fieldname"><a id="a06ec60dc8d38dfab0333fb793ad0da76abaedaa450ddecac58433cf954fdfd8b8"></a>RecvWouldBlock&#160;</td><td class="fielddoc"><p>Receive would block - in non-blocking mode if there are no packets in the rx queue the receive method will return immediately with this return value </p>
</td></tr>
<tr><td class="fieldname"><a id="a06ec60dc8d38dfab0333fb793ad0da76adce5f5b2a3d83a5816da7520ee4228ea"></a>RecvError&#160;</td><td class="fielddoc"><p>Receive error, usually will be followed by an error log. </p>
</td></tr>
</table>

</div>
</div>
<h2 class="groupheader">Constructor &amp; Destructor Documentation</h2>
<a id="ad9af5cae14f4e97821e3ada6700cf035"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ad9af5cae14f4e97821e3ada6700cf035">&#9670;&nbsp;</a></span>RawSocketDevice()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">pcpp::RawSocketDevice::RawSocketDevice </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classpcpp_1_1_i_p_address.html">IPAddress</a> &amp;&#160;</td>
          <td class="paramname"><em>interfaceIP</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">explicit</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>A c'tor for this class. This c'tor doesn't create the raw socket, but rather initializes internal structures. The actual raw socket creation is done in the <a class="el" href="classpcpp_1_1_raw_socket_device.html#aff1eb10c3d601d602322849c31e98e10">open()</a> method. Each raw socket is bound to a network interface which means packets will be received and sent from only from this network interface only </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">interfaceIP</td><td>The network interface IP to bind the raw socket to. It can be either an IPv4 or IPv6 address (both are supported in raw sockets) </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<h2 class="groupheader">Member Function Documentation</h2>
<a id="aff1eb10c3d601d602322849c31e98e10"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aff1eb10c3d601d602322849c31e98e10">&#9670;&nbsp;</a></span>open()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool pcpp::RawSocketDevice::open </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">override</span><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Open the device by creating a raw socket and binding it to the network interface specified in the c'tor </p><dl class="section return"><dt>Returns</dt><dd>True if device was opened successfully, false otherwise with a corresponding error log message </dd></dl>

<p>Implements <a class="el" href="classpcpp_1_1_i_device.html#ad7bed3f1134e8b4329295b4af6733b9f">pcpp::IDevice</a>.</p>

</div>
</div>
<a id="ad3819d6840a9d1bbdb9bd4d38c464430"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ad3819d6840a9d1bbdb9bd4d38c464430">&#9670;&nbsp;</a></span>receivePacket()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classpcpp_1_1_raw_socket_device.html#a06ec60dc8d38dfab0333fb793ad0da76">RecvPacketResult</a> pcpp::RawSocketDevice::receivePacket </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classpcpp_1_1_raw_packet.html">RawPacket</a> &amp;&#160;</td>
          <td class="paramname"><em>rawPacket</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>blocking</em> = <code>true</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double&#160;</td>
          <td class="paramname"><em>timeout</em> = <code>-1</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Receive a packet on the raw socket. This method has several modes of operation:</p><ul>
<li>Blocking/non-blocking - in blocking mode the method will not return until a packet is received on the socket or until the timeout expires. In non-blocking mode it will return immediately and in case no packets are on the receive queue <a class="el" href="classpcpp_1_1_raw_socket_device.html#a06ec60dc8d38dfab0333fb793ad0da76abaedaa450ddecac58433cf954fdfd8b8">RawSocketDevice::RecvWouldBlock</a> will be returned. Unless specified otherwise, the default value is blocking mode</li>
<li>Receive timeout - in blocking mode, the user can set a timeout to wait until a packet is received. If the timeout expires and no packets were received, the method will return <a class="el" href="classpcpp_1_1_raw_socket_device.html#a06ec60dc8d38dfab0333fb793ad0da76a0ad5957368155861234acd2c5251b95c" title="Receive timeout - timeout expired without any packets being captured.">RawSocketDevice::RecvTimeout</a>. The default value is a negative value which means no timeout</li>
</ul>
<p>There is a slight difference on this method's behavior between Windows and Linux around how packets are received. On Linux the received packet contains all layers starting from the L2 (Ethernet). However on Windows raw socket are integrated in L3 level so the received packet contains only L3 (IP) layer and up. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[out]</td><td class="paramname">rawPacket</td><td>An empty packet instance where the received packet data will be written to </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">blocking</td><td>Indicates whether to run in blocking or non-blocking mode. Default value is blocking </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">timeout</td><td>When in blocking mode, specifies the timeout [in seconds] to wait for a packet. If timeout expired and no packets were captured the method will return <a class="el" href="classpcpp_1_1_raw_socket_device.html#a06ec60dc8d38dfab0333fb793ad0da76a0ad5957368155861234acd2c5251b95c" title="Receive timeout - timeout expired without any packets being captured.">RawSocketDevice::RecvTimeout</a>. Zero or negative values mean no timeout. The default value is no timeout. The timeout precision is in milliseconds, for example a timeout of 0.123 means 123 milliseconds. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The method returns one on the following values:<ul>
<li><a class="el" href="classpcpp_1_1_raw_socket_device.html#a06ec60dc8d38dfab0333fb793ad0da76ad36c34a2ebc972da8d8ad02b1e1d8c70" title="Receive success.">RawSocketDevice::RecvSuccess</a> is returned if a packet was received successfully</li>
<li><a class="el" href="classpcpp_1_1_raw_socket_device.html#a06ec60dc8d38dfab0333fb793ad0da76a0ad5957368155861234acd2c5251b95c" title="Receive timeout - timeout expired without any packets being captured.">RawSocketDevice::RecvTimeout</a> is returned if in blocking mode and timeout expired</li>
<li><a class="el" href="classpcpp_1_1_raw_socket_device.html#a06ec60dc8d38dfab0333fb793ad0da76abaedaa450ddecac58433cf954fdfd8b8">RawSocketDevice::RecvWouldBlock</a> is returned if in non-blocking mode and no packets were captured</li>
<li><a class="el" href="classpcpp_1_1_raw_socket_device.html#a06ec60dc8d38dfab0333fb793ad0da76adce5f5b2a3d83a5816da7520ee4228ea" title="Receive error, usually will be followed by an error log.">RawSocketDevice::RecvError</a> is returned if an error occurred such as device is not opened or the recv operation returned some error. A log message will be followed specifying the error and error code </li>
</ul>
</dd></dl>

</div>
</div>
<a id="a130fcdee203ddabc332e612e36da5b12"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a130fcdee203ddabc332e612e36da5b12">&#9670;&nbsp;</a></span>receivePackets()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int pcpp::RawSocketDevice::receivePackets </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="namespacepcpp.html#a4c0775fb93a0867d2afa7992d55957f0">RawPacketVector</a> &amp;&#160;</td>
          <td class="paramname"><em>packetVec</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double&#160;</td>
          <td class="paramname"><em>timeout</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int &amp;&#160;</td>
          <td class="paramname"><em>failedRecv</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Receive packets into a packet vector for a certain amount of time. This method starts a timer and invokes the <a class="el" href="classpcpp_1_1_raw_socket_device.html#ad3819d6840a9d1bbdb9bd4d38c464430">receivePacket()</a> method in blocking mode repeatedly until the timeout expires. All packets received successfully are put into a packet vector </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[out]</td><td class="paramname">packetVec</td><td>The packet vector to add the received packet to </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">timeout</td><td>Timeout in seconds to receive packets on the raw socket. The timeout precision is in milliseconds, for example a timeout of 0.123 means 123 milliseconds. </td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">failedRecv</td><td>Number of receive attempts that failed </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The number of packets received successfully </dd></dl>

</div>
</div>
<a id="a3a7822e719e2f5895b3bee1523327e08"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a3a7822e719e2f5895b3bee1523327e08">&#9670;&nbsp;</a></span>sendPacket()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool pcpp::RawSocketDevice::sendPacket </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classpcpp_1_1_raw_packet.html">RawPacket</a> *&#160;</td>
          <td class="paramname"><em>rawPacket</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Send an Ethernet packet to the network. L2 protocols other than Ethernet are not supported in raw sockets. The entire packet is sent as is, including the original Ethernet and IP data. This method is only supported in Linux as Windows doesn't allow sending packets from raw sockets. Using it from other platforms will also return "false" with a corresponding error log message </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">rawPacket</td><td>The packet to send </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>True if packet was sent successfully or false if the socket is not open, if the packet is not Ethernet or if there was a failure sending the packet </dd></dl>

</div>
</div>
<a id="a348a0cfddc2d9b04857fd8bf8402b6ba"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a348a0cfddc2d9b04857fd8bf8402b6ba">&#9670;&nbsp;</a></span>sendPackets()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int pcpp::RawSocketDevice::sendPackets </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="namespacepcpp.html#a4c0775fb93a0867d2afa7992d55957f0">RawPacketVector</a> &amp;&#160;</td>
          <td class="paramname"><em>packetVec</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Send a set of Ethernet packets to the network. L2 protocols other than Ethernet are not supported by raw sockets. The entire packet is sent as is, including the original Ethernet and IP data. This method is only supported in Linux as Windows doesn't allow sending packets from raw sockets. Using it from other platforms will return "false" with an appropriate error log message </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">packetVec</td><td>The set of packets to send </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The number of packets sent successfully. For packets that weren't sent successfully there will be a corresponding error message printed to log </dd></dl>

</div>
</div>
</div><!-- contents -->
</div><!-- doc-content -->
<!-- start footer part -->
<div id="nav-path" class="navpath"><!-- id is needed for treeview function! -->
  <ul>
    <li class="navelem"><a class="el" href="namespacepcpp.html">pcpp</a></li><li class="navelem"><a class="el" href="classpcpp_1_1_raw_socket_device.html">RawSocketDevice</a></li>
    <li class="footer">Generated on Thu Jun 12 2025 03:23:15 for PcapPlusPlus by <a href="https://www.doxygen.org/index.html"><img class="footer" src="doxygen.svg" width="104" height="31" alt="doxygen"/></a> 1.9.1 </li>
  </ul>
</div>
</body>
</html>
