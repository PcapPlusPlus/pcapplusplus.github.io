<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "https://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=9"/>
<meta name="generator" content="Doxygen 1.8.16"/>
<meta name="viewport" content="width=device-width, initial-scale=1"/>
<title>PcapPlusPlus: pcpp::KniDevice Class Reference</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<link href="navtree.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="resize.js"></script>
<script type="text/javascript" src="navtreedata.js"></script>
<script type="text/javascript" src="navtree.js"></script>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:cf05388f2679ee054f2beb29a391d25f4e673ac3&amp;dn=gpl-2.0.txt GPL-v2 */
  $(document).ready(initResizable);
/* @license-end */</script>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/searchdata.js"></script>
<script type="text/javascript" src="search/search.js"></script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
<link href="doxygen-mobile.css" rel="stylesheet" type="text/css"/>
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr style="height: 56px;">
  <td id="projectlogo"><img alt="Logo" src="logo_icon_large.ico"/></td>
  <td id="projectalign" style="padding-left: 0.5em;">
   <div id="projectname">PcapPlusPlus
   &#160;<span id="projectnumber">19.12</span>
   </div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.8.16 -->
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:cf05388f2679ee054f2beb29a391d25f4e673ac3&amp;dn=gpl-2.0.txt GPL-v2 */
var searchBox = new SearchBox("searchBox", "search",false,'Search');
/* @license-end */
</script>
<script type="text/javascript" src="menudata.js"></script>
<script type="text/javascript" src="menu.js"></script>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:cf05388f2679ee054f2beb29a391d25f4e673ac3&amp;dn=gpl-2.0.txt GPL-v2 */
$(function() {
  initMenu('',true,false,'search.php','Search');
  $(document).ready(function() { init_search(); });
});
/* @license-end */</script>
<div id="main-nav"></div>
</div><!-- top -->
<div id="side-nav" class="ui-resizable side-nav-resizable">
  <div id="nav-tree">
    <div id="nav-tree-contents">
      <div id="nav-sync" class="sync"></div>
    </div>
  </div>
  <div id="splitbar" style="-moz-user-select:none;" 
       class="ui-resizable-handle">
  </div>
</div>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:cf05388f2679ee054f2beb29a391d25f4e673ac3&amp;dn=gpl-2.0.txt GPL-v2 */
$(document).ready(function(){initNavTree('classpcpp_1_1_kni_device.html','');});
/* @license-end */
</script>
<div id="doc-content">
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
</div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<iframe src="javascript:void(0)" frameborder="0" 
        name="MSearchResults" id="MSearchResults">
</iframe>
</div>

<div class="header">
  <div class="summary">
<a href="#nested-classes">Classes</a> &#124;
<a href="#pub-types">Public Types</a> &#124;
<a href="#pub-methods">Public Member Functions</a> &#124;
<a href="classpcpp_1_1_kni_device-members.html">List of all members</a>  </div>
  <div class="headertitle">
<div class="title">pcpp::KniDevice Class Reference</div>  </div>
</div><!--header-->
<div class="contents">

<p><code>#include &lt;<a class="el" href="_kni_device_8h_source.html">KniDevice.h</a>&gt;</code></p>
<div class="dynheader">
Inheritance diagram for pcpp::KniDevice:</div>
<div class="dyncontent">
 <div class="center">
  <img src="classpcpp_1_1_kni_device.png" usemap="#pcpp::KniDevice_map" alt=""/>
  <map id="pcpp::KniDevice_map" name="pcpp::KniDevice_map">
<area href="classpcpp_1_1_i_device.html" alt="pcpp::IDevice" shape="rect" coords="0,0,104,24"/>
  </map>
</div></div>
<table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="nested-classes"></a>
Classes</h2></td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structpcpp_1_1_kni_device_1_1_kni_device_configuration.html">KniDeviceConfiguration</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">KNI device initialization data. Used to create new KNI device. Usage of callbacks member or oldCallbacks member is defined by result of <a class="el" href="classpcpp_1_1_kni_device_list.html#afa8b65d977557e02a19e87139e1fbcc0">KniDeviceList::callbackVersion</a>.  <a href="structpcpp_1_1_kni_device_1_1_kni_device_configuration.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structpcpp_1_1_kni_device_1_1_kni_ioctl_callbacks.html">KniIoctlCallbacks</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">New callbacks for KNI device events. This structure MUST be used ONLY when <a class="el" href="classpcpp_1_1_kni_device_list.html#afa8b65d977557e02a19e87139e1fbcc0">KniDeviceList::callbackVersion</a> returns KniDeviceList::KniCallbackVersion::CALLBACKS_NEW. Or if You are sure that DPDK version used is 17.11 or higher. If some callback is not provided (NULL) the request will always succeeds if other is not specified in callback description.  <a href="structpcpp_1_1_kni_device_1_1_kni_ioctl_callbacks.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structpcpp_1_1_kni_device_1_1_kni_old_ioctl_callbacks.html">KniOldIoctlCallbacks</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Old callbacks for KNI device events. This structure MUST be used ONLY when <a class="el" href="classpcpp_1_1_kni_device_list.html#afa8b65d977557e02a19e87139e1fbcc0">KniDeviceList::callbackVersion</a> returns KniDeviceList::KniCallbackVersion::CALLBACKS_OLD. Or if You are sure that DPDK version used is lower than 17.11. If some callback is not provided (NULL) the request will always succeeds.  <a href="structpcpp_1_1_kni_device_1_1_kni_old_ioctl_callbacks.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="pub-types"></a>
Public Types</h2></td></tr>
<tr class="memitem:a9a016df4487ece71c8dc911961a4f329"><td class="memItemLeft" align="right" valign="top">enum &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classpcpp_1_1_kni_device.html#a9a016df4487ece71c8dc911961a4f329">KniLinkState</a> { <a class="el" href="classpcpp_1_1_kni_device.html#a9a016df4487ece71c8dc911961a4f329a404b3c5554c11081ce5b42f59d43bbd0">LINK_NOT_SUPPORTED</a> = -2, 
<a class="el" href="classpcpp_1_1_kni_device.html#a9a016df4487ece71c8dc911961a4f329ae13904b9463e2ccad7d7fc051e16591f">LINK_ERROR</a> = -1, 
<a class="el" href="classpcpp_1_1_kni_device.html#a9a016df4487ece71c8dc911961a4f329a5f628c7179cabc3691ad5cd974667643">LINK_DOWN</a> = 0, 
<a class="el" href="classpcpp_1_1_kni_device.html#a9a016df4487ece71c8dc911961a4f329a46ddb813939e1f5ada002c78996649f2">LINK_UP</a> = 1
 }</td></tr>
<tr class="separator:a9a016df4487ece71c8dc911961a4f329"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3fd22d62a55612b03481d65bc49fa0cc"><td class="memItemLeft" align="right" valign="top">enum &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classpcpp_1_1_kni_device.html#a3fd22d62a55612b03481d65bc49fa0cc">KniInfoState</a> { <a class="el" href="classpcpp_1_1_kni_device.html#a3fd22d62a55612b03481d65bc49fa0cca4950a91c9a09ef0cced588928b501945">INFO_CACHED</a> = 0, 
<a class="el" href="classpcpp_1_1_kni_device.html#a3fd22d62a55612b03481d65bc49fa0ccad71b838937713cff4f1bbe10b2193ada">INFO_RENEW</a> = 1
 }</td></tr>
<tr class="separator:a3fd22d62a55612b03481d65bc49fa0cc"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:acfeed0b25fa073d8a74b2d29ca218dc6"><td class="memItemLeft" align="right" valign="top">enum &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classpcpp_1_1_kni_device.html#acfeed0b25fa073d8a74b2d29ca218dc6">KniPromiscuousMode</a> { <a class="el" href="classpcpp_1_1_kni_device.html#acfeed0b25fa073d8a74b2d29ca218dc6af75609c56b3e20a626bde24b3867d2dd">PROMISC_DISABLE</a> = 0, 
<a class="el" href="classpcpp_1_1_kni_device.html#acfeed0b25fa073d8a74b2d29ca218dc6ab03872103ed6bd45be0db9fe29683edd">PROMISC_ENABLE</a> = 1
 }</td></tr>
<tr class="separator:acfeed0b25fa073d8a74b2d29ca218dc6"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="pub-methods"></a>
Public Member Functions</h2></td></tr>
<tr class="memitem:a40f81fc75157860db3c6ff93c70e228f"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classpcpp_1_1_kni_device.html#a40f81fc75157860db3c6ff93c70e228f">isInitialized</a> () const</td></tr>
<tr class="separator:a40f81fc75157860db3c6ff93c70e228f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a313c357df59ca65f3c390f9bc2dd98d1"><td class="memItemLeft" align="right" valign="top">std::string&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classpcpp_1_1_kni_device.html#a313c357df59ca65f3c390f9bc2dd98d1">getName</a> () const</td></tr>
<tr class="separator:a313c357df59ca65f3c390f9bc2dd98d1"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa4d4d8536d5fecfd9ab99a8c92b41971"><td class="memItemLeft" align="right" valign="top">uint16_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classpcpp_1_1_kni_device.html#aa4d4d8536d5fecfd9ab99a8c92b41971">getPort</a> () const</td></tr>
<tr class="separator:aa4d4d8536d5fecfd9ab99a8c92b41971"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a65ad16846869b52da79397723cd4e691"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classpcpp_1_1_kni_device.html#a9a016df4487ece71c8dc911961a4f329">KniLinkState</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classpcpp_1_1_kni_device.html#a65ad16846869b52da79397723cd4e691">getLinkState</a> (<a class="el" href="classpcpp_1_1_kni_device.html#a3fd22d62a55612b03481d65bc49fa0cc">KniInfoState</a> state=<a class="el" href="classpcpp_1_1_kni_device.html#a3fd22d62a55612b03481d65bc49fa0cca4950a91c9a09ef0cced588928b501945">INFO_CACHED</a>)</td></tr>
<tr class="memdesc:a65ad16846869b52da79397723cd4e691"><td class="mdescLeft">&#160;</td><td class="mdescRight">Obtains link status of KNI device. If called with INFO_CACHED - returns cached data about link state (SUPER FAST may be INACCURATE). If called with INFO_RENEW - makes system call to Linux to obtain link information and caches it (VERY SLOW but ACCURATE).  <a href="classpcpp_1_1_kni_device.html#a65ad16846869b52da79397723cd4e691">More...</a><br /></td></tr>
<tr class="separator:a65ad16846869b52da79397723cd4e691"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5a5025025675c14d984adde60a3f0c37"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classpcpp_1_1_mac_address.html">MacAddress</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classpcpp_1_1_kni_device.html#a5a5025025675c14d984adde60a3f0c37">getMacAddress</a> (<a class="el" href="classpcpp_1_1_kni_device.html#a3fd22d62a55612b03481d65bc49fa0cc">KniInfoState</a> state=<a class="el" href="classpcpp_1_1_kni_device.html#a3fd22d62a55612b03481d65bc49fa0cca4950a91c9a09ef0cced588928b501945">INFO_CACHED</a>)</td></tr>
<tr class="memdesc:a5a5025025675c14d984adde60a3f0c37"><td class="mdescLeft">&#160;</td><td class="mdescRight">Obtains MAC address of KNI device. If called with INFO_CACHED - returns cached data about MAC address (SUPER FAST may be INACCURATE). If called with INFO_RENEW - makes system call to Linux to obtain MAC address and caches it (VERY SLOW but ACCURATE).  <a href="classpcpp_1_1_kni_device.html#a5a5025025675c14d984adde60a3f0c37">More...</a><br /></td></tr>
<tr class="separator:a5a5025025675c14d984adde60a3f0c37"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae95905dfcd2e5aac787e03571cb9fdac"><td class="memItemLeft" align="right" valign="top">uint16_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classpcpp_1_1_kni_device.html#ae95905dfcd2e5aac787e03571cb9fdac">getMtu</a> (<a class="el" href="classpcpp_1_1_kni_device.html#a3fd22d62a55612b03481d65bc49fa0cc">KniInfoState</a> state=<a class="el" href="classpcpp_1_1_kni_device.html#a3fd22d62a55612b03481d65bc49fa0cca4950a91c9a09ef0cced588928b501945">INFO_CACHED</a>)</td></tr>
<tr class="memdesc:ae95905dfcd2e5aac787e03571cb9fdac"><td class="mdescLeft">&#160;</td><td class="mdescRight">Obtains MTU of KNI device. If called with INFO_CACHED - returns cached data about MTU (SUPER FAST may be INACCURATE). If called with INFO_RENEW - makes system call to Linux to obtain MTU and caches it (VERY SLOW but ACCURATE).  <a href="classpcpp_1_1_kni_device.html#ae95905dfcd2e5aac787e03571cb9fdac">More...</a><br /></td></tr>
<tr class="separator:ae95905dfcd2e5aac787e03571cb9fdac"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a24e3a5fcb269c6b12ce943fc4e000bde"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classpcpp_1_1_kni_device.html#acfeed0b25fa073d8a74b2d29ca218dc6">KniPromiscuousMode</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classpcpp_1_1_kni_device.html#a24e3a5fcb269c6b12ce943fc4e000bde">getPromiscuous</a> (<a class="el" href="classpcpp_1_1_kni_device.html#a3fd22d62a55612b03481d65bc49fa0cc">KniInfoState</a> state=<a class="el" href="classpcpp_1_1_kni_device.html#a3fd22d62a55612b03481d65bc49fa0cca4950a91c9a09ef0cced588928b501945">INFO_CACHED</a>)</td></tr>
<tr class="memdesc:a24e3a5fcb269c6b12ce943fc4e000bde"><td class="mdescLeft">&#160;</td><td class="mdescRight">Obtains information about promiscuous mode of KNI device. If called with INFO_CACHED - returns cached data about promiscuous mode (SUPER FAST may be INACCURATE). If called with INFO_RENEW - makes system call to Linux to obtain promiscuous mode and caches it (VERY SLOW but ACCURATE).  <a href="classpcpp_1_1_kni_device.html#a24e3a5fcb269c6b12ce943fc4e000bde">More...</a><br /></td></tr>
<tr class="separator:a24e3a5fcb269c6b12ce943fc4e000bde"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa16790972282b1abaf1116dc6cd32355"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classpcpp_1_1_kni_device.html#aa16790972282b1abaf1116dc6cd32355">setLinkState</a> (<a class="el" href="classpcpp_1_1_kni_device.html#a9a016df4487ece71c8dc911961a4f329">KniLinkState</a> state)</td></tr>
<tr class="memdesc:aa16790972282b1abaf1116dc6cd32355"><td class="mdescLeft">&#160;</td><td class="mdescRight">Sets link state of KNI device. Firstly the link information is updated as by call to getLinkState(INFO_RENEW). Then link state is set only if obtained state differs from provided. New link state of KNI device is cached.  <a href="classpcpp_1_1_kni_device.html#aa16790972282b1abaf1116dc6cd32355">More...</a><br /></td></tr>
<tr class="separator:aa16790972282b1abaf1116dc6cd32355"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6baf3b2af2d5edd81e85d57a7a7a5ae3"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classpcpp_1_1_kni_device.html#a6baf3b2af2d5edd81e85d57a7a7a5ae3">setMacAddress</a> (<a class="el" href="classpcpp_1_1_mac_address.html">MacAddress</a> mac)</td></tr>
<tr class="memdesc:a6baf3b2af2d5edd81e85d57a7a7a5ae3"><td class="mdescLeft">&#160;</td><td class="mdescRight">Sets MAC address of KNI device. Unconditionally changes MAC of KNI device. If MAC is updated successfully then it is cached.  <a href="classpcpp_1_1_kni_device.html#a6baf3b2af2d5edd81e85d57a7a7a5ae3">More...</a><br /></td></tr>
<tr class="separator:a6baf3b2af2d5edd81e85d57a7a7a5ae3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a84eb855f4a1ca4df14d23374b752edd6"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classpcpp_1_1_kni_device.html#a84eb855f4a1ca4df14d23374b752edd6">setMtu</a> (uint16_t mtu)</td></tr>
<tr class="memdesc:a84eb855f4a1ca4df14d23374b752edd6"><td class="mdescLeft">&#160;</td><td class="mdescRight">Sets MTU of KNI device. Unconditionally changes MTU of KNI device. If MTU is updated successfully then it is cached.  <a href="classpcpp_1_1_kni_device.html#a84eb855f4a1ca4df14d23374b752edd6">More...</a><br /></td></tr>
<tr class="separator:a84eb855f4a1ca4df14d23374b752edd6"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4ca4642ca8d30d931a084c7582aa3a6b"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classpcpp_1_1_kni_device.html#a4ca4642ca8d30d931a084c7582aa3a6b">setPromiscuous</a> (<a class="el" href="classpcpp_1_1_kni_device.html#acfeed0b25fa073d8a74b2d29ca218dc6">KniPromiscuousMode</a> mode)</td></tr>
<tr class="memdesc:a4ca4642ca8d30d931a084c7582aa3a6b"><td class="mdescLeft">&#160;</td><td class="mdescRight">Sets promiscuous mode of KNI device. Firstly the promiscuous mode information is updated as by call to getPromiscuous(INFO_RENEW). Then promiscuous mode is set only if obtained mode differs from provided. New promiscuous mode of KNI device is cached.  <a href="classpcpp_1_1_kni_device.html#a4ca4642ca8d30d931a084c7582aa3a6b">More...</a><br /></td></tr>
<tr class="separator:a4ca4642ca8d30d931a084c7582aa3a6b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4d0c0eb6a3dee13f287d0d72e2aa8b9c"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classpcpp_1_1_kni_device.html#a9a016df4487ece71c8dc911961a4f329">KniLinkState</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classpcpp_1_1_kni_device.html#a4d0c0eb6a3dee13f287d0d72e2aa8b9c">updateLinkState</a> (<a class="el" href="classpcpp_1_1_kni_device.html#a9a016df4487ece71c8dc911961a4f329">KniLinkState</a> state)</td></tr>
<tr class="memdesc:a4d0c0eb6a3dee13f287d0d72e2aa8b9c"><td class="mdescLeft">&#160;</td><td class="mdescRight">Updates link state of KNI device. Unconditionally updates link state of KNI device via call to DPDK librte_kni API. FASTER THAN setLinkState(state) but may not be supported or may fail. If link state is updated successfully then it is cached.  <a href="classpcpp_1_1_kni_device.html#a4d0c0eb6a3dee13f287d0d72e2aa8b9c">More...</a><br /></td></tr>
<tr class="separator:a4d0c0eb6a3dee13f287d0d72e2aa8b9c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab1c0ad9cc41211075af60930dc591d8e"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classpcpp_1_1_kni_device.html#ab1c0ad9cc41211075af60930dc591d8e">handleRequests</a> ()</td></tr>
<tr class="memdesc:ab1c0ad9cc41211075af60930dc591d8e"><td class="mdescLeft">&#160;</td><td class="mdescRight">Handle requests from Linux kernel synchronously in calling thread. When one of events which is needed application attention occurres it must be handled by calling this function (or by running RequestHandlerThread for this device). Until the request is handled the Linux kernel thread that manages this KNI is blocked. If it is not hanled by application in 3 seconds the request is reported to kernel as failed one. Current known requests are:  <a href="classpcpp_1_1_kni_device.html#ab1c0ad9cc41211075af60930dc591d8e">More...</a><br /></td></tr>
<tr class="separator:ab1c0ad9cc41211075af60930dc591d8e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aea9f67921e83cd832cbfc4eadb96855b"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classpcpp_1_1_kni_device.html#aea9f67921e83cd832cbfc4eadb96855b">startRequestHandlerThread</a> (long sleepSeconds, long sleepNanoSeconds=0)</td></tr>
<tr class="memdesc:aea9f67921e83cd832cbfc4eadb96855b"><td class="mdescLeft">&#160;</td><td class="mdescRight">Starts new thread (using pthread) to asynchronously handle KNI device requests. See description of <a class="el" href="classpcpp_1_1_kni_device.html#ab1c0ad9cc41211075af60930dc591d8e" title="Handle requests from Linux kernel synchronously in calling thread. When one of events which is needed...">handleRequests()</a> about requests. New thread is detached using pthread_detach. This thread can be stoped explicitly by calling <a class="el" href="classpcpp_1_1_kni_device.html#a9ea262da8ecc907b834fe7892241578e" title="Explicitly stops request thread for this device if it was running. See description of handleRequests(...">stopRequestHandlerThread()</a> or implicitly on KNI device destruction. Linux <a href="http://man7.org/linux/man-pages/man2/nanosleep.2.html">nanosleep()</a> function is used for sleeping.  <a href="classpcpp_1_1_kni_device.html#aea9f67921e83cd832cbfc4eadb96855b">More...</a><br /></td></tr>
<tr class="separator:aea9f67921e83cd832cbfc4eadb96855b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9ea262da8ecc907b834fe7892241578e"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classpcpp_1_1_kni_device.html#a9ea262da8ecc907b834fe7892241578e">stopRequestHandlerThread</a> ()</td></tr>
<tr class="memdesc:a9ea262da8ecc907b834fe7892241578e"><td class="mdescLeft">&#160;</td><td class="mdescRight">Explicitly stops request thread for this device if it was running. See description of <a class="el" href="classpcpp_1_1_kni_device.html#ab1c0ad9cc41211075af60930dc591d8e" title="Handle requests from Linux kernel synchronously in calling thread. When one of events which is needed...">handleRequests()</a> about requests.  <a href="classpcpp_1_1_kni_device.html#a9ea262da8ecc907b834fe7892241578e">More...</a><br /></td></tr>
<tr class="separator:a9ea262da8ecc907b834fe7892241578e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a85fadba90e945dcbb8915684f862e483"><td class="memItemLeft" align="right" valign="top">uint16_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classpcpp_1_1_kni_device.html#a85fadba90e945dcbb8915684f862e483">receivePackets</a> (<a class="el" href="namespacepcpp.html#a594cff22cd51c0a8acc36590c9733ecd">MBufRawPacketVector</a> &amp;rawPacketsArr)</td></tr>
<tr class="memdesc:a85fadba90e945dcbb8915684f862e483"><td class="mdescLeft">&#160;</td><td class="mdescRight">Receive raw packets from kernel.  <a href="classpcpp_1_1_kni_device.html#a85fadba90e945dcbb8915684f862e483">More...</a><br /></td></tr>
<tr class="separator:a85fadba90e945dcbb8915684f862e483"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a52256d09555727c9034037b19aa99c55"><td class="memItemLeft" align="right" valign="top">uint16_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classpcpp_1_1_kni_device.html#a52256d09555727c9034037b19aa99c55">receivePackets</a> (<a class="el" href="classpcpp_1_1_m_buf_raw_packet.html">MBufRawPacket</a> **rawPacketsArr, uint16_t rawPacketArrLength)</td></tr>
<tr class="memdesc:a52256d09555727c9034037b19aa99c55"><td class="mdescLeft">&#160;</td><td class="mdescRight">Receive raw packets from kernel. Please notice that in terms of performance, this is the best method to use for receiving packets because out of all receivePackets overloads this method requires the least overhead and is almost as efficient as receiving packets directly through DPDK. So if performance is a critical factor in your application, please use this method.  <a href="classpcpp_1_1_kni_device.html#a52256d09555727c9034037b19aa99c55">More...</a><br /></td></tr>
<tr class="separator:a52256d09555727c9034037b19aa99c55"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a25b6ac64fad904b0c0778acd96b9662c"><td class="memItemLeft" align="right" valign="top">uint16_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classpcpp_1_1_kni_device.html#a25b6ac64fad904b0c0778acd96b9662c">receivePackets</a> (<a class="el" href="classpcpp_1_1_packet.html">Packet</a> **packetsArr, uint16_t packetsArrLength)</td></tr>
<tr class="memdesc:a25b6ac64fad904b0c0778acd96b9662c"><td class="mdescLeft">&#160;</td><td class="mdescRight">Receive parsed packets from kernel.  <a href="classpcpp_1_1_kni_device.html#a25b6ac64fad904b0c0778acd96b9662c">More...</a><br /></td></tr>
<tr class="separator:a25b6ac64fad904b0c0778acd96b9662c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab9881c7b4a577be790dfee9e8b6a8e19"><td class="memItemLeft" align="right" valign="top">uint16_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classpcpp_1_1_kni_device.html#ab9881c7b4a577be790dfee9e8b6a8e19">sendPackets</a> (<a class="el" href="classpcpp_1_1_m_buf_raw_packet.html">MBufRawPacket</a> **rawPacketsArr, uint16_t arrLength)</td></tr>
<tr class="memdesc:ab9881c7b4a577be790dfee9e8b6a8e19"><td class="mdescLeft">&#160;</td><td class="mdescRight">Send an array of <a class="el" href="classpcpp_1_1_m_buf_raw_packet.html">MBufRawPacket</a> to kernel. Please notice the following:<br  />
  <a href="classpcpp_1_1_kni_device.html#ab9881c7b4a577be790dfee9e8b6a8e19">More...</a><br /></td></tr>
<tr class="separator:ab9881c7b4a577be790dfee9e8b6a8e19"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac0c2773ebeb2c0f0a49a8fb708d1d257"><td class="memItemLeft" align="right" valign="top">uint16_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classpcpp_1_1_kni_device.html#ac0c2773ebeb2c0f0a49a8fb708d1d257">sendPackets</a> (<a class="el" href="classpcpp_1_1_packet.html">Packet</a> **packetsArr, uint16_t arrLength)</td></tr>
<tr class="memdesc:ac0c2773ebeb2c0f0a49a8fb708d1d257"><td class="mdescLeft">&#160;</td><td class="mdescRight">Send an array of parsed packets to kernel. Please notice the following:<br  />
  <a href="classpcpp_1_1_kni_device.html#ac0c2773ebeb2c0f0a49a8fb708d1d257">More...</a><br /></td></tr>
<tr class="separator:ac0c2773ebeb2c0f0a49a8fb708d1d257"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa43aa821542e38f67503545175dc334e"><td class="memItemLeft" align="right" valign="top">uint16_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classpcpp_1_1_kni_device.html#aa43aa821542e38f67503545175dc334e">sendPackets</a> (<a class="el" href="namespacepcpp.html#a594cff22cd51c0a8acc36590c9733ecd">MBufRawPacketVector</a> &amp;rawPacketsVec)</td></tr>
<tr class="memdesc:aa43aa821542e38f67503545175dc334e"><td class="mdescLeft">&#160;</td><td class="mdescRight">Send a vector of <a class="el" href="classpcpp_1_1_m_buf_raw_packet.html">MBufRawPacket</a> pointers to kernel. Please notice the following:<br  />
  <a href="classpcpp_1_1_kni_device.html#aa43aa821542e38f67503545175dc334e">More...</a><br /></td></tr>
<tr class="separator:aa43aa821542e38f67503545175dc334e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:acf6de9a122dcf513108f58daed609afa"><td class="memItemLeft" align="right" valign="top">uint16_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classpcpp_1_1_kni_device.html#acf6de9a122dcf513108f58daed609afa">sendPackets</a> (<a class="el" href="namespacepcpp.html#a4c0775fb93a0867d2afa7992d55957f0">RawPacketVector</a> &amp;rawPacketsVec)</td></tr>
<tr class="memdesc:acf6de9a122dcf513108f58daed609afa"><td class="mdescLeft">&#160;</td><td class="mdescRight">Send a vector of <a class="el" href="classpcpp_1_1_raw_packet.html">RawPacket</a> pointers to kernel. Please notice the following:<br  />
  <a href="classpcpp_1_1_kni_device.html#acf6de9a122dcf513108f58daed609afa">More...</a><br /></td></tr>
<tr class="separator:acf6de9a122dcf513108f58daed609afa"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1b7d681b5e1128f4f0c63d71eca31621"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classpcpp_1_1_kni_device.html#a1b7d681b5e1128f4f0c63d71eca31621">sendPacket</a> (<a class="el" href="classpcpp_1_1_raw_packet.html">RawPacket</a> &amp;rawPacket)</td></tr>
<tr class="memdesc:a1b7d681b5e1128f4f0c63d71eca31621"><td class="mdescLeft">&#160;</td><td class="mdescRight">Send a raw packet to kernel. Please notice that if the raw packet isn't of type <a class="el" href="classpcpp_1_1_m_buf_raw_packet.html">MBufRawPacket</a>, a new temp <a class="el" href="classpcpp_1_1_m_buf_raw_packet.html">MBufRawPacket</a> will be created and the data will be copied to it. This is necessary to allocate an mbuf which will store the data to be sent. If performance is a critical factor please make sure you send a raw packet of type <a class="el" href="classpcpp_1_1_m_buf_raw_packet.html">MBufRawPacket</a>. Please also notice that the mbuf used or allocated in this method isn't freed by this method, it will be transparently freed by DPDK.  <a href="classpcpp_1_1_kni_device.html#a1b7d681b5e1128f4f0c63d71eca31621">More...</a><br /></td></tr>
<tr class="separator:a1b7d681b5e1128f4f0c63d71eca31621"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a03791dbfd1f8e47ec4ff55613d854719"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classpcpp_1_1_kni_device.html#a03791dbfd1f8e47ec4ff55613d854719">sendPacket</a> (<a class="el" href="classpcpp_1_1_m_buf_raw_packet.html">MBufRawPacket</a> &amp;rawPacket)</td></tr>
<tr class="memdesc:a03791dbfd1f8e47ec4ff55613d854719"><td class="mdescLeft">&#160;</td><td class="mdescRight">Send a <a class="el" href="classpcpp_1_1_m_buf_raw_packet.html">MBufRawPacket</a> to kernel. Please notice that the mbuf used in this method isn't freed by this method, it will be transparently freed by DPDK.  <a href="classpcpp_1_1_kni_device.html#a03791dbfd1f8e47ec4ff55613d854719">More...</a><br /></td></tr>
<tr class="separator:a03791dbfd1f8e47ec4ff55613d854719"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a295cb561420c5e9d219ef4d3aa4a230b"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classpcpp_1_1_kni_device.html#a295cb561420c5e9d219ef4d3aa4a230b">sendPacket</a> (<a class="el" href="classpcpp_1_1_packet.html">Packet</a> &amp;packet)</td></tr>
<tr class="memdesc:a295cb561420c5e9d219ef4d3aa4a230b"><td class="mdescLeft">&#160;</td><td class="mdescRight">Send a parsed packet to kernel. Please notice that the mbuf used or allocated in this method isn't freed by this method, it will be transparently freed by DPDK.  <a href="classpcpp_1_1_kni_device.html#a295cb561420c5e9d219ef4d3aa4a230b">More...</a><br /></td></tr>
<tr class="separator:a295cb561420c5e9d219ef4d3aa4a230b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3f5f48e1e2950cb3f2385d1bdda5a25e"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classpcpp_1_1_kni_device.html#a3f5f48e1e2950cb3f2385d1bdda5a25e">startCapture</a> (<a class="el" href="namespacepcpp.html#a5d5c27837ffd86e49a6b4ce2cc1ed57b">OnKniPacketArriveCallback</a> onPacketArrives, void *onPacketArrivesUserCookie)</td></tr>
<tr class="memdesc:a3f5f48e1e2950cb3f2385d1bdda5a25e"><td class="mdescLeft">&#160;</td><td class="mdescRight">Start capturing packets asynchronously on this KNI interface. Each time a burst of packets is captured the onPacketArrives callback is called. The capture is done on a new thread created by this method, meaning all callback calls are done in a thread other than the caller thread. Capture process will stop and this capture thread will be terminated when calling <a class="el" href="classpcpp_1_1_kni_device.html#aacdb5298cdb0fa1cc8a3563ef91e2546">stopCapture()</a>. This method must be called after the device is opened (i.e the <a class="el" href="classpcpp_1_1_kni_device.html#a2f66da689a3403a98d3d4f735b79cc50">open()</a> method was called), otherwise an error will be returned. Capturing thread will be terminated automatically on KNI device destruction or when <a class="el" href="classpcpp_1_1_kni_device.html#af1d2bdcdd4ec0ab6db3754af10f0c541" title="Close the KNI device. When device is closed it&#39;s not possible to work with it. Stops asynchronous pac...">close()</a> is called.  <a href="classpcpp_1_1_kni_device.html#a3f5f48e1e2950cb3f2385d1bdda5a25e">More...</a><br /></td></tr>
<tr class="separator:a3f5f48e1e2950cb3f2385d1bdda5a25e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7039519dc1d34590bb4a8b31ebc3ffe2"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classpcpp_1_1_kni_device.html#a7039519dc1d34590bb4a8b31ebc3ffe2">startCaptureBlockingMode</a> (<a class="el" href="namespacepcpp.html#a5d5c27837ffd86e49a6b4ce2cc1ed57b">OnKniPacketArriveCallback</a> onPacketArrives, void *onPacketArrivesUserCookie, int timeout)</td></tr>
<tr class="memdesc:a7039519dc1d34590bb4a8b31ebc3ffe2"><td class="mdescLeft">&#160;</td><td class="mdescRight">Start capturing packets synchronously on this KNI interface in blocking mode. Blocking mode means that this method block and won't return until the user frees the blocking (via onPacketArrives callback) or until a user defined timeout expires. Whenever a burst of packets is captured the onPacketArrives callback is called and lets the user handle the packet. In each callback call the user should return true if he wants to release the block or false if it wants it to keep blocking. Regardless of this callback a timeout is defined when stop capturing. When this timeout expires the method will return.<br  />
 Please notice that <a class="el" href="classpcpp_1_1_kni_device.html#aacdb5298cdb0fa1cc8a3563ef91e2546">stopCapture()</a> isn't needed here because when the method returns (after timeout or per user decision) capturing on the device is stopped.  <a href="classpcpp_1_1_kni_device.html#a7039519dc1d34590bb4a8b31ebc3ffe2">More...</a><br /></td></tr>
<tr class="separator:a7039519dc1d34590bb4a8b31ebc3ffe2"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aacdb5298cdb0fa1cc8a3563ef91e2546"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classpcpp_1_1_kni_device.html#aacdb5298cdb0fa1cc8a3563ef91e2546">stopCapture</a> ()</td></tr>
<tr class="separator:aacdb5298cdb0fa1cc8a3563ef91e2546"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2f66da689a3403a98d3d4f735b79cc50"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classpcpp_1_1_kni_device.html#a2f66da689a3403a98d3d4f735b79cc50">open</a> ()</td></tr>
<tr class="separator:a2f66da689a3403a98d3d4f735b79cc50"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af1d2bdcdd4ec0ab6db3754af10f0c541"><td class="memItemLeft" align="right" valign="top"><a id="af1d2bdcdd4ec0ab6db3754af10f0c541"></a>
void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classpcpp_1_1_kni_device.html#af1d2bdcdd4ec0ab6db3754af10f0c541">close</a> ()</td></tr>
<tr class="memdesc:af1d2bdcdd4ec0ab6db3754af10f0c541"><td class="mdescLeft">&#160;</td><td class="mdescRight">Close the KNI device. When device is closed it's not possible to work with it. Stops asynchronous packet capture if it is running. <br /></td></tr>
<tr class="separator:af1d2bdcdd4ec0ab6db3754af10f0c541"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="inherit_header pub_methods_classpcpp_1_1_i_device"><td colspan="2" onclick="javascript:toggleInherit('pub_methods_classpcpp_1_1_i_device')"><img src="closed.png" alt="-"/>&#160;Public Member Functions inherited from <a class="el" href="classpcpp_1_1_i_device.html">pcpp::IDevice</a></td></tr>
<tr class="memitem:a5b75e7491597f271b8f29847bec2ee99 inherit pub_methods_classpcpp_1_1_i_device"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classpcpp_1_1_i_device.html#a5b75e7491597f271b8f29847bec2ee99">isOpened</a> ()</td></tr>
<tr class="separator:a5b75e7491597f271b8f29847bec2ee99 inherit pub_methods_classpcpp_1_1_i_device"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table>
<a name="details" id="details"></a><h2 class="groupheader">Detailed Description</h2>
<div class="textblock"><p>This class represents special kind of DPDK devices called KNI - Kernel Network Interface that are used to exchange DPDK mbuf packets with Linux kernel network stack. This devices have only one RX and one TX queue so MT receiving or MT sending is not safe but simultaneous receiving and sending packets is MT safe. The RX queue of KNI device is pointed from kernel to application and TX queue is pointed in opposite direction - from application to kernel. So receive* methods will obtain packets from kernel and send* methods will send them to kernel.<br  />
 The lifecycle of the KNI device is as follows:</p><ul>
<li><a class="el" href="structpcpp_1_1_kni_device_1_1_kni_device_configuration.html" title="KNI device initialization data. Used to create new KNI device. Usage of callbacks member or oldCallba...">KniDeviceConfiguration</a> structure is created by user and filled with device settings;</li>
<li>The <a class="el" href="classpcpp_1_1_kni_device_list.html#a36f15dfe77675fdb81606ed9bdb07ff2" title="Getter for singleton.">KniDeviceList::getInstance</a> method is called to initialize the KNI module and obtain the <a class="el" href="classpcpp_1_1_kni_device_list.html">KniDeviceList</a> singleton;</li>
<li><a class="el" href="classpcpp_1_1_kni_device_list.html#a20344920bac3647235f624c33f50f6c8" title="Factory method for KNI devices. Newly created device is remembered under portId and name provided in ...">KniDeviceList::createDevice</a> method of the singleton is called to allocate new KNI device;</li>
<li>Device then must be opened by calling <a class="el" href="classpcpp_1_1_kni_device.html#a2f66da689a3403a98d3d4f735b79cc50">KniDevice::open</a>;</li>
<li>During lifetime the application must handle the requests from kernel either by calling <a class="el" href="classpcpp_1_1_kni_device.html#ab1c0ad9cc41211075af60930dc591d8e" title="Handle requests from Linux kernel synchronously in calling thread. When one of events which is needed...">KniDevice::handleRequests</a> to handle them synchronously or by starting separate thread to do this by calling <a class="el" href="classpcpp_1_1_kni_device.html#aea9f67921e83cd832cbfc4eadb96855b" title="Starts new thread (using pthread) to asynchronously handle KNI device requests. See description of ha...">KniDevice::startRequestHandlerThread</a>;</li>
<li>During lifetime the packets may be send to/received from KNI device via calls to synchronous API (send/receive methods) or asynchronously by running capturing thread using <a class="el" href="classpcpp_1_1_kni_device.html#a3f5f48e1e2950cb3f2385d1bdda5a25e" title="Start capturing packets asynchronously on this KNI interface. Each time a burst of packets is capture...">KniDevice::startCapture</a>;</li>
<li>KNI device will be destroyed or implicitly on application exit. User must assure that NO OTHER linux application is using KNI device when and after it is beeing destroyed otherwise Linux kernel may crush dramatically. </li>
</ul>
</div><h2 class="groupheader">Member Enumeration Documentation</h2>
<a id="a3fd22d62a55612b03481d65bc49fa0cc"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a3fd22d62a55612b03481d65bc49fa0cc">&#9670;&nbsp;</a></span>KniInfoState</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">enum <a class="el" href="classpcpp_1_1_kni_device.html#a3fd22d62a55612b03481d65bc49fa0cc">pcpp::KniDevice::KniInfoState</a></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Various information related constants for KNI device </p>
<table class="fieldtable">
<tr><th colspan="2">Enumerator</th></tr><tr><td class="fieldname"><a id="a3fd22d62a55612b03481d65bc49fa0cca4950a91c9a09ef0cced588928b501945"></a>INFO_CACHED&#160;</td><td class="fielddoc"><p>Used to identify intent to obtain cached version of KNI device information </p>
</td></tr>
<tr><td class="fieldname"><a id="a3fd22d62a55612b03481d65bc49fa0ccad71b838937713cff4f1bbe10b2193ada"></a>INFO_RENEW&#160;</td><td class="fielddoc"><p>Used to identify intent to renew/update KNI device information </p>
</td></tr>
</table>

</div>
</div>
<a id="a9a016df4487ece71c8dc911961a4f329"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a9a016df4487ece71c8dc911961a4f329">&#9670;&nbsp;</a></span>KniLinkState</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">enum <a class="el" href="classpcpp_1_1_kni_device.html#a9a016df4487ece71c8dc911961a4f329">pcpp::KniDevice::KniLinkState</a></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Various link related constants for KNI device </p>
<table class="fieldtable">
<tr><th colspan="2">Enumerator</th></tr><tr><td class="fieldname"><a id="a9a016df4487ece71c8dc911961a4f329a404b3c5554c11081ce5b42f59d43bbd0"></a>LINK_NOT_SUPPORTED&#160;</td><td class="fielddoc"><p>Returned by KNI functions if DPDK version used don't support link setup capability </p>
</td></tr>
<tr><td class="fieldname"><a id="a9a016df4487ece71c8dc911961a4f329ae13904b9463e2ccad7d7fc051e16591f"></a>LINK_ERROR&#160;</td><td class="fielddoc"><p>Returned by KNI functions if link changing function meets an error </p>
</td></tr>
<tr><td class="fieldname"><a id="a9a016df4487ece71c8dc911961a4f329a5f628c7179cabc3691ad5cd974667643"></a>LINK_DOWN&#160;</td><td class="fielddoc"><p>Used to put link status on KNI device DOWN </p>
</td></tr>
<tr><td class="fieldname"><a id="a9a016df4487ece71c8dc911961a4f329a46ddb813939e1f5ada002c78996649f2"></a>LINK_UP&#160;</td><td class="fielddoc"><p>Used to put link status on KNI device UP </p>
</td></tr>
</table>

</div>
</div>
<a id="acfeed0b25fa073d8a74b2d29ca218dc6"></a>
<h2 class="memtitle"><span class="permalink"><a href="#acfeed0b25fa073d8a74b2d29ca218dc6">&#9670;&nbsp;</a></span>KniPromiscuousMode</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">enum <a class="el" href="classpcpp_1_1_kni_device.html#acfeed0b25fa073d8a74b2d29ca218dc6">pcpp::KniDevice::KniPromiscuousMode</a></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Promiscuous mode related constants for KNI device </p>
<table class="fieldtable">
<tr><th colspan="2">Enumerator</th></tr><tr><td class="fieldname"><a id="acfeed0b25fa073d8a74b2d29ca218dc6af75609c56b3e20a626bde24b3867d2dd"></a>PROMISC_DISABLE&#160;</td><td class="fielddoc"><p>Used to DISABLE promiscuous mode on KNI device </p>
</td></tr>
<tr><td class="fieldname"><a id="acfeed0b25fa073d8a74b2d29ca218dc6ab03872103ed6bd45be0db9fe29683edd"></a>PROMISC_ENABLE&#160;</td><td class="fielddoc"><p>Used to ENABLE promiscuous mode on KNI device </p>
</td></tr>
</table>

</div>
</div>
<h2 class="groupheader">Member Function Documentation</h2>
<a id="a65ad16846869b52da79397723cd4e691"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a65ad16846869b52da79397723cd4e691">&#9670;&nbsp;</a></span>getLinkState()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classpcpp_1_1_kni_device.html#a9a016df4487ece71c8dc911961a4f329">KniLinkState</a> pcpp::KniDevice::getLinkState </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classpcpp_1_1_kni_device.html#a3fd22d62a55612b03481d65bc49fa0cc">KniInfoState</a>&#160;</td>
          <td class="paramname"><em>state</em> = <code><a class="el" href="classpcpp_1_1_kni_device.html#a3fd22d62a55612b03481d65bc49fa0cca4950a91c9a09ef0cced588928b501945">INFO_CACHED</a></code></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Obtains link status of KNI device. If called with INFO_CACHED - returns cached data about link state (SUPER FAST may be INACCURATE). If called with INFO_RENEW - makes system call to Linux to obtain link information and caches it (VERY SLOW but ACCURATE). </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">state</td><td>Defines information relevance level </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>LINK_UP, LINK_DOWN, LINK_NOT_SUPPORTED if device is not initialized, some times LINK_ERROR </dd></dl>

</div>
</div>
<a id="a5a5025025675c14d984adde60a3f0c37"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a5a5025025675c14d984adde60a3f0c37">&#9670;&nbsp;</a></span>getMacAddress()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classpcpp_1_1_mac_address.html">MacAddress</a> pcpp::KniDevice::getMacAddress </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classpcpp_1_1_kni_device.html#a3fd22d62a55612b03481d65bc49fa0cc">KniInfoState</a>&#160;</td>
          <td class="paramname"><em>state</em> = <code><a class="el" href="classpcpp_1_1_kni_device.html#a3fd22d62a55612b03481d65bc49fa0cca4950a91c9a09ef0cced588928b501945">INFO_CACHED</a></code></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Obtains MAC address of KNI device. If called with INFO_CACHED - returns cached data about MAC address (SUPER FAST may be INACCURATE). If called with INFO_RENEW - makes system call to Linux to obtain MAC address and caches it (VERY SLOW but ACCURATE). </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">state</td><td>Defines information relevance level </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Known MAC address of KNI interface </dd></dl>

</div>
</div>
<a id="ae95905dfcd2e5aac787e03571cb9fdac"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ae95905dfcd2e5aac787e03571cb9fdac">&#9670;&nbsp;</a></span>getMtu()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">uint16_t pcpp::KniDevice::getMtu </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classpcpp_1_1_kni_device.html#a3fd22d62a55612b03481d65bc49fa0cc">KniInfoState</a>&#160;</td>
          <td class="paramname"><em>state</em> = <code><a class="el" href="classpcpp_1_1_kni_device.html#a3fd22d62a55612b03481d65bc49fa0cca4950a91c9a09ef0cced588928b501945">INFO_CACHED</a></code></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Obtains MTU of KNI device. If called with INFO_CACHED - returns cached data about MTU (SUPER FAST may be INACCURATE). If called with INFO_RENEW - makes system call to Linux to obtain MTU and caches it (VERY SLOW but ACCURATE). </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">state</td><td>Defines information relevance level </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Known MTU of KNI interface </dd></dl>

</div>
</div>
<a id="a313c357df59ca65f3c390f9bc2dd98d1"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a313c357df59ca65f3c390f9bc2dd98d1">&#9670;&nbsp;</a></span>getName()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">std::string pcpp::KniDevice::getName </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Obtains name of KNI device in form of C++ string </p>

</div>
</div>
<a id="aa4d4d8536d5fecfd9ab99a8c92b41971"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aa4d4d8536d5fecfd9ab99a8c92b41971">&#9670;&nbsp;</a></span>getPort()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">uint16_t pcpp::KniDevice::getPort </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Obtains port ID of KNI device </p>

</div>
</div>
<a id="a24e3a5fcb269c6b12ce943fc4e000bde"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a24e3a5fcb269c6b12ce943fc4e000bde">&#9670;&nbsp;</a></span>getPromiscuous()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classpcpp_1_1_kni_device.html#acfeed0b25fa073d8a74b2d29ca218dc6">KniPromiscuousMode</a> pcpp::KniDevice::getPromiscuous </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classpcpp_1_1_kni_device.html#a3fd22d62a55612b03481d65bc49fa0cc">KniInfoState</a>&#160;</td>
          <td class="paramname"><em>state</em> = <code><a class="el" href="classpcpp_1_1_kni_device.html#a3fd22d62a55612b03481d65bc49fa0cca4950a91c9a09ef0cced588928b501945">INFO_CACHED</a></code></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Obtains information about promiscuous mode of KNI device. If called with INFO_CACHED - returns cached data about promiscuous mode (SUPER FAST may be INACCURATE). If called with INFO_RENEW - makes system call to Linux to obtain promiscuous mode and caches it (VERY SLOW but ACCURATE). </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">state</td><td>Defines information relevance level </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Known promiscuous mode of KNI interface </dd></dl>

</div>
</div>
<a id="ab1c0ad9cc41211075af60930dc591d8e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ab1c0ad9cc41211075af60930dc591d8e">&#9670;&nbsp;</a></span>handleRequests()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool pcpp::KniDevice::handleRequests </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Handle requests from Linux kernel synchronously in calling thread. When one of events which is needed application attention occurres it must be handled by calling this function (or by running RequestHandlerThread for this device). Until the request is handled the Linux kernel thread that manages this KNI is blocked. If it is not hanled by application in 3 seconds the request is reported to kernel as failed one. Current known requests are: </p>
<ul>
<li>change link state: ip l set [interface] up/down</li>
<li>change mtu: ip l set dev [interface] mtu [mtu_count]</li>
<li>change mac: ip l set [interface] address [new_mac]</li>
<li>change promiscuous mode: ip l set [interface] promisc on/off <dl class="section warning"><dt>Warning</dt><dd>Functions setLinkState, setMacAddress, setMtu and setPromiscuous will generate this requests. </dd></dl>
<dl class="section note"><dt>Note</dt><dd>Callbacks provided for this KNI device will be called synchronously in calling thread during execution of this function </dd></dl>
<dl class="section return"><dt>Returns</dt><dd>true if no error happend during request handling false otherwise </dd></dl>
</li>
</ul>

</div>
</div>
<a id="a40f81fc75157860db3c6ff93c70e228f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a40f81fc75157860db3c6ff93c70e228f">&#9670;&nbsp;</a></span>isInitialized()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool pcpp::KniDevice::isInitialized </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Indicates whether the KNI device was initialized successfully </p>

</div>
</div>
<a id="a2f66da689a3403a98d3d4f735b79cc50"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a2f66da689a3403a98d3d4f735b79cc50">&#9670;&nbsp;</a></span>open()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool pcpp::KniDevice::open </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Takes appropriate actions for opening KNI device. </p><dl class="section return"><dt>Returns</dt><dd>true if the device was opened successfully, false if device is already opened, or KNI device configuration and startup failed </dd></dl>

<p>Implements <a class="el" href="classpcpp_1_1_i_device.html#ad7bed3f1134e8b4329295b4af6733b9f">pcpp::IDevice</a>.</p>

</div>
</div>
<a id="a52256d09555727c9034037b19aa99c55"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a52256d09555727c9034037b19aa99c55">&#9670;&nbsp;</a></span>receivePackets() <span class="overload">[1/3]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">uint16_t pcpp::KniDevice::receivePackets </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classpcpp_1_1_m_buf_raw_packet.html">MBufRawPacket</a> **&#160;</td>
          <td class="paramname"><em>rawPacketsArr</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint16_t&#160;</td>
          <td class="paramname"><em>rawPacketArrLength</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Receive raw packets from kernel. Please notice that in terms of performance, this is the best method to use for receiving packets because out of all receivePackets overloads this method requires the least overhead and is almost as efficient as receiving packets directly through DPDK. So if performance is a critical factor in your application, please use this method. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[out]</td><td class="paramname">rawPacketsArr</td><td>A pointer to an array of <a class="el" href="classpcpp_1_1_m_buf_raw_packet.html">MBufRawPacket</a> pointers where all received packets will be written into. The array is expected to be allocated by the user and its length should be provided in rawPacketArrLength. Number of packets received will be returned. Notice it's the user responsibility to free the array and its content when done using it </td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">rawPacketArrLength</td><td>The length of <a class="el" href="classpcpp_1_1_m_buf_raw_packet.html">MBufRawPacket</a> pointers array </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The number of packets received. If an error occurred 0 will be returned and the error will be printed to log </dd></dl>

</div>
</div>
<a id="a85fadba90e945dcbb8915684f862e483"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a85fadba90e945dcbb8915684f862e483">&#9670;&nbsp;</a></span>receivePackets() <span class="overload">[2/3]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">uint16_t pcpp::KniDevice::receivePackets </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="namespacepcpp.html#a594cff22cd51c0a8acc36590c9733ecd">MBufRawPacketVector</a> &amp;&#160;</td>
          <td class="paramname"><em>rawPacketsArr</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Receive raw packets from kernel. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[out]</td><td class="paramname">rawPacketsArr</td><td>A vector where all received packets will be written into </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The number of packets received. If an error occurred 0 will be returned and the error will be printed to log </dd></dl>

</div>
</div>
<a id="a25b6ac64fad904b0c0778acd96b9662c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a25b6ac64fad904b0c0778acd96b9662c">&#9670;&nbsp;</a></span>receivePackets() <span class="overload">[3/3]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">uint16_t pcpp::KniDevice::receivePackets </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classpcpp_1_1_packet.html">Packet</a> **&#160;</td>
          <td class="paramname"><em>packetsArr</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint16_t&#160;</td>
          <td class="paramname"><em>packetsArrLength</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Receive parsed packets from kernel. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[out]</td><td class="paramname">packetsArr</td><td>A pointer to an allocated array of <a class="el" href="classpcpp_1_1_packet.html">Packet</a> pointers where all received packets will be written into. The array is expected to be allocated by the user and its length should be provided in packetsArrLength. Number of packets received will be returned. Notice it's the user responsibility to free the array and its content when done using it </td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">packetsArrLength</td><td>The length of <a class="el" href="classpcpp_1_1_packet.html">Packet</a> pointers array </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The number of packets received. If an error occurred 0 will be returned and the error will be printed to log </dd></dl>

</div>
</div>
<a id="a03791dbfd1f8e47ec4ff55613d854719"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a03791dbfd1f8e47ec4ff55613d854719">&#9670;&nbsp;</a></span>sendPacket() <span class="overload">[1/3]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool pcpp::KniDevice::sendPacket </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classpcpp_1_1_m_buf_raw_packet.html">MBufRawPacket</a> &amp;&#160;</td>
          <td class="paramname"><em>rawPacket</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Send a <a class="el" href="classpcpp_1_1_m_buf_raw_packet.html">MBufRawPacket</a> to kernel. Please notice that the mbuf used in this method isn't freed by this method, it will be transparently freed by DPDK. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">rawPacket</td><td>The <a class="el" href="classpcpp_1_1_m_buf_raw_packet.html">MBufRawPacket</a> to send </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>True if packet was sent successfully or false if device is not opened or if the packet wasn't sent for any other reason </dd></dl>

</div>
</div>
<a id="a295cb561420c5e9d219ef4d3aa4a230b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a295cb561420c5e9d219ef4d3aa4a230b">&#9670;&nbsp;</a></span>sendPacket() <span class="overload">[2/3]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool pcpp::KniDevice::sendPacket </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classpcpp_1_1_packet.html">Packet</a> &amp;&#160;</td>
          <td class="paramname"><em>packet</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Send a parsed packet to kernel. Please notice that the mbuf used or allocated in this method isn't freed by this method, it will be transparently freed by DPDK. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">packet</td><td>The parsed packet to send. Please notice that if the packet contains a raw packet which isn't of type <a class="el" href="classpcpp_1_1_m_buf_raw_packet.html">MBufRawPacket</a>, a new temp <a class="el" href="classpcpp_1_1_m_buf_raw_packet.html">MBufRawPacket</a> will be created and the data will be copied to it. This is necessary to allocate an mbuf which will store the data to be sent. If performance is a critical factor please make sure you send a parsed packet that contains a raw packet of type <a class="el" href="classpcpp_1_1_m_buf_raw_packet.html">MBufRawPacket</a> </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>True if packet was sent successfully or false if device is not opened or if the packet wasn't sent for any other reason </dd></dl>

</div>
</div>
<a id="a1b7d681b5e1128f4f0c63d71eca31621"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a1b7d681b5e1128f4f0c63d71eca31621">&#9670;&nbsp;</a></span>sendPacket() <span class="overload">[3/3]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool pcpp::KniDevice::sendPacket </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classpcpp_1_1_raw_packet.html">RawPacket</a> &amp;&#160;</td>
          <td class="paramname"><em>rawPacket</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Send a raw packet to kernel. Please notice that if the raw packet isn't of type <a class="el" href="classpcpp_1_1_m_buf_raw_packet.html">MBufRawPacket</a>, a new temp <a class="el" href="classpcpp_1_1_m_buf_raw_packet.html">MBufRawPacket</a> will be created and the data will be copied to it. This is necessary to allocate an mbuf which will store the data to be sent. If performance is a critical factor please make sure you send a raw packet of type <a class="el" href="classpcpp_1_1_m_buf_raw_packet.html">MBufRawPacket</a>. Please also notice that the mbuf used or allocated in this method isn't freed by this method, it will be transparently freed by DPDK. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">rawPacket</td><td>The raw packet to send </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>True if packet was sent successfully or false if the packet wasn't sent for any other reason </dd></dl>

</div>
</div>
<a id="ab9881c7b4a577be790dfee9e8b6a8e19"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ab9881c7b4a577be790dfee9e8b6a8e19">&#9670;&nbsp;</a></span>sendPackets() <span class="overload">[1/4]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">uint16_t pcpp::KniDevice::sendPackets </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classpcpp_1_1_m_buf_raw_packet.html">MBufRawPacket</a> **&#160;</td>
          <td class="paramname"><em>rawPacketsArr</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint16_t&#160;</td>
          <td class="paramname"><em>arrLength</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Send an array of <a class="el" href="classpcpp_1_1_m_buf_raw_packet.html">MBufRawPacket</a> to kernel. Please notice the following:<br  />
 </p>
<ul>
<li>In terms of performance, this is the best method to use for sending packets because out of all sendPackets overloads this method requires the least overhead and is almost as efficient as sending the packets directly through DPDK. So if performance is a critical factor in your application, please use this method</li>
<li>If the number of packets to send is higher than 64 this method will run multiple iterations of sending packets to DPDK, each iteration of 64 packets</li>
<li>The mbufs used in this method aren't freed by this method, they will be transparently freed by DPDK <br  />
<br  />
 <dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">rawPacketsArr</td><td>A pointer to an array of <a class="el" href="classpcpp_1_1_m_buf_raw_packet.html">MBufRawPacket</a> </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">arrLength</td><td>The length of the array </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The number of packets actually and successfully sent </dd></dl>
</li>
</ul>

</div>
</div>
<a id="aa43aa821542e38f67503545175dc334e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aa43aa821542e38f67503545175dc334e">&#9670;&nbsp;</a></span>sendPackets() <span class="overload">[2/4]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">uint16_t pcpp::KniDevice::sendPackets </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="namespacepcpp.html#a594cff22cd51c0a8acc36590c9733ecd">MBufRawPacketVector</a> &amp;&#160;</td>
          <td class="paramname"><em>rawPacketsVec</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Send a vector of <a class="el" href="classpcpp_1_1_m_buf_raw_packet.html">MBufRawPacket</a> pointers to kernel. Please notice the following:<br  />
 </p>
<ul>
<li>If the number of packets to send is higher than 64 this method will run multiple iterations of sending packets to DPDK, each iteration of 64 packets</li>
<li>The mbufs used in this method aren't freed by this method, they will be transparently freed by DPDK <br  />
<br  />
 <dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">rawPacketsVec</td><td>The vector of raw packet </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The number of packets actually and successfully sent </dd></dl>
</li>
</ul>

</div>
</div>
<a id="ac0c2773ebeb2c0f0a49a8fb708d1d257"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ac0c2773ebeb2c0f0a49a8fb708d1d257">&#9670;&nbsp;</a></span>sendPackets() <span class="overload">[3/4]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">uint16_t pcpp::KniDevice::sendPackets </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classpcpp_1_1_packet.html">Packet</a> **&#160;</td>
          <td class="paramname"><em>packetsArr</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint16_t&#160;</td>
          <td class="paramname"><em>arrLength</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Send an array of parsed packets to kernel. Please notice the following:<br  />
 </p>
<ul>
<li>If some or all of the packets contain raw packets which aren't of type <a class="el" href="classpcpp_1_1_m_buf_raw_packet.html">MBufRawPacket</a>, a new temp <a class="el" href="classpcpp_1_1_m_buf_raw_packet.html">MBufRawPacket</a> instances will be created and packet data will be copied to them. This is necessary to allocate mbufs which will store the data to be sent. If performance is a critical factor please make sure you send parsed packets that contain only raw packets of type <a class="el" href="classpcpp_1_1_m_buf_raw_packet.html">MBufRawPacket</a></li>
<li>If the number of packets to send is higher than 64 this method will run multiple iterations of sending packets to DPDK, each iteration of 64 packets</li>
<li>The mbufs used or allocated in this method aren't freed by this method, they will be transparently freed by DPDK <br  />
<br  />
 <dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">packetsArr</td><td>A pointer to an array of parsed packet pointers </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">arrLength</td><td>The length of the array </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The number of packets actually and successfully sent </dd></dl>
</li>
</ul>

</div>
</div>
<a id="acf6de9a122dcf513108f58daed609afa"></a>
<h2 class="memtitle"><span class="permalink"><a href="#acf6de9a122dcf513108f58daed609afa">&#9670;&nbsp;</a></span>sendPackets() <span class="overload">[4/4]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">uint16_t pcpp::KniDevice::sendPackets </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="namespacepcpp.html#a4c0775fb93a0867d2afa7992d55957f0">RawPacketVector</a> &amp;&#160;</td>
          <td class="paramname"><em>rawPacketsVec</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Send a vector of <a class="el" href="classpcpp_1_1_raw_packet.html">RawPacket</a> pointers to kernel. Please notice the following:<br  />
 </p>
<ul>
<li>If some or all of the raw packets aren't of type <a class="el" href="classpcpp_1_1_m_buf_raw_packet.html">MBufRawPacket</a>, a new temp <a class="el" href="classpcpp_1_1_m_buf_raw_packet.html">MBufRawPacket</a> instances will be created and packet data will be copied to them. This is necessary to allocate mbufs which will store the data to be sent. If performance is a critical factor please make sure you send only raw packets of type <a class="el" href="classpcpp_1_1_m_buf_raw_packet.html">MBufRawPacket</a> (or use the sendPackets overload that sends MBufRawPacketVector)</li>
<li>If the number of packets to send is higher than 64 this method will run multiple iterations of sending packets to DPDK, each iteration of 64 packets</li>
<li>The mbufs used or allocated in this method aren't freed by this method, they will be transparently freed by DPDK <br  />
<br  />
 <dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">rawPacketsVec</td><td>The vector of raw packet </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The number of packets actually and successfully sent </dd></dl>
</li>
</ul>

</div>
</div>
<a id="aa16790972282b1abaf1116dc6cd32355"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aa16790972282b1abaf1116dc6cd32355">&#9670;&nbsp;</a></span>setLinkState()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool pcpp::KniDevice::setLinkState </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classpcpp_1_1_kni_device.html#a9a016df4487ece71c8dc911961a4f329">KniLinkState</a>&#160;</td>
          <td class="paramname"><em>state</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Sets link state of KNI device. Firstly the link information is updated as by call to getLinkState(INFO_RENEW). Then link state is set only if obtained state differs from provided. New link state of KNI device is cached. </p>
<dl class="section note"><dt>Note</dt><dd>You must be using sudo or be root or have CAP_NET_ADMIN capability to use this function </dd>
<dd>
Generates change link state request </dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">state</td><td>Must be LINK_UP or LINK_DOWN </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>true if desired link state of KNI device is set (was as provided or set successfully), false if some error occurred (debug info is printed) </dd></dl>

</div>
</div>
<a id="a6baf3b2af2d5edd81e85d57a7a7a5ae3"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a6baf3b2af2d5edd81e85d57a7a7a5ae3">&#9670;&nbsp;</a></span>setMacAddress()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool pcpp::KniDevice::setMacAddress </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classpcpp_1_1_mac_address.html">MacAddress</a>&#160;</td>
          <td class="paramname"><em>mac</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Sets MAC address of KNI device. Unconditionally changes MAC of KNI device. If MAC is updated successfully then it is cached. </p>
<dl class="section note"><dt>Note</dt><dd>You must be using sudo or be root or have CAP_NET_ADMIN capability to use this function </dd>
<dd>
Generates change mac request </dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">mac</td><td>New MAC address of KNI device </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>true if desired MAC address is set, false if not and some error occurred (debug info is printed) </dd></dl>

</div>
</div>
<a id="a84eb855f4a1ca4df14d23374b752edd6"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a84eb855f4a1ca4df14d23374b752edd6">&#9670;&nbsp;</a></span>setMtu()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool pcpp::KniDevice::setMtu </td>
          <td>(</td>
          <td class="paramtype">uint16_t&#160;</td>
          <td class="paramname"><em>mtu</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Sets MTU of KNI device. Unconditionally changes MTU of KNI device. If MTU is updated successfully then it is cached. </p>
<dl class="section note"><dt>Note</dt><dd>You must be using sudo or be root or have CAP_NET_ADMIN capability to use this function </dd>
<dd>
Generates change mtu request </dd></dl>
<dl class="section warning"><dt>Warning</dt><dd>Low MTU values may crush Linux kernel. Follow Your kernel version documentation for details </dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">mtu</td><td>New MTU address of KNI device </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>true if desired MTU is set, false if not and some error occurred (debug info is printed) </dd></dl>

</div>
</div>
<a id="a4ca4642ca8d30d931a084c7582aa3a6b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a4ca4642ca8d30d931a084c7582aa3a6b">&#9670;&nbsp;</a></span>setPromiscuous()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool pcpp::KniDevice::setPromiscuous </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classpcpp_1_1_kni_device.html#acfeed0b25fa073d8a74b2d29ca218dc6">KniPromiscuousMode</a>&#160;</td>
          <td class="paramname"><em>mode</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Sets promiscuous mode of KNI device. Firstly the promiscuous mode information is updated as by call to getPromiscuous(INFO_RENEW). Then promiscuous mode is set only if obtained mode differs from provided. New promiscuous mode of KNI device is cached. </p>
<dl class="section note"><dt>Note</dt><dd>You must be using sudo or be root or have CAP_NET_ADMIN capability to use this function </dd>
<dd>
Generates promiscuous mode request </dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">mode</td><td>Must be PROMISC_DISABLE or PROMISC_ENABLE </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>true if desired promiscuous mode of KNI device is set (was as provided or set successfully), false if some error occurred (debug info is printed) </dd></dl>

</div>
</div>
<a id="a3f5f48e1e2950cb3f2385d1bdda5a25e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a3f5f48e1e2950cb3f2385d1bdda5a25e">&#9670;&nbsp;</a></span>startCapture()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool pcpp::KniDevice::startCapture </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="namespacepcpp.html#a5d5c27837ffd86e49a6b4ce2cc1ed57b">OnKniPacketArriveCallback</a>&#160;</td>
          <td class="paramname"><em>onPacketArrives</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">void *&#160;</td>
          <td class="paramname"><em>onPacketArrivesUserCookie</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Start capturing packets asynchronously on this KNI interface. Each time a burst of packets is captured the onPacketArrives callback is called. The capture is done on a new thread created by this method, meaning all callback calls are done in a thread other than the caller thread. Capture process will stop and this capture thread will be terminated when calling <a class="el" href="classpcpp_1_1_kni_device.html#aacdb5298cdb0fa1cc8a3563ef91e2546">stopCapture()</a>. This method must be called after the device is opened (i.e the <a class="el" href="classpcpp_1_1_kni_device.html#a2f66da689a3403a98d3d4f735b79cc50">open()</a> method was called), otherwise an error will be returned. Capturing thread will be terminated automatically on KNI device destruction or when <a class="el" href="classpcpp_1_1_kni_device.html#af1d2bdcdd4ec0ab6db3754af10f0c541" title="Close the KNI device. When device is closed it&#39;s not possible to work with it. Stops asynchronous pac...">close()</a> is called. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">onPacketArrives</td><td>A callback that is called each time a burst of packets is captured </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">onPacketArrivesUserCookie</td><td>A pointer to a user provided object. This object will be transferred to the onPacketArrives callback each time it is called. This cookie is very useful for transferring objects that give context to the capture callback, for example: objects that counts packets, manages flow state or manages the application state according to the packet that was captured </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>True if capture started successfully, false if (relevant log error is printed in any case):<ul>
<li>Capture is already running</li>
<li>Device is not opened</li>
<li>Capture thread could not be created </li>
</ul>
</dd></dl>

</div>
</div>
<a id="a7039519dc1d34590bb4a8b31ebc3ffe2"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a7039519dc1d34590bb4a8b31ebc3ffe2">&#9670;&nbsp;</a></span>startCaptureBlockingMode()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int pcpp::KniDevice::startCaptureBlockingMode </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="namespacepcpp.html#a5d5c27837ffd86e49a6b4ce2cc1ed57b">OnKniPacketArriveCallback</a>&#160;</td>
          <td class="paramname"><em>onPacketArrives</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">void *&#160;</td>
          <td class="paramname"><em>onPacketArrivesUserCookie</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>timeout</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Start capturing packets synchronously on this KNI interface in blocking mode. Blocking mode means that this method block and won't return until the user frees the blocking (via onPacketArrives callback) or until a user defined timeout expires. Whenever a burst of packets is captured the onPacketArrives callback is called and lets the user handle the packet. In each callback call the user should return true if he wants to release the block or false if it wants it to keep blocking. Regardless of this callback a timeout is defined when stop capturing. When this timeout expires the method will return.<br  />
 Please notice that <a class="el" href="classpcpp_1_1_kni_device.html#aacdb5298cdb0fa1cc8a3563ef91e2546">stopCapture()</a> isn't needed here because when the method returns (after timeout or per user decision) capturing on the device is stopped. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">onPacketArrives</td><td>A callback given by the user for handling incoming packets. After handling each burst of packets the user needs to return a boolean value. True value indicates stop capturing and stop blocking and false value indicates continue capturing and blocking </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">onPacketArrivesUserCookie</td><td>A pointer to a user provided object. This object will be transferred to the onPacketArrives callback each time it is called. This cookie is very useful for transferring objects that give context to the capture callback, for example: objects that counts packets, manages flow state or manages the application state according to the packet that was captured </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">timeout</td><td>A timeout in seconds for the blocking to stop even if the user didn't return "true" in the onPacketArrives callback If this timeout is set to 0 or less the timeout will be ignored, meaning the method will keep blocking until the user frees it via the onPacketArrives callback </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>-1 if timeout expired, 1 if blocking was stopped via onPacketArrives callback or 0 if an error occurred (such as device not open etc.). When returning 0 an appropriate error message is printed to log </dd></dl>

</div>
</div>
<a id="aea9f67921e83cd832cbfc4eadb96855b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aea9f67921e83cd832cbfc4eadb96855b">&#9670;&nbsp;</a></span>startRequestHandlerThread()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool pcpp::KniDevice::startRequestHandlerThread </td>
          <td>(</td>
          <td class="paramtype">long&#160;</td>
          <td class="paramname"><em>sleepSeconds</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">long&#160;</td>
          <td class="paramname"><em>sleepNanoSeconds</em> = <code>0</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Starts new thread (using pthread) to asynchronously handle KNI device requests. See description of <a class="el" href="classpcpp_1_1_kni_device.html#ab1c0ad9cc41211075af60930dc591d8e" title="Handle requests from Linux kernel synchronously in calling thread. When one of events which is needed...">handleRequests()</a> about requests. New thread is detached using pthread_detach. This thread can be stoped explicitly by calling <a class="el" href="classpcpp_1_1_kni_device.html#a9ea262da8ecc907b834fe7892241578e" title="Explicitly stops request thread for this device if it was running. See description of handleRequests(...">stopRequestHandlerThread()</a> or implicitly on KNI device destruction. Linux <a href="http://man7.org/linux/man-pages/man2/nanosleep.2.html">nanosleep()</a> function is used for sleeping. </p>
<dl class="section note"><dt>Note</dt><dd>Callbacks provided for this KNI device will be called asynchronously in new thread </dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">sleepSeconds</td><td>Sleeping time in seconds </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">sleepNanoSeconds</td><td>Sleeping time in nanoseconds </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>true if new thread is started successfully false otherwise </dd></dl>

</div>
</div>
<a id="aacdb5298cdb0fa1cc8a3563ef91e2546"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aacdb5298cdb0fa1cc8a3563ef91e2546">&#9670;&nbsp;</a></span>stopCapture()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void pcpp::KniDevice::stopCapture </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Stop a currently running asynchronous packet capture. </p>

</div>
</div>
<a id="a9ea262da8ecc907b834fe7892241578e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a9ea262da8ecc907b834fe7892241578e">&#9670;&nbsp;</a></span>stopRequestHandlerThread()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void pcpp::KniDevice::stopRequestHandlerThread </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Explicitly stops request thread for this device if it was running. See description of <a class="el" href="classpcpp_1_1_kni_device.html#ab1c0ad9cc41211075af60930dc591d8e" title="Handle requests from Linux kernel synchronously in calling thread. When one of events which is needed...">handleRequests()</a> about requests. </p>
<dl class="section warning"><dt>Warning</dt><dd>There may be a rare error when request thread handles requests on already destroyed device. It occurres only because request thread is detached one but it is really really rare. In case of this error occuring (must be SIGSEGV) change type of created thread in startRequestHandlerThread function from DETACHED to JOINABLE. </dd></dl>

</div>
</div>
<a id="a4d0c0eb6a3dee13f287d0d72e2aa8b9c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a4d0c0eb6a3dee13f287d0d72e2aa8b9c">&#9670;&nbsp;</a></span>updateLinkState()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classpcpp_1_1_kni_device.html#a9a016df4487ece71c8dc911961a4f329">KniLinkState</a> pcpp::KniDevice::updateLinkState </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classpcpp_1_1_kni_device.html#a9a016df4487ece71c8dc911961a4f329">KniLinkState</a>&#160;</td>
          <td class="paramname"><em>state</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Updates link state of KNI device. Unconditionally updates link state of KNI device via call to DPDK librte_kni API. FASTER THAN setLinkState(state) but may not be supported or may fail. If link state is updated successfully then it is cached. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">state</td><td>New link state of KNI device </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>LINK_NOT_SUPPORTED if this capability is not supported by DPDK version used (DPDK ver &lt; 18.11), LINK_ERROR if attempt to set link state failed (may always fail on some systems see class description) LINK_DOWN - previous link state was DOWN, state is successfully updated to provided one LINK_UP - previous link state was UP, state is successfully updated to provided one </dd></dl>

</div>
</div>
</div><!-- contents -->
</div><!-- doc-content -->
<!-- start footer part -->
<div id="nav-path" class="navpath"><!-- id is needed for treeview function! -->
  <ul>
    <li class="navelem"><a class="el" href="namespacepcpp.html">pcpp</a></li><li class="navelem"><a class="el" href="classpcpp_1_1_kni_device.html">KniDevice</a></li>
    <li class="footer">Generated on Mon Dec 2 2019 23:53:22 for PcapPlusPlus by
    <a href="http://www.doxygen.org/index.html">
    <img class="footer" src="doxygen.png" alt="doxygen"/></a> 1.8.16 </li>
  </ul>
</div>
</body>
</html>
