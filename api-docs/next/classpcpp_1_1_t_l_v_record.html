<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "https://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=9"/>
<meta name="generator" content="Doxygen 1.9.1"/>
<meta name="viewport" content="width=device-width, initial-scale=1"/>
<title>PcapPlusPlus: pcpp::TLVRecord&lt; TRecType, TRecLen &gt; Class Template Reference</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<link href="navtree.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="resize.js"></script>
<script type="text/javascript" src="navtreedata.js"></script>
<script type="text/javascript" src="navtree.js"></script>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/searchdata.js"></script>
<script type="text/javascript" src="search/search.js"></script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
<link href="doxygen-mobile.css" rel="stylesheet" type="text/css"/>
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr style="height: 56px;">
  <td id="projectlogo"><img alt="Logo" src="logo_icon_large.ico"/></td>
  <td id="projectalign" style="padding-left: 0.5em;">
   <div id="projectname">PcapPlusPlus
   &#160;<span id="projectnumber">Next</span>
   </div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.9.1 -->
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:cf05388f2679ee054f2beb29a391d25f4e673ac3&amp;dn=gpl-2.0.txt GPL-v2 */
var searchBox = new SearchBox("searchBox", "search",false,'Search','.html');
/* @license-end */
</script>
<script type="text/javascript" src="menudata.js"></script>
<script type="text/javascript" src="menu.js"></script>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:cf05388f2679ee054f2beb29a391d25f4e673ac3&amp;dn=gpl-2.0.txt GPL-v2 */
$(function() {
  initMenu('',true,false,'search.php','Search');
  $(document).ready(function() { init_search(); });
});
/* @license-end */</script>
<div id="main-nav"></div>
</div><!-- top -->
<div id="side-nav" class="ui-resizable side-nav-resizable">
  <div id="nav-tree">
    <div id="nav-tree-contents">
      <div id="nav-sync" class="sync"></div>
    </div>
  </div>
  <div id="splitbar" style="-moz-user-select:none;" 
       class="ui-resizable-handle">
  </div>
</div>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:cf05388f2679ee054f2beb29a391d25f4e673ac3&amp;dn=gpl-2.0.txt GPL-v2 */
$(document).ready(function(){initNavTree('classpcpp_1_1_t_l_v_record.html',''); initResizable(); });
/* @license-end */
</script>
<div id="doc-content">
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
</div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<iframe src="javascript:void(0)" frameborder="0" 
        name="MSearchResults" id="MSearchResults">
</iframe>
</div>

<div class="header">
  <div class="summary">
<a href="#nested-classes">Classes</a> &#124;
<a href="#pub-methods">Public Member Functions</a> &#124;
<a href="#pub-static-methods">Static Public Member Functions</a> &#124;
<a href="classpcpp_1_1_t_l_v_record-members.html">List of all members</a>  </div>
  <div class="headertitle">
<div class="title">pcpp::TLVRecord&lt; TRecType, TRecLen &gt; Class Template Reference<span class="mlabels"><span class="mlabel">abstract</span></span></div>  </div>
</div><!--header-->
<div class="contents">

<p><code>#include &lt;<a class="el" href="_t_l_v_data_8h_source.html">TLVData.h</a>&gt;</code></p>
<table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="nested-classes"></a>
Classes</h2></td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structpcpp_1_1_t_l_v_record_1_1_t_l_v_raw_data.html">TLVRawData</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">A struct representing the TLV construct.  <a href="structpcpp_1_1_t_l_v_record_1_1_t_l_v_raw_data.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="pub-methods"></a>
Public Member Functions</h2></td></tr>
<tr class="memitem:a026522df3430ba5cc60f03c1a41aceb6"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classpcpp_1_1_t_l_v_record.html#a026522df3430ba5cc60f03c1a41aceb6">TLVRecord</a> (uint8_t *recordRawData)</td></tr>
<tr class="separator:a026522df3430ba5cc60f03c1a41aceb6"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a06c65d738332174555360bf0fcf79752"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classpcpp_1_1_t_l_v_record.html#a06c65d738332174555360bf0fcf79752">TLVRecord</a> (const <a class="el" href="classpcpp_1_1_t_l_v_record.html">TLVRecord</a> &amp;other)</td></tr>
<tr class="separator:a06c65d738332174555360bf0fcf79752"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a233ff1535e95b15b514731033579d148"><td class="memItemLeft" align="right" valign="top"><a id="a233ff1535e95b15b514731033579d148"></a>
virtual&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classpcpp_1_1_t_l_v_record.html#a233ff1535e95b15b514731033579d148">~TLVRecord</a> ()=default</td></tr>
<tr class="memdesc:a233ff1535e95b15b514731033579d148"><td class="mdescLeft">&#160;</td><td class="mdescRight">A d'tor for this class, currently does nothing. <br /></td></tr>
<tr class="separator:a233ff1535e95b15b514731033579d148"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:afc60806af9572d14483ed3b961579a60"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classpcpp_1_1_t_l_v_record.html#afc60806af9572d14483ed3b961579a60">assign</a> (uint8_t *recordRawData)</td></tr>
<tr class="separator:afc60806af9572d14483ed3b961579a60"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad742ccc40d30398c30d194e7f97bbc07"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classpcpp_1_1_t_l_v_record.html">TLVRecord</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classpcpp_1_1_t_l_v_record.html#ad742ccc40d30398c30d194e7f97bbc07">operator=</a> (const <a class="el" href="classpcpp_1_1_t_l_v_record.html">TLVRecord</a> &amp;other)</td></tr>
<tr class="separator:ad742ccc40d30398c30d194e7f97bbc07"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8b94bd90891b47c0617fabf18459c212"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classpcpp_1_1_t_l_v_record.html#a8b94bd90891b47c0617fabf18459c212">operator==</a> (const <a class="el" href="classpcpp_1_1_t_l_v_record.html">TLVRecord</a> &amp;rhs) const</td></tr>
<tr class="separator:a8b94bd90891b47c0617fabf18459c212"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2f02894d4417e42cd64b67a4673c9866"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classpcpp_1_1_t_l_v_record.html#a2f02894d4417e42cd64b67a4673c9866">operator!=</a> (const <a class="el" href="classpcpp_1_1_t_l_v_record.html">TLVRecord</a> &amp;rhs) const</td></tr>
<tr class="separator:a2f02894d4417e42cd64b67a4673c9866"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2c03958af00bae5ff4cb953e206becf0"><td class="memItemLeft" align="right" valign="top">TRecType&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classpcpp_1_1_t_l_v_record.html#a2c03958af00bae5ff4cb953e206becf0">getType</a> () const</td></tr>
<tr class="separator:a2c03958af00bae5ff4cb953e206becf0"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7e0a6f19fbc18d4f23263e5179d7d38e"><td class="memItemLeft" align="right" valign="top">uint8_t *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classpcpp_1_1_t_l_v_record.html#a7e0a6f19fbc18d4f23263e5179d7d38e">getValue</a> () const</td></tr>
<tr class="separator:a7e0a6f19fbc18d4f23263e5179d7d38e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac645af1daf82e0062d3c15fe92418801"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classpcpp_1_1_t_l_v_record.html#ac645af1daf82e0062d3c15fe92418801">isNull</a> () const</td></tr>
<tr class="separator:ac645af1daf82e0062d3c15fe92418801"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac19ebe875b28350a38b555f2fe12d865"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classpcpp_1_1_t_l_v_record.html#ac19ebe875b28350a38b555f2fe12d865">isNotNull</a> () const</td></tr>
<tr class="separator:ac19ebe875b28350a38b555f2fe12d865"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3cef912b3e79835e782e64e7947e4aa2"><td class="memItemLeft" align="right" valign="top">uint8_t *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classpcpp_1_1_t_l_v_record.html#a3cef912b3e79835e782e64e7947e4aa2">getRecordBasePtr</a> () const</td></tr>
<tr class="separator:a3cef912b3e79835e782e64e7947e4aa2"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae083ae0b87a8a0f4fd097a52b7dd41fa"><td class="memItemLeft" align="right" valign="top"><a id="ae083ae0b87a8a0f4fd097a52b7dd41fa"></a>
void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classpcpp_1_1_t_l_v_record.html#ae083ae0b87a8a0f4fd097a52b7dd41fa">purgeRecordData</a> ()</td></tr>
<tr class="memdesc:ae083ae0b87a8a0f4fd097a52b7dd41fa"><td class="mdescLeft">&#160;</td><td class="mdescRight">Free the memory of the TLV record raw data. <br /></td></tr>
<tr class="separator:ae083ae0b87a8a0f4fd097a52b7dd41fa"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac69de0f3ed861718067b2ab81629c1d5"><td class="memTemplParams" colspan="2">template&lt;typename T &gt; </td></tr>
<tr class="memitem:ac69de0f3ed861718067b2ab81629c1d5"><td class="memTemplItemLeft" align="right" valign="top">T&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classpcpp_1_1_t_l_v_record.html#ac69de0f3ed861718067b2ab81629c1d5">getValueAs</a> (size_t offset=0) const</td></tr>
<tr class="separator:ac69de0f3ed861718067b2ab81629c1d5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2d7906d1980f8101d5312966193bf9bd"><td class="memTemplParams" colspan="2">template&lt;typename T &gt; </td></tr>
<tr class="memitem:a2d7906d1980f8101d5312966193bf9bd"><td class="memTemplItemLeft" align="right" valign="top">bool&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classpcpp_1_1_t_l_v_record.html#a2d7906d1980f8101d5312966193bf9bd">setValue</a> (T newValue, int valueOffset=0)</td></tr>
<tr class="separator:a2d7906d1980f8101d5312966193bf9bd"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0df698c8dc4fd0bfe2daa39062edaa54"><td class="memItemLeft" align="right" valign="top">virtual size_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classpcpp_1_1_t_l_v_record.html#a0df698c8dc4fd0bfe2daa39062edaa54">getTotalSize</a> () const =0</td></tr>
<tr class="separator:a0df698c8dc4fd0bfe2daa39062edaa54"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab756e2100b55a66339c102908164c788"><td class="memItemLeft" align="right" valign="top">virtual size_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classpcpp_1_1_t_l_v_record.html#ab756e2100b55a66339c102908164c788">getDataSize</a> () const =0</td></tr>
<tr class="separator:ab756e2100b55a66339c102908164c788"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="pub-static-methods"></a>
Static Public Member Functions</h2></td></tr>
<tr class="memitem:aa1784bf9e0956fd4a973359ebe12e059"><td class="memItemLeft" align="right" valign="top">static bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classpcpp_1_1_t_l_v_record.html#aa1784bf9e0956fd4a973359ebe12e059">canAssign</a> (const uint8_t *recordRawData, size_t tlvDataLen)</td></tr>
<tr class="separator:aa1784bf9e0956fd4a973359ebe12e059"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table>
<a name="details" id="details"></a><h2 class="groupheader">Detailed Description</h2>
<div class="textblock"><h3>template&lt;typename TRecType, typename TRecLen&gt;<br />
class pcpp::TLVRecord&lt; TRecType, TRecLen &gt;</h3>

<p>A wrapper class for a Type-Length-Value (TLV) record. This class does not create or modify TLV records, but rather serves as a wrapper and provides useful methods for retrieving data from them. This class has several abstract methods that should be implemented in derived classes. These methods are for record length value calculation (the 'L' in TLV) which is implemented differently in different protocols </p>
</div><h2 class="groupheader">Constructor &amp; Destructor Documentation</h2>
<a id="a026522df3430ba5cc60f03c1a41aceb6"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a026522df3430ba5cc60f03c1a41aceb6">&#9670;&nbsp;</a></span>TLVRecord() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename TRecType , typename TRecLen &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classpcpp_1_1_t_l_v_record.html">pcpp::TLVRecord</a>&lt; TRecType, TRecLen &gt;::<a class="el" href="classpcpp_1_1_t_l_v_record.html">TLVRecord</a> </td>
          <td>(</td>
          <td class="paramtype">uint8_t *&#160;</td>
          <td class="paramname"><em>recordRawData</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>A c'tor for this class that gets a pointer to the TLV record raw data (byte array) </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">recordRawData</td><td>A pointer to the TLV record raw data </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a06c65d738332174555360bf0fcf79752"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a06c65d738332174555360bf0fcf79752">&#9670;&nbsp;</a></span>TLVRecord() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename TRecType , typename TRecLen &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classpcpp_1_1_t_l_v_record.html">pcpp::TLVRecord</a>&lt; TRecType, TRecLen &gt;::<a class="el" href="classpcpp_1_1_t_l_v_record.html">TLVRecord</a> </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classpcpp_1_1_t_l_v_record.html">TLVRecord</a>&lt; TRecType, TRecLen &gt; &amp;&#160;</td>
          <td class="paramname"><em>other</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>A copy c'tor for this class. This copy c'tor doesn't copy the TLV data, but only the pointer to it, which means that after calling it both the old and the new instance will point to the same TLV raw data </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">other</td><td>The <a class="el" href="classpcpp_1_1_t_l_v_record.html">TLVRecord</a> instance to copy from </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<h2 class="groupheader">Member Function Documentation</h2>
<a id="afc60806af9572d14483ed3b961579a60"></a>
<h2 class="memtitle"><span class="permalink"><a href="#afc60806af9572d14483ed3b961579a60">&#9670;&nbsp;</a></span>assign()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename TRecType , typename TRecLen &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classpcpp_1_1_t_l_v_record.html">pcpp::TLVRecord</a>&lt; TRecType, TRecLen &gt;::assign </td>
          <td>(</td>
          <td class="paramtype">uint8_t *&#160;</td>
          <td class="paramname"><em>recordRawData</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Assign a pointer to the TLV record raw data (byte array) </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">recordRawData</td><td>A pointer to the TLV record raw data </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="aa1784bf9e0956fd4a973359ebe12e059"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aa1784bf9e0956fd4a973359ebe12e059">&#9670;&nbsp;</a></span>canAssign()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename TRecType , typename TRecLen &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static bool <a class="el" href="classpcpp_1_1_t_l_v_record.html">pcpp::TLVRecord</a>&lt; TRecType, TRecLen &gt;::canAssign </td>
          <td>(</td>
          <td class="paramtype">const uint8_t *&#160;</td>
          <td class="paramname"><em>recordRawData</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>tlvDataLen</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Check if a pointer can be assigned to the TLV record data </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">recordRawData</td><td>A pointer to the TLV record raw data </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">tlvDataLen</td><td>The size of the TLV record raw data </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>True if data is valid and can be assigned </dd></dl>

</div>
</div>
<a id="ab756e2100b55a66339c102908164c788"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ab756e2100b55a66339c102908164c788">&#9670;&nbsp;</a></span>getDataSize()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename TRecType , typename TRecLen &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual size_t <a class="el" href="classpcpp_1_1_t_l_v_record.html">pcpp::TLVRecord</a>&lt; TRecType, TRecLen &gt;::getDataSize </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">pure virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<dl class="section return"><dt>Returns</dt><dd>The size of the record value (meaning the size of the 'V' part in TLV) </dd></dl>

<p>Implemented in <a class="el" href="classpcpp_1_1_tcp_option.html#a6e023af9f1517e6d1a02f0157cd682f2">pcpp::TcpOption</a>, <a class="el" href="classpcpp_1_1_radius_attribute.html#ae350b76bcf43fe56c0a3c0fac7bf7c48">pcpp::RadiusAttribute</a>, <a class="el" href="classpcpp_1_1_p_p_po_e_discovery_layer_1_1_p_p_po_e_tag.html#a8bce6b7f9268e22de4d5df266d020059">pcpp::PPPoEDiscoveryLayer::PPPoETag</a>, <a class="el" href="classpcpp_1_1_ndp_option.html#ac8e6be9b73a2df18e8e0d5b893d0a121">pcpp::NdpOption</a>, <a class="el" href="classpcpp_1_1_i_pv4_option.html#a91523ce4bc70bc9d5bfca01bf9e5084c">pcpp::IPv4Option</a>, <a class="el" href="classpcpp_1_1_gtp_v2_information_element.html#abc29983296449368f889162e85004cd9">pcpp::GtpV2InformationElement</a>, <a class="el" href="classpcpp_1_1_dhcp_v6_option.html#a0b652ee8615f14cabeefd87aa686d634">pcpp::DhcpV6Option</a>, <a class="el" href="classpcpp_1_1_dhcp_option.html#a380870773ecd2bc12088fe7170c30626">pcpp::DhcpOption</a>, and <a class="el" href="classpcpp_1_1_i_pv6_t_l_v_option_header_1_1_i_pv6_option.html#a382941c28bc594519a3cb439a1491da4">pcpp::IPv6TLVOptionHeader::IPv6Option</a>.</p>

</div>
</div>
<a id="a3cef912b3e79835e782e64e7947e4aa2"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a3cef912b3e79835e782e64e7947e4aa2">&#9670;&nbsp;</a></span>getRecordBasePtr()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename TRecType , typename TRecLen &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">uint8_t* <a class="el" href="classpcpp_1_1_t_l_v_record.html">pcpp::TLVRecord</a>&lt; TRecType, TRecLen &gt;::getRecordBasePtr </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<dl class="section return"><dt>Returns</dt><dd>A pointer to the TLV record raw data byte stream </dd></dl>

</div>
</div>
<a id="a0df698c8dc4fd0bfe2daa39062edaa54"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a0df698c8dc4fd0bfe2daa39062edaa54">&#9670;&nbsp;</a></span>getTotalSize()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename TRecType , typename TRecLen &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual size_t <a class="el" href="classpcpp_1_1_t_l_v_record.html">pcpp::TLVRecord</a>&lt; TRecType, TRecLen &gt;::getTotalSize </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">pure virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<dl class="section return"><dt>Returns</dt><dd>The total size of the TLV record (in bytes) </dd></dl>

<p>Implemented in <a class="el" href="classpcpp_1_1_tcp_option.html#a30e266b944ae97927a0cd215763f6a69">pcpp::TcpOption</a>, <a class="el" href="classpcpp_1_1_radius_attribute.html#aadc1ee06ebaf2a20e8f002834e597701">pcpp::RadiusAttribute</a>, <a class="el" href="classpcpp_1_1_p_p_po_e_discovery_layer_1_1_p_p_po_e_tag.html#ab606b75cc656dc54d5cb3c0915ac5b87">pcpp::PPPoEDiscoveryLayer::PPPoETag</a>, <a class="el" href="classpcpp_1_1_ndp_option.html#ad5bb2bfdd739bc9291278522b344a35a">pcpp::NdpOption</a>, <a class="el" href="classpcpp_1_1_i_pv4_option.html#ace1ff5efc30db0d5b6a00e6b29be0f3e">pcpp::IPv4Option</a>, <a class="el" href="classpcpp_1_1_gtp_v2_information_element.html#ac56ddc5c5026e9f6884a9a7adaac88ba">pcpp::GtpV2InformationElement</a>, <a class="el" href="classpcpp_1_1_dhcp_v6_option.html#a82b1f010b6b7fd95ceb08266f900df03">pcpp::DhcpV6Option</a>, <a class="el" href="classpcpp_1_1_dhcp_option.html#a9b8f200848e1b18a4a00ee3f357a4d2a">pcpp::DhcpOption</a>, and <a class="el" href="classpcpp_1_1_i_pv6_t_l_v_option_header_1_1_i_pv6_option.html#a2145e93d58855c929496a2a315a57e5a">pcpp::IPv6TLVOptionHeader::IPv6Option</a>.</p>

</div>
</div>
<a id="a2c03958af00bae5ff4cb953e206becf0"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a2c03958af00bae5ff4cb953e206becf0">&#9670;&nbsp;</a></span>getType()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename TRecType , typename TRecLen &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">TRecType <a class="el" href="classpcpp_1_1_t_l_v_record.html">pcpp::TLVRecord</a>&lt; TRecType, TRecLen &gt;::getType </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<dl class="section return"><dt>Returns</dt><dd>The type field of the record (the 'T' in <b>Type</b>-Length-Value) </dd></dl>

</div>
</div>
<a id="a7e0a6f19fbc18d4f23263e5179d7d38e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a7e0a6f19fbc18d4f23263e5179d7d38e">&#9670;&nbsp;</a></span>getValue()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename TRecType , typename TRecLen &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">uint8_t* <a class="el" href="classpcpp_1_1_t_l_v_record.html">pcpp::TLVRecord</a>&lt; TRecType, TRecLen &gt;::getValue </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<dl class="section return"><dt>Returns</dt><dd>A pointer to the value of the record as byte array (the 'V' in Type-Length- <b>Value</b>) </dd></dl>

</div>
</div>
<a id="ac69de0f3ed861718067b2ab81629c1d5"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ac69de0f3ed861718067b2ab81629c1d5">&#9670;&nbsp;</a></span>getValueAs()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename TRecType , typename TRecLen &gt; </div>
<div class="memtemplate">
template&lt;typename T &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">T <a class="el" href="classpcpp_1_1_t_l_v_record.html">pcpp::TLVRecord</a>&lt; TRecType, TRecLen &gt;::getValueAs </td>
          <td>(</td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>offset</em> = <code>0</code></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>A templated method to retrieve the record data as a certain type T. For example, if record data is 4B long (integer) then this method should be used as <a class="el" href="classpcpp_1_1_t_l_v_record.html#ac69de0f3ed861718067b2ab81629c1d5">getValueAs&lt;int&gt;()</a> and it will return the record data as an integer.<br  />
 Notice this return value is a copy of the data, not a pointer to the actual data </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">offset</td><td>The offset in the record data to start reading the value from. Useful for cases when you want to read some of the data that doesn't start at offset 0. This is an optional parameter and the default value is 0, meaning start reading the value at the beginning of the record data </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The record data as type T </dd></dl>

</div>
</div>
<a id="ac19ebe875b28350a38b555f2fe12d865"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ac19ebe875b28350a38b555f2fe12d865">&#9670;&nbsp;</a></span>isNotNull()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename TRecType , typename TRecLen &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool <a class="el" href="classpcpp_1_1_t_l_v_record.html">pcpp::TLVRecord</a>&lt; TRecType, TRecLen &gt;::isNotNull </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<dl class="section return"><dt>Returns</dt><dd>True if the TLV record raw data is not nullptr, false otherwise </dd></dl>

</div>
</div>
<a id="ac645af1daf82e0062d3c15fe92418801"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ac645af1daf82e0062d3c15fe92418801">&#9670;&nbsp;</a></span>isNull()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename TRecType , typename TRecLen &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool <a class="el" href="classpcpp_1_1_t_l_v_record.html">pcpp::TLVRecord</a>&lt; TRecType, TRecLen &gt;::isNull </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<dl class="section return"><dt>Returns</dt><dd>True if the TLV record raw data is nullptr, false otherwise </dd></dl>

</div>
</div>
<a id="a2f02894d4417e42cd64b67a4673c9866"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a2f02894d4417e42cd64b67a4673c9866">&#9670;&nbsp;</a></span>operator!=()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename TRecType , typename TRecLen &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool <a class="el" href="classpcpp_1_1_t_l_v_record.html">pcpp::TLVRecord</a>&lt; TRecType, TRecLen &gt;::operator!= </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classpcpp_1_1_t_l_v_record.html">TLVRecord</a>&lt; TRecType, TRecLen &gt; &amp;&#160;</td>
          <td class="paramname"><em>rhs</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Overload of the not equal operator. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">rhs</td><td>The object to compare to </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>True if objects are not equal, false otherwise </dd></dl>

</div>
</div>
<a id="ad742ccc40d30398c30d194e7f97bbc07"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ad742ccc40d30398c30d194e7f97bbc07">&#9670;&nbsp;</a></span>operator=()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename TRecType , typename TRecLen &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classpcpp_1_1_t_l_v_record.html">TLVRecord</a>&amp; <a class="el" href="classpcpp_1_1_t_l_v_record.html">pcpp::TLVRecord</a>&lt; TRecType, TRecLen &gt;::operator= </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classpcpp_1_1_t_l_v_record.html">TLVRecord</a>&lt; TRecType, TRecLen &gt; &amp;&#160;</td>
          <td class="paramname"><em>other</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Overload of the assignment operator. This operator doesn't copy the TLV data, but rather copies the pointer to it, which means that after calling it both the old and the new instance will point to the same TLV raw data </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">other</td><td>The <a class="el" href="classpcpp_1_1_t_l_v_record.html">TLVRecord</a> instance to assign </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a8b94bd90891b47c0617fabf18459c212"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a8b94bd90891b47c0617fabf18459c212">&#9670;&nbsp;</a></span>operator==()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename TRecType , typename TRecLen &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool <a class="el" href="classpcpp_1_1_t_l_v_record.html">pcpp::TLVRecord</a>&lt; TRecType, TRecLen &gt;::operator== </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classpcpp_1_1_t_l_v_record.html">TLVRecord</a>&lt; TRecType, TRecLen &gt; &amp;&#160;</td>
          <td class="paramname"><em>rhs</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Overload of the equality operator. Two record are equal if both of them point to the same data, or if they point to different data but their total size is equal and the raw data they both contain is similar. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">rhs</td><td>The object to compare to </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>True if both objects are equal, false otherwise </dd></dl>

</div>
</div>
<a id="a2d7906d1980f8101d5312966193bf9bd"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a2d7906d1980f8101d5312966193bf9bd">&#9670;&nbsp;</a></span>setValue()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename TRecType , typename TRecLen &gt; </div>
<div class="memtemplate">
template&lt;typename T &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool <a class="el" href="classpcpp_1_1_t_l_v_record.html">pcpp::TLVRecord</a>&lt; TRecType, TRecLen &gt;::setValue </td>
          <td>(</td>
          <td class="paramtype">T&#160;</td>
          <td class="paramname"><em>newValue</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>valueOffset</em> = <code>0</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>A templated method to copy data of type T into the TLV record data. For example: if record data is 4[Bytes] long use this method with &lt;int&gt; to set an integer value into the record data: setValue&lt;int&gt;(num) </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">newValue</td><td>The value of type T to copy to the record data </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">valueOffset</td><td>An optional parameter that specifies where to start setting the record data (default set to 0). For example: if record data is 20 bytes long and you only need to set the 4 last bytes as integer then use this method like this: setValue&lt;int&gt;(num, 16) </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>True if value was set successfully or false if the size of T is larger than the record data size </dd></dl>

</div>
</div>
</div><!-- contents -->
</div><!-- doc-content -->
<!-- start footer part -->
<div id="nav-path" class="navpath"><!-- id is needed for treeview function! -->
  <ul>
    <li class="navelem"><a class="el" href="namespacepcpp.html">pcpp</a></li><li class="navelem"><a class="el" href="classpcpp_1_1_t_l_v_record.html">TLVRecord</a></li>
    <li class="footer">Generated on Tue May 13 2025 08:15:03 for PcapPlusPlus by <a href="https://www.doxygen.org/index.html"><img class="footer" src="doxygen.svg" width="104" height="31" alt="doxygen"/></a> 1.9.1 </li>
  </ul>
</div>
</body>
</html>
