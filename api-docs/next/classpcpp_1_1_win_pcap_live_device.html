<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=9"/>
<meta name="generator" content="Doxygen 1.8.13"/>
<meta name="viewport" content="width=device-width, initial-scale=1"/>
<title>PcapPlusPlus: pcpp::WinPcapLiveDevice Class Reference</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<link href="navtree.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="resize.js"></script>
<script type="text/javascript" src="navtreedata.js"></script>
<script type="text/javascript" src="navtree.js"></script>
<script type="text/javascript">
  $(document).ready(initResizable);
</script>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/searchdata.js"></script>
<script type="text/javascript" src="search/search.js"></script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
<link href="doxygen-mobile.css" rel="stylesheet" type="text/css"/>
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr style="height: 56px;">
  <td id="projectlogo"><img alt="Logo" src="logo_icon_large.ico"/></td>
  <td id="projectalign" style="padding-left: 0.5em;">
   <div id="projectname">PcapPlusPlus
   &#160;<span id="projectnumber">Next</span>
   </div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.8.13 -->
<script type="text/javascript">
var searchBox = new SearchBox("searchBox", "search",false,'Search');
</script>
<script type="text/javascript" src="menudata.js"></script>
<script type="text/javascript" src="menu.js"></script>
<script type="text/javascript">
$(function() {
  initMenu('',true,false,'search.php','Search');
  $(document).ready(function() { init_search(); });
});
</script>
<div id="main-nav"></div>
</div><!-- top -->
<div id="side-nav" class="ui-resizable side-nav-resizable">
  <div id="nav-tree">
    <div id="nav-tree-contents">
      <div id="nav-sync" class="sync"></div>
    </div>
  </div>
  <div id="splitbar" style="-moz-user-select:none;" 
       class="ui-resizable-handle">
  </div>
</div>
<script type="text/javascript">
$(document).ready(function(){initNavTree('classpcpp_1_1_win_pcap_live_device.html','');});
</script>
<div id="doc-content">
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
</div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<iframe src="javascript:void(0)" frameborder="0" 
        name="MSearchResults" id="MSearchResults">
</iframe>
</div>

<div class="header">
  <div class="summary">
<a href="#pub-methods">Public Member Functions</a> &#124;
<a href="classpcpp_1_1_win_pcap_live_device-members.html">List of all members</a>  </div>
  <div class="headertitle">
<div class="title">pcpp::WinPcapLiveDevice Class Reference</div>  </div>
</div><!--header-->
<div class="contents">

<p><code>#include &lt;<a class="el" href="_win_pcap_live_device_8h_source.html">WinPcapLiveDevice.h</a>&gt;</code></p>
<div class="dynheader">
Inheritance diagram for pcpp::WinPcapLiveDevice:</div>
<div class="dyncontent">
 <div class="center">
  <img src="classpcpp_1_1_win_pcap_live_device.png" usemap="#pcpp::WinPcapLiveDevice_map" alt=""/>
  <map id="pcpp::WinPcapLiveDevice_map" name="pcpp::WinPcapLiveDevice_map">
<area href="classpcpp_1_1_pcap_live_device.html" alt="pcpp::PcapLiveDevice" shape="rect" coords="85,112,245,136"/>
<area href="classpcpp_1_1_i_pcap_device.html" alt="pcpp::IPcapDevice" shape="rect" coords="85,56,245,80"/>
<area href="classpcpp_1_1_i_device.html" alt="pcpp::IDevice" shape="rect" coords="0,0,160,24"/>
<area href="classpcpp_1_1_i_filterable_device.html" alt="pcpp::IFilterableDevice" shape="rect" coords="170,0,330,24"/>
</map>
 </div></div>
<table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="pub-methods"></a>
Public Member Functions</h2></td></tr>
<tr class="memitem:a86b56db9d815fc8c6017c9a1232554ed"><td class="memItemLeft" align="right" valign="top">virtual <a class="el" href="classpcpp_1_1_pcap_live_device.html#a0e343585711ee4e02d4b9507467135ab">LiveDeviceType</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classpcpp_1_1_win_pcap_live_device.html#a86b56db9d815fc8c6017c9a1232554ed">getDeviceType</a> () const</td></tr>
<tr class="separator:a86b56db9d815fc8c6017c9a1232554ed"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:adc89b5d18a2a00f078d339189d2f7c62"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classpcpp_1_1_win_pcap_live_device.html#adc89b5d18a2a00f078d339189d2f7c62">startCapture</a> (<a class="el" href="namespacepcpp.html#aa07524ba3fd4932968d2c302a936ae10">OnPacketArrivesCallback</a> onPacketArrives, void *onPacketArrivesUserCookie, int intervalInSecondsToUpdateStats, <a class="el" href="namespacepcpp.html#a7bf335eaca5d498401aa85d012070298">OnStatsUpdateCallback</a> onStatsUpdate, void *onStatsUpdateUserCookie)</td></tr>
<tr class="separator:adc89b5d18a2a00f078d339189d2f7c62"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a70126c098779937e5ce88360966c7aa1"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classpcpp_1_1_win_pcap_live_device.html#a70126c098779937e5ce88360966c7aa1">startCapture</a> (int intervalInSecondsToUpdateStats, <a class="el" href="namespacepcpp.html#a7bf335eaca5d498401aa85d012070298">OnStatsUpdateCallback</a> onStatsUpdate, void *onStatsUpdateUserCookie)</td></tr>
<tr class="separator:a70126c098779937e5ce88360966c7aa1"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a74824694b8f72f687dec10557a196675"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classpcpp_1_1_win_pcap_live_device.html#a74824694b8f72f687dec10557a196675">startCapture</a> (<a class="el" href="namespacepcpp.html#a4c0775fb93a0867d2afa7992d55957f0">RawPacketVector</a> &amp;capturedPacketsVector)</td></tr>
<tr class="separator:a74824694b8f72f687dec10557a196675"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aebff78da9d57c6ec9046de32746943bd"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classpcpp_1_1_win_pcap_live_device.html#aebff78da9d57c6ec9046de32746943bd">setMinAmountOfDataToCopyFromKernelToApplication</a> (int size)</td></tr>
<tr class="separator:aebff78da9d57c6ec9046de32746943bd"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8e2487bad421ea945119a872c346c595"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classpcpp_1_1_win_pcap_live_device.html#a8e2487bad421ea945119a872c346c595">getMinAmountOfDataToCopyFromKernelToApplication</a> () const</td></tr>
<tr class="separator:a8e2487bad421ea945119a872c346c595"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="inherit_header pub_methods_classpcpp_1_1_pcap_live_device"><td colspan="2" onclick="javascript:toggleInherit('pub_methods_classpcpp_1_1_pcap_live_device')"><img src="closed.png" alt="-"/>&#160;Public Member Functions inherited from <a class="el" href="classpcpp_1_1_pcap_live_device.html">pcpp::PcapLiveDevice</a></td></tr>
<tr class="memitem:a0172bbe45fb66f4722bf2bd4847c91fe inherit pub_methods_classpcpp_1_1_pcap_live_device"><td class="memItemLeft" align="right" valign="top">virtual&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classpcpp_1_1_pcap_live_device.html#a0172bbe45fb66f4722bf2bd4847c91fe">~PcapLiveDevice</a> ()</td></tr>
<tr class="separator:a0172bbe45fb66f4722bf2bd4847c91fe inherit pub_methods_classpcpp_1_1_pcap_live_device"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8b4bf1bc2bed7dfcbadd30ace0bc84bf inherit pub_methods_classpcpp_1_1_pcap_live_device"><td class="memItemLeft" align="right" valign="top">std::string&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classpcpp_1_1_pcap_live_device.html#a8b4bf1bc2bed7dfcbadd30ace0bc84bf">getName</a> () const</td></tr>
<tr class="separator:a8b4bf1bc2bed7dfcbadd30ace0bc84bf inherit pub_methods_classpcpp_1_1_pcap_live_device"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a54ee9e8c709de885bdb738844fca76b3 inherit pub_methods_classpcpp_1_1_pcap_live_device"><td class="memItemLeft" align="right" valign="top">std::string&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classpcpp_1_1_pcap_live_device.html#a54ee9e8c709de885bdb738844fca76b3">getDesc</a> () const</td></tr>
<tr class="separator:a54ee9e8c709de885bdb738844fca76b3 inherit pub_methods_classpcpp_1_1_pcap_live_device"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:acafca8ced5f590d537f1aed6fc94fcfe inherit pub_methods_classpcpp_1_1_pcap_live_device"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classpcpp_1_1_pcap_live_device.html#acafca8ced5f590d537f1aed6fc94fcfe">getLoopback</a> () const</td></tr>
<tr class="separator:acafca8ced5f590d537f1aed6fc94fcfe inherit pub_methods_classpcpp_1_1_pcap_live_device"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2eeadb33b0e5097213752a76d1e71ba7 inherit pub_methods_classpcpp_1_1_pcap_live_device"><td class="memItemLeft" align="right" valign="top">virtual uint32_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classpcpp_1_1_pcap_live_device.html#a2eeadb33b0e5097213752a76d1e71ba7">getMtu</a> () const</td></tr>
<tr class="separator:a2eeadb33b0e5097213752a76d1e71ba7 inherit pub_methods_classpcpp_1_1_pcap_live_device"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab80a7d9e829f0b0a4c7eddeb746a69be inherit pub_methods_classpcpp_1_1_pcap_live_device"><td class="memItemLeft" align="right" valign="top">virtual <a class="el" href="namespacepcpp.html#ab3f43dd3ccd8c93acac8b67909be02be">LinkLayerType</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classpcpp_1_1_pcap_live_device.html#ab80a7d9e829f0b0a4c7eddeb746a69be">getLinkType</a> () const</td></tr>
<tr class="separator:ab80a7d9e829f0b0a4c7eddeb746a69be inherit pub_methods_classpcpp_1_1_pcap_live_device"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a688940ed03c33b88fec2f297b7efe5a8 inherit pub_methods_classpcpp_1_1_pcap_live_device"><td class="memItemLeft" align="right" valign="top">const std::vector&lt; pcap_addr_t &gt; &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classpcpp_1_1_pcap_live_device.html#a688940ed03c33b88fec2f297b7efe5a8">getAddresses</a> () const</td></tr>
<tr class="separator:a688940ed03c33b88fec2f297b7efe5a8 inherit pub_methods_classpcpp_1_1_pcap_live_device"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4bc13ec8552ffbf5ae2fe281c4d0905b inherit pub_methods_classpcpp_1_1_pcap_live_device"><td class="memItemLeft" align="right" valign="top">virtual <a class="el" href="classpcpp_1_1_mac_address.html">MacAddress</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classpcpp_1_1_pcap_live_device.html#a4bc13ec8552ffbf5ae2fe281c4d0905b">getMacAddress</a> () const</td></tr>
<tr class="separator:a4bc13ec8552ffbf5ae2fe281c4d0905b inherit pub_methods_classpcpp_1_1_pcap_live_device"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9a3915b20de33f61dd40e434688fa63c inherit pub_methods_classpcpp_1_1_pcap_live_device"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classpcpp_1_1_i_pv4_address.html">IPv4Address</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classpcpp_1_1_pcap_live_device.html#a9a3915b20de33f61dd40e434688fa63c">getIPv4Address</a> () const</td></tr>
<tr class="separator:a9a3915b20de33f61dd40e434688fa63c inherit pub_methods_classpcpp_1_1_pcap_live_device"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a53a12fdc4a19fb23acea4c0ed11c4cfd inherit pub_methods_classpcpp_1_1_pcap_live_device"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classpcpp_1_1_i_pv4_address.html">IPv4Address</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classpcpp_1_1_pcap_live_device.html#a53a12fdc4a19fb23acea4c0ed11c4cfd">getDefaultGateway</a> () const</td></tr>
<tr class="separator:a53a12fdc4a19fb23acea4c0ed11c4cfd inherit pub_methods_classpcpp_1_1_pcap_live_device"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6b173d2702c2e33c05eec8f5676affd8 inherit pub_methods_classpcpp_1_1_pcap_live_device"><td class="memItemLeft" align="right" valign="top">const std::vector&lt; <a class="el" href="classpcpp_1_1_i_pv4_address.html">IPv4Address</a> &gt; &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classpcpp_1_1_pcap_live_device.html#a6b173d2702c2e33c05eec8f5676affd8">getDnsServers</a> () const</td></tr>
<tr class="separator:a6b173d2702c2e33c05eec8f5676affd8 inherit pub_methods_classpcpp_1_1_pcap_live_device"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a349b001c38b0f1e43a1691fedbd1b0cc inherit pub_methods_classpcpp_1_1_pcap_live_device"><td class="memItemLeft" align="right" valign="top">virtual bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classpcpp_1_1_pcap_live_device.html#a349b001c38b0f1e43a1691fedbd1b0cc">startCapture</a> (<a class="el" href="namespacepcpp.html#aa07524ba3fd4932968d2c302a936ae10">OnPacketArrivesCallback</a> onPacketArrives, void *onPacketArrivesUserCookie)</td></tr>
<tr class="separator:a349b001c38b0f1e43a1691fedbd1b0cc inherit pub_methods_classpcpp_1_1_pcap_live_device"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae479987f8faf52328061e18af2addcc5 inherit pub_methods_classpcpp_1_1_pcap_live_device"><td class="memItemLeft" align="right" valign="top">virtual int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classpcpp_1_1_pcap_live_device.html#ae479987f8faf52328061e18af2addcc5">startCaptureBlockingMode</a> (<a class="el" href="namespacepcpp.html#a1fb7ed19d0cb6b09ab2b1d0570b64cb4">OnPacketArrivesStopBlocking</a> onPacketArrives, void *userCookie, int timeout)</td></tr>
<tr class="separator:ae479987f8faf52328061e18af2addcc5 inherit pub_methods_classpcpp_1_1_pcap_live_device"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a818da3e11e0c953385badf6233ee0f43 inherit pub_methods_classpcpp_1_1_pcap_live_device"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classpcpp_1_1_pcap_live_device.html#a818da3e11e0c953385badf6233ee0f43">stopCapture</a> ()</td></tr>
<tr class="separator:a818da3e11e0c953385badf6233ee0f43 inherit pub_methods_classpcpp_1_1_pcap_live_device"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a058f8bc527935d97bbd044614ab93473 inherit pub_methods_classpcpp_1_1_pcap_live_device"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classpcpp_1_1_pcap_live_device.html#a058f8bc527935d97bbd044614ab93473">captureActive</a> ()</td></tr>
<tr class="separator:a058f8bc527935d97bbd044614ab93473 inherit pub_methods_classpcpp_1_1_pcap_live_device"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6a4073105d21336a4f9539a8302d47cb inherit pub_methods_classpcpp_1_1_pcap_live_device"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classpcpp_1_1_pcap_live_device.html#a6a4073105d21336a4f9539a8302d47cb">doMtuCheck</a> (int packetPayloadLength)</td></tr>
<tr class="separator:a6a4073105d21336a4f9539a8302d47cb inherit pub_methods_classpcpp_1_1_pcap_live_device"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2ec557886562d8af27bb7bce07016544 inherit pub_methods_classpcpp_1_1_pcap_live_device"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classpcpp_1_1_pcap_live_device.html#a2ec557886562d8af27bb7bce07016544">sendPacket</a> (<a class="el" href="classpcpp_1_1_raw_packet.html">RawPacket</a> const &amp;rawPacket, bool checkMtu=false)</td></tr>
<tr class="separator:a2ec557886562d8af27bb7bce07016544 inherit pub_methods_classpcpp_1_1_pcap_live_device"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4e5b87c1864ee727e12bb246b071c964 inherit pub_methods_classpcpp_1_1_pcap_live_device"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classpcpp_1_1_pcap_live_device.html#a4e5b87c1864ee727e12bb246b071c964">sendPacket</a> (const uint8_t *packetData, int packetDataLength, int packetPayloadLength)</td></tr>
<tr class="separator:a4e5b87c1864ee727e12bb246b071c964 inherit pub_methods_classpcpp_1_1_pcap_live_device"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a62c57a5a0fd0427188e4c89ac87f12d8 inherit pub_methods_classpcpp_1_1_pcap_live_device"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classpcpp_1_1_pcap_live_device.html#a62c57a5a0fd0427188e4c89ac87f12d8">sendPacket</a> (const uint8_t *packetData, int packetDataLength, bool checkMtu=false, <a class="el" href="namespacepcpp.html#ab3f43dd3ccd8c93acac8b67909be02be">pcpp::LinkLayerType</a> linkType=<a class="el" href="namespacepcpp.html#ab3f43dd3ccd8c93acac8b67909be02bea4a7bd3283e7f9b30aa9e71e7807de215">pcpp::LINKTYPE_ETHERNET</a>)</td></tr>
<tr class="separator:a62c57a5a0fd0427188e4c89ac87f12d8 inherit pub_methods_classpcpp_1_1_pcap_live_device"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9d8a41394806dd5e5245046908f60f16 inherit pub_methods_classpcpp_1_1_pcap_live_device"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classpcpp_1_1_pcap_live_device.html#a9d8a41394806dd5e5245046908f60f16">sendPacket</a> (<a class="el" href="classpcpp_1_1_packet.html">Packet</a> *packet, bool checkMtu=true)</td></tr>
<tr class="separator:a9d8a41394806dd5e5245046908f60f16 inherit pub_methods_classpcpp_1_1_pcap_live_device"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa11efe575402d9e06624376d87caf4fb inherit pub_methods_classpcpp_1_1_pcap_live_device"><td class="memItemLeft" align="right" valign="top">virtual int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classpcpp_1_1_pcap_live_device.html#aa11efe575402d9e06624376d87caf4fb">sendPackets</a> (<a class="el" href="classpcpp_1_1_raw_packet.html">RawPacket</a> *rawPacketsArr, int arrLength, bool checkMtu=false)</td></tr>
<tr class="separator:aa11efe575402d9e06624376d87caf4fb inherit pub_methods_classpcpp_1_1_pcap_live_device"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a71eb799bb039b9b4b182958bf5fdf563 inherit pub_methods_classpcpp_1_1_pcap_live_device"><td class="memItemLeft" align="right" valign="top">virtual int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classpcpp_1_1_pcap_live_device.html#a71eb799bb039b9b4b182958bf5fdf563">sendPackets</a> (<a class="el" href="classpcpp_1_1_packet.html">Packet</a> **packetsArr, int arrLength, bool checkMtu=true)</td></tr>
<tr class="separator:a71eb799bb039b9b4b182958bf5fdf563 inherit pub_methods_classpcpp_1_1_pcap_live_device"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9fb54c1f769a409743c6710f02b4de56 inherit pub_methods_classpcpp_1_1_pcap_live_device"><td class="memItemLeft" align="right" valign="top">virtual int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classpcpp_1_1_pcap_live_device.html#a9fb54c1f769a409743c6710f02b4de56">sendPackets</a> (const <a class="el" href="namespacepcpp.html#a4c0775fb93a0867d2afa7992d55957f0">RawPacketVector</a> &amp;rawPackets, bool checkMtu=false)</td></tr>
<tr class="separator:a9fb54c1f769a409743c6710f02b4de56 inherit pub_methods_classpcpp_1_1_pcap_live_device"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a281f2cd6062791c68ecdd82384f751f8 inherit pub_methods_classpcpp_1_1_pcap_live_device"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classpcpp_1_1_pcap_live_device.html#a281f2cd6062791c68ecdd82384f751f8">open</a> ()</td></tr>
<tr class="separator:a281f2cd6062791c68ecdd82384f751f8 inherit pub_methods_classpcpp_1_1_pcap_live_device"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3f58e22a71cbed9109ae75bd1759e8ed inherit pub_methods_classpcpp_1_1_pcap_live_device"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classpcpp_1_1_pcap_live_device.html#a3f58e22a71cbed9109ae75bd1759e8ed">open</a> (const <a class="el" href="structpcpp_1_1_pcap_live_device_1_1_device_configuration.html">DeviceConfiguration</a> &amp;config)</td></tr>
<tr class="separator:a3f58e22a71cbed9109ae75bd1759e8ed inherit pub_methods_classpcpp_1_1_pcap_live_device"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad7ccb5eac1b23651e7b157b628435528 inherit pub_methods_classpcpp_1_1_pcap_live_device"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classpcpp_1_1_pcap_live_device.html#ad7ccb5eac1b23651e7b157b628435528">close</a> ()</td></tr>
<tr class="separator:ad7ccb5eac1b23651e7b157b628435528 inherit pub_methods_classpcpp_1_1_pcap_live_device"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a81fc7607e3ac31e87df37d15c159cca0 inherit pub_methods_classpcpp_1_1_pcap_live_device"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classpcpp_1_1_pcap_live_device.html">PcapLiveDevice</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classpcpp_1_1_pcap_live_device.html#a81fc7607e3ac31e87df37d15c159cca0">clone</a> ()</td></tr>
<tr class="separator:a81fc7607e3ac31e87df37d15c159cca0 inherit pub_methods_classpcpp_1_1_pcap_live_device"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a63c26fadf6e36c99608f500f67d60f29 inherit pub_methods_classpcpp_1_1_pcap_live_device"><td class="memItemLeft" align="right" valign="top">virtual void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classpcpp_1_1_pcap_live_device.html#a63c26fadf6e36c99608f500f67d60f29">getStatistics</a> (<a class="el" href="structpcpp_1_1_i_pcap_device_1_1_pcap_stats.html">IPcapDevice::PcapStats</a> &amp;stats) const</td></tr>
<tr class="separator:a63c26fadf6e36c99608f500f67d60f29 inherit pub_methods_classpcpp_1_1_pcap_live_device"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="inherit_header pub_methods_classpcpp_1_1_i_pcap_device"><td colspan="2" onclick="javascript:toggleInherit('pub_methods_classpcpp_1_1_i_pcap_device')"><img src="closed.png" alt="-"/>&#160;Public Member Functions inherited from <a class="el" href="classpcpp_1_1_i_pcap_device.html">pcpp::IPcapDevice</a></td></tr>
<tr class="memitem:a134f061d7883abbdb256abd48d53e66c inherit pub_methods_classpcpp_1_1_i_pcap_device"><td class="memItemLeft" align="right" valign="top">virtual bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classpcpp_1_1_i_pcap_device.html#a134f061d7883abbdb256abd48d53e66c">setFilter</a> (std::string filterAsString)</td></tr>
<tr class="separator:a134f061d7883abbdb256abd48d53e66c inherit pub_methods_classpcpp_1_1_i_pcap_device"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8ca7eb3d99231a8cfd9d68cde0b5067c inherit pub_methods_classpcpp_1_1_i_pcap_device"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classpcpp_1_1_i_pcap_device.html#a8ca7eb3d99231a8cfd9d68cde0b5067c">clearFilter</a> ()</td></tr>
<tr class="separator:a8ca7eb3d99231a8cfd9d68cde0b5067c inherit pub_methods_classpcpp_1_1_i_pcap_device"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="inherit_header pub_methods_classpcpp_1_1_i_device"><td colspan="2" onclick="javascript:toggleInherit('pub_methods_classpcpp_1_1_i_device')"><img src="closed.png" alt="-"/>&#160;Public Member Functions inherited from <a class="el" href="classpcpp_1_1_i_device.html">pcpp::IDevice</a></td></tr>
<tr class="memitem:a5b75e7491597f271b8f29847bec2ee99 inherit pub_methods_classpcpp_1_1_i_device"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classpcpp_1_1_i_device.html#a5b75e7491597f271b8f29847bec2ee99">isOpened</a> ()</td></tr>
<tr class="separator:a5b75e7491597f271b8f29847bec2ee99 inherit pub_methods_classpcpp_1_1_i_device"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="inherit_header pub_methods_classpcpp_1_1_i_filterable_device"><td colspan="2" onclick="javascript:toggleInherit('pub_methods_classpcpp_1_1_i_filterable_device')"><img src="closed.png" alt="-"/>&#160;Public Member Functions inherited from <a class="el" href="classpcpp_1_1_i_filterable_device.html">pcpp::IFilterableDevice</a></td></tr>
<tr class="memitem:af334503822ac7076373c64109f3e6d64 inherit pub_methods_classpcpp_1_1_i_filterable_device"><td class="memItemLeft" align="right" valign="top">virtual bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classpcpp_1_1_i_filterable_device.html#af334503822ac7076373c64109f3e6d64">setFilter</a> (<a class="el" href="classpcpp_1_1_general_filter.html">GeneralFilter</a> &amp;filter)</td></tr>
<tr class="separator:af334503822ac7076373c64109f3e6d64 inherit pub_methods_classpcpp_1_1_i_filterable_device"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="inherited"></a>
Additional Inherited Members</h2></td></tr>
<tr class="inherit_header pub_types_classpcpp_1_1_pcap_live_device"><td colspan="2" onclick="javascript:toggleInherit('pub_types_classpcpp_1_1_pcap_live_device')"><img src="closed.png" alt="-"/>&#160;Public Types inherited from <a class="el" href="classpcpp_1_1_pcap_live_device.html">pcpp::PcapLiveDevice</a></td></tr>
<tr class="memitem:a0e343585711ee4e02d4b9507467135ab inherit pub_types_classpcpp_1_1_pcap_live_device"><td class="memItemLeft" align="right" valign="top">enum &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classpcpp_1_1_pcap_live_device.html#a0e343585711ee4e02d4b9507467135ab">LiveDeviceType</a> { <a class="el" href="classpcpp_1_1_pcap_live_device.html#a0e343585711ee4e02d4b9507467135aba975b2663c8a8bcc495a71af5e80f8652">LibPcapDevice</a>, 
<a class="el" href="classpcpp_1_1_pcap_live_device.html#a0e343585711ee4e02d4b9507467135aba0c8c0011ab41d3aeee8e8f1c29fd07b6">WinPcapDevice</a>, 
<a class="el" href="classpcpp_1_1_pcap_live_device.html#a0e343585711ee4e02d4b9507467135aba47692cc2f098676c70ad0505059f581c">RemoteDevice</a>
 }</td></tr>
<tr class="separator:a0e343585711ee4e02d4b9507467135ab inherit pub_types_classpcpp_1_1_pcap_live_device"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2381e7f053285090f0f9620bcbd8f0f3 inherit pub_types_classpcpp_1_1_pcap_live_device"><td class="memItemLeft" align="right" valign="top">enum &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classpcpp_1_1_pcap_live_device.html#a2381e7f053285090f0f9620bcbd8f0f3">DeviceMode</a> { <a class="el" href="classpcpp_1_1_pcap_live_device.html#a2381e7f053285090f0f9620bcbd8f0f3ad57df3ce2415ba6f804539bb268aecdf">Normal</a> = 0, 
<a class="el" href="classpcpp_1_1_pcap_live_device.html#a2381e7f053285090f0f9620bcbd8f0f3af1c5bb543295a735a99cc9f88ac67bca">Promiscuous</a> = 1
 }</td></tr>
<tr class="separator:a2381e7f053285090f0f9620bcbd8f0f3 inherit pub_types_classpcpp_1_1_pcap_live_device"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a00efdbd7aca92b696dd585cf3301add5 inherit pub_types_classpcpp_1_1_pcap_live_device"><td class="memItemLeft" align="right" valign="top">enum &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classpcpp_1_1_pcap_live_device.html#a00efdbd7aca92b696dd585cf3301add5">PcapDirection</a> { <a class="el" href="classpcpp_1_1_pcap_live_device.html#a00efdbd7aca92b696dd585cf3301add5acf27653531bcc39386aecacd44416052">PCPP_INOUT</a> = 0, 
<a class="el" href="classpcpp_1_1_pcap_live_device.html#a00efdbd7aca92b696dd585cf3301add5a9da5011f04f2f9cf302d144d311f27ab">PCPP_IN</a>, 
<a class="el" href="classpcpp_1_1_pcap_live_device.html#a00efdbd7aca92b696dd585cf3301add5aa09daf455022a9dab650fdcb2171ba1c">PCPP_OUT</a>
 }</td></tr>
<tr class="separator:a00efdbd7aca92b696dd585cf3301add5 inherit pub_types_classpcpp_1_1_pcap_live_device"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="inherit_header pub_static_methods_classpcpp_1_1_i_pcap_device"><td colspan="2" onclick="javascript:toggleInherit('pub_static_methods_classpcpp_1_1_i_pcap_device')"><img src="closed.png" alt="-"/>&#160;Static Public Member Functions inherited from <a class="el" href="classpcpp_1_1_i_pcap_device.html">pcpp::IPcapDevice</a></td></tr>
<tr class="memitem:ac9e91fa6b66ced9a92d09068712ccffc inherit pub_static_methods_classpcpp_1_1_i_pcap_device"><td class="memItemLeft" align="right" valign="top">static std::string&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classpcpp_1_1_i_pcap_device.html#ac9e91fa6b66ced9a92d09068712ccffc">getPcapLibVersionInfo</a> ()</td></tr>
<tr class="separator:ac9e91fa6b66ced9a92d09068712ccffc inherit pub_static_methods_classpcpp_1_1_i_pcap_device"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9095bdfe0c8e79b656b2651a721a2ea2 inherit pub_static_methods_classpcpp_1_1_i_pcap_device"><td class="memItemLeft" align="right" valign="top">static bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classpcpp_1_1_i_pcap_device.html#a9095bdfe0c8e79b656b2651a721a2ea2">matchPacketWithFilter</a> (<a class="el" href="classpcpp_1_1_general_filter.html">GeneralFilter</a> &amp;filter, <a class="el" href="classpcpp_1_1_raw_packet.html">RawPacket</a> *rawPacket)</td></tr>
<tr class="separator:a9095bdfe0c8e79b656b2651a721a2ea2 inherit pub_static_methods_classpcpp_1_1_i_pcap_device"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table>
<a name="details" id="details"></a><h2 class="groupheader">Detailed Description</h2>
<div class="textblock"><p>A class that wraps a Windows network interface (each of the interfaces listed in ipconfig). This class is almost similar in its capabilities to <a class="el" href="classpcpp_1_1_pcap_live_device.html">PcapLiveDevice</a> (its parent class) with some small changes that mainly result from differences between libpcap and WinPcap/Npcap. Please see the reference for <a class="el" href="classpcpp_1_1_pcap_live_device.html">PcapLiveDevice</a> for more details </p>
</div><h2 class="groupheader">Member Function Documentation</h2>
<a id="a86b56db9d815fc8c6017c9a1232554ed"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a86b56db9d815fc8c6017c9a1232554ed">&#9670;&nbsp;</a></span>getDeviceType()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual <a class="el" href="classpcpp_1_1_pcap_live_device.html#a0e343585711ee4e02d4b9507467135ab">LiveDeviceType</a> pcpp::WinPcapLiveDevice::getDeviceType </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<dl class="section return"><dt>Returns</dt><dd>The type of the device (libPcap, WinPcap/Npcap or a remote device) </dd></dl>

<p>Reimplemented from <a class="el" href="classpcpp_1_1_pcap_live_device.html#a76bd1af9e2079c71a790834e2f14baa7">pcpp::PcapLiveDevice</a>.</p>

</div>
</div>
<a id="a8e2487bad421ea945119a872c346c595"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a8e2487bad421ea945119a872c346c595">&#9670;&nbsp;</a></span>getMinAmountOfDataToCopyFromKernelToApplication()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">int pcpp::WinPcapLiveDevice::getMinAmountOfDataToCopyFromKernelToApplication </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<dl class="section return"><dt>Returns</dt><dd>The current amount of data in the kernel buffer that causes a read from the application to return (see also <a class="el" href="classpcpp_1_1_win_pcap_live_device.html#aebff78da9d57c6ec9046de32746943bd">setMinAmountOfDataToCopyFromKernelToApplication()</a>) </dd></dl>

</div>
</div>
<a id="aebff78da9d57c6ec9046de32746943bd"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aebff78da9d57c6ec9046de32746943bd">&#9670;&nbsp;</a></span>setMinAmountOfDataToCopyFromKernelToApplication()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool pcpp::WinPcapLiveDevice::setMinAmountOfDataToCopyFromKernelToApplication </td>
          <td>(</td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>size</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>WinPcap/Npcap have a feature (that doesn't exist in libpcap) to change the minimum amount of data in the kernel buffer that causes a read from the application to return (unless the timeout expires). Please see documentation for pcap_setmintocopy for more info. This method enables the user to change this size. Note the device must be open for this method to work </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">size</td><td>The size to set in bytes </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>True if set succeeded, false if the device is closed or if pcap_setmintocopy failed </dd></dl>

</div>
</div>
<a id="adc89b5d18a2a00f078d339189d2f7c62"></a>
<h2 class="memtitle"><span class="permalink"><a href="#adc89b5d18a2a00f078d339189d2f7c62">&#9670;&nbsp;</a></span>startCapture() <span class="overload">[1/3]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool pcpp::WinPcapLiveDevice::startCapture </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="namespacepcpp.html#aa07524ba3fd4932968d2c302a936ae10">OnPacketArrivesCallback</a>&#160;</td>
          <td class="paramname"><em>onPacketArrives</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">void *&#160;</td>
          <td class="paramname"><em>onPacketArrivesUserCookie</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>intervalInSecondsToUpdateStats</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="namespacepcpp.html#a7bf335eaca5d498401aa85d012070298">OnStatsUpdateCallback</a>&#160;</td>
          <td class="paramname"><em>onStatsUpdate</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">void *&#160;</td>
          <td class="paramname"><em>onStatsUpdateUserCookie</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Start capturing packets on this network interface (device) with periodic stats collection. Each time a packet is captured the onPacketArrives callback is called. In addition, each intervalInSecondsToUpdateStats seconds stats are collected from the device and the onStatsUpdate callback is called. Both the capture and periodic stats collection are done on new threads created by this method, each on a different thread, meaning all callback calls are done in threads other than the caller thread. Capture process and stats collection will stop and threads will be terminated when calling <a class="el" href="classpcpp_1_1_pcap_live_device.html#a818da3e11e0c953385badf6233ee0f43">stopCapture()</a>. This method must be called after the device is opened (i.e the <a class="el" href="classpcpp_1_1_pcap_live_device.html#a281f2cd6062791c68ecdd82384f751f8">open()</a> method was called), otherwise an error will be returned. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">onPacketArrives</td><td>A callback that is called each time a packet is captured </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">onPacketArrivesUserCookie</td><td>A pointer to a user provided object. This object will be transferred to the onPacketArrives callback each time it is called. This cookie is very useful for transferring objects that give context to the capture callback, for example: objects that counts packets, manages flow state or manages the application state according to the packet that was captured </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">intervalInSecondsToUpdateStats</td><td>The interval in seconds to activate periodic stats collection </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">onStatsUpdate</td><td>A callback that will be called each time intervalInSecondsToUpdateStats expires and stats are collected. This callback will contain the collected stats </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">onStatsUpdateUserCookie</td><td>A pointer to a user provided object. This object will be transferred to the onStatsUpdate callback each time it is called </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>True if capture started successfully, false if (relevant log error is printed in any case):<ul>
<li>Capture is already running</li>
<li>Device is not opened</li>
<li>Capture thread could not be created</li>
<li>Stats collection thread could not be created </li>
</ul>
</dd></dl>

<p>Reimplemented from <a class="el" href="classpcpp_1_1_pcap_live_device.html#a78306fe44879e457df4043a117f6863a">pcpp::PcapLiveDevice</a>.</p>

</div>
</div>
<a id="a70126c098779937e5ce88360966c7aa1"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a70126c098779937e5ce88360966c7aa1">&#9670;&nbsp;</a></span>startCapture() <span class="overload">[2/3]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool pcpp::WinPcapLiveDevice::startCapture </td>
          <td>(</td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>intervalInSecondsToUpdateStats</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="namespacepcpp.html#a7bf335eaca5d498401aa85d012070298">OnStatsUpdateCallback</a>&#160;</td>
          <td class="paramname"><em>onStatsUpdate</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">void *&#160;</td>
          <td class="paramname"><em>onStatsUpdateUserCookie</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Start capturing packets on this network interface (device) with periodic stats collection only. This means that packets arriving to the network interface aren't delivered to the user but only counted. Each intervalInSecondsToUpdateStats seconds stats are collected from the device and the onStatsUpdate callback is called with the updated counters. The periodic stats collection is done on a new thread created by this method, meaning all callback calls are done in threads other than the caller thread. Stats collection will stop and threads will be terminated when calling <a class="el" href="classpcpp_1_1_pcap_live_device.html#a818da3e11e0c953385badf6233ee0f43">stopCapture()</a>. This method must be called after the device is opened (i.e the <a class="el" href="classpcpp_1_1_pcap_live_device.html#a281f2cd6062791c68ecdd82384f751f8">open()</a> method was called), otherwise an error will be returned. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">intervalInSecondsToUpdateStats</td><td>The interval in seconds to activate periodic stats collection </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">onStatsUpdate</td><td>A callback that will be called each time intervalInSecondsToUpdateStats expires and stats are collected. This callback will contain the collected stats </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">onStatsUpdateUserCookie</td><td>A pointer to a user provided object. This object will be transferred to the onStatsUpdate callback each time it is called </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>True if capture started successfully, false if (relevant log error is printed in any case):<ul>
<li>Capture is already running</li>
<li>Device is not opened</li>
<li>Stats collection thread could not be created </li>
</ul>
</dd></dl>

<p>Reimplemented from <a class="el" href="classpcpp_1_1_pcap_live_device.html#a2933139d284d7c167283982ec8b56559">pcpp::PcapLiveDevice</a>.</p>

</div>
</div>
<a id="a74824694b8f72f687dec10557a196675"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a74824694b8f72f687dec10557a196675">&#9670;&nbsp;</a></span>startCapture() <span class="overload">[3/3]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool pcpp::WinPcapLiveDevice::startCapture </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="namespacepcpp.html#a4c0775fb93a0867d2afa7992d55957f0">RawPacketVector</a> &amp;&#160;</td>
          <td class="paramname"><em>capturedPacketsVector</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Start capturing packets on this network interface (device). All captured packets are added to capturedPacketsVector, so at the end of the capture (when calling <a class="el" href="classpcpp_1_1_pcap_live_device.html#a818da3e11e0c953385badf6233ee0f43">stopCapture()</a>) this vector contains pointers to all captured packets in the form of <a class="el" href="classpcpp_1_1_raw_packet.html">RawPacket</a>. The capture is done on a new thread created by this method, meaning capturedPacketsVector is updated from another thread other than the caller thread (so user should avoid changing or iterating this vector while capture is on). Capture process will stop and this capture thread will be terminated when calling <a class="el" href="classpcpp_1_1_pcap_live_device.html#a818da3e11e0c953385badf6233ee0f43">stopCapture()</a>. This method must be called after the device is opened (i.e the <a class="el" href="classpcpp_1_1_pcap_live_device.html#a281f2cd6062791c68ecdd82384f751f8">open()</a> method was called), otherwise an error will be returned. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">capturedPacketsVector</td><td>A reference to a RawPacketVector, meaning a vector of pointer to <a class="el" href="classpcpp_1_1_raw_packet.html">RawPacket</a> objects </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>True if capture started successfully, false if (relevant log error is printed in any case):<ul>
<li>Capture is already running</li>
<li>Device is not opened</li>
<li>Capture thread could not be created </li>
</ul>
</dd></dl>

<p>Reimplemented from <a class="el" href="classpcpp_1_1_pcap_live_device.html#a821bbac1ffad5a75c6a0be1ff362eb9f">pcpp::PcapLiveDevice</a>.</p>

</div>
</div>
</div><!-- contents -->
</div><!-- doc-content -->
<!-- start footer part -->
<div id="nav-path" class="navpath"><!-- id is needed for treeview function! -->
  <ul>
    <li class="navelem"><a class="el" href="namespacepcpp.html">pcpp</a></li><li class="navelem"><a class="el" href="classpcpp_1_1_win_pcap_live_device.html">WinPcapLiveDevice</a></li>
    <li class="footer">Generated on Sun May 8 2022 20:09:30 for PcapPlusPlus by
    <a href="http://www.doxygen.org/index.html">
    <img class="footer" src="doxygen.png" alt="doxygen"/></a> 1.8.13 </li>
  </ul>
</div>
</body>
</html>
