<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "https://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=9"/>
<meta name="generator" content="Doxygen 1.9.1"/>
<meta name="viewport" content="width=device-width, initial-scale=1"/>
<title>PcapPlusPlus: pcpp::PcapLiveDevice Class Reference</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<link href="navtree.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="resize.js"></script>
<script type="text/javascript" src="navtreedata.js"></script>
<script type="text/javascript" src="navtree.js"></script>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/searchdata.js"></script>
<script type="text/javascript" src="search/search.js"></script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
<link href="doxygen-mobile.css" rel="stylesheet" type="text/css"/>
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr style="height: 56px;">
  <td id="projectlogo"><img alt="Logo" src="logo_icon_large.ico"/></td>
  <td id="projectalign" style="padding-left: 0.5em;">
   <div id="projectname">PcapPlusPlus
   &#160;<span id="projectnumber">Next</span>
   </div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.9.1 -->
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:cf05388f2679ee054f2beb29a391d25f4e673ac3&amp;dn=gpl-2.0.txt GPL-v2 */
var searchBox = new SearchBox("searchBox", "search",false,'Search','.html');
/* @license-end */
</script>
<script type="text/javascript" src="menudata.js"></script>
<script type="text/javascript" src="menu.js"></script>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:cf05388f2679ee054f2beb29a391d25f4e673ac3&amp;dn=gpl-2.0.txt GPL-v2 */
$(function() {
  initMenu('',true,false,'search.php','Search');
  $(document).ready(function() { init_search(); });
});
/* @license-end */</script>
<div id="main-nav"></div>
</div><!-- top -->
<div id="side-nav" class="ui-resizable side-nav-resizable">
  <div id="nav-tree">
    <div id="nav-tree-contents">
      <div id="nav-sync" class="sync"></div>
    </div>
  </div>
  <div id="splitbar" style="-moz-user-select:none;" 
       class="ui-resizable-handle">
  </div>
</div>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:cf05388f2679ee054f2beb29a391d25f4e673ac3&amp;dn=gpl-2.0.txt GPL-v2 */
$(document).ready(function(){initNavTree('classpcpp_1_1_pcap_live_device.html',''); initResizable(); });
/* @license-end */
</script>
<div id="doc-content">
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
</div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<iframe src="javascript:void(0)" frameborder="0" 
        name="MSearchResults" id="MSearchResults">
</iframe>
</div>

<div class="header">
  <div class="summary">
<a href="#nested-classes">Classes</a> &#124;
<a href="#pub-types">Public Types</a> &#124;
<a href="#pub-methods">Public Member Functions</a> &#124;
<a href="#pro-methods">Protected Member Functions</a> &#124;
<a href="classpcpp_1_1_pcap_live_device-members.html">List of all members</a>  </div>
  <div class="headertitle">
<div class="title">pcpp::PcapLiveDevice Class Reference</div>  </div>
</div><!--header-->
<div class="contents">

<p><code>#include &lt;<a class="el" href="_pcap_live_device_8h_source.html">PcapLiveDevice.h</a>&gt;</code></p>
<div class="dynheader">
Inheritance diagram for pcpp::PcapLiveDevice:</div>
<div class="dyncontent">
 <div class="center">
  <img src="classpcpp_1_1_pcap_live_device.png" usemap="#pcpp::PcapLiveDevice_map" alt=""/>
  <map id="pcpp::PcapLiveDevice_map" name="pcpp::PcapLiveDevice_map">
<area href="classpcpp_1_1_i_pcap_device.html" alt="pcpp::IPcapDevice" shape="rect" coords="186,56,362,80"/>
<area href="classpcpp_1_1_i_device.html" alt="pcpp::IDevice" shape="rect" coords="0,0,176,24"/>
<area href="classpcpp_1_1_i_filterable_device.html" alt="pcpp::IFilterableDevice" shape="rect" coords="186,0,362,24"/>
<area href="classpcpp_1_1_i_pcap_statistics_provider.html" title="An interface for providing Pcap-based device statistics." alt="pcpp::IPcapStatisticsProvider" shape="rect" coords="372,0,548,24"/>
<area href="classpcpp_1_1_pcap_remote_device.html" alt="pcpp::PcapRemoteDevice" shape="rect" coords="93,168,269,192"/>
<area href="classpcpp_1_1_win_pcap_live_device.html" alt="pcpp::WinPcapLiveDevice" shape="rect" coords="279,168,455,192"/>
  </map>
</div></div>
<table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="nested-classes"></a>
Classes</h2></td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structpcpp_1_1_pcap_live_device_1_1_device_configuration.html">DeviceConfiguration</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structpcpp_1_1_pcap_live_device_1_1_device_interface_details.html">DeviceInterfaceDetails</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">A struct that contains all details of a network interface.  <a href="structpcpp_1_1_pcap_live_device_1_1_device_interface_details.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classpcpp_1_1_pcap_live_device_1_1_statistics_update_worker.html">StatisticsUpdateWorker</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">A worker thread that periodically calls the provided callback with updated statistics.  <a href="classpcpp_1_1_pcap_live_device_1_1_statistics_update_worker.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="pub-types"></a>
Public Types</h2></td></tr>
<tr class="memitem:a0e343585711ee4e02d4b9507467135ab"><td class="memItemLeft" align="right" valign="top">enum &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classpcpp_1_1_pcap_live_device.html#a0e343585711ee4e02d4b9507467135ab">LiveDeviceType</a> { <a class="el" href="classpcpp_1_1_pcap_live_device.html#a0e343585711ee4e02d4b9507467135aba975b2663c8a8bcc495a71af5e80f8652">LibPcapDevice</a>
, <a class="el" href="classpcpp_1_1_pcap_live_device.html#a0e343585711ee4e02d4b9507467135aba0c8c0011ab41d3aeee8e8f1c29fd07b6">WinPcapDevice</a>
, <a class="el" href="classpcpp_1_1_pcap_live_device.html#a0e343585711ee4e02d4b9507467135aba47692cc2f098676c70ad0505059f581c">RemoteDevice</a>
 }</td></tr>
<tr class="memdesc:a0e343585711ee4e02d4b9507467135ab"><td class="mdescLeft">&#160;</td><td class="mdescRight">The type of the live device.  <a href="classpcpp_1_1_pcap_live_device.html#a0e343585711ee4e02d4b9507467135ab">More...</a><br /></td></tr>
<tr class="separator:a0e343585711ee4e02d4b9507467135ab"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2381e7f053285090f0f9620bcbd8f0f3"><td class="memItemLeft" align="right" valign="top">enum &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classpcpp_1_1_pcap_live_device.html#a2381e7f053285090f0f9620bcbd8f0f3">DeviceMode</a> { <a class="el" href="classpcpp_1_1_pcap_live_device.html#a2381e7f053285090f0f9620bcbd8f0f3ad57df3ce2415ba6f804539bb268aecdf">Normal</a> = 0
, <a class="el" href="classpcpp_1_1_pcap_live_device.html#a2381e7f053285090f0f9620bcbd8f0f3af1c5bb543295a735a99cc9f88ac67bca">Promiscuous</a> = 1
 }</td></tr>
<tr class="memdesc:a2381e7f053285090f0f9620bcbd8f0f3"><td class="mdescLeft">&#160;</td><td class="mdescRight">Device capturing mode.  <a href="classpcpp_1_1_pcap_live_device.html#a2381e7f053285090f0f9620bcbd8f0f3">More...</a><br /></td></tr>
<tr class="separator:a2381e7f053285090f0f9620bcbd8f0f3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a00efdbd7aca92b696dd585cf3301add5"><td class="memItemLeft" align="right" valign="top">enum &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classpcpp_1_1_pcap_live_device.html#a00efdbd7aca92b696dd585cf3301add5">PcapDirection</a> { <a class="el" href="classpcpp_1_1_pcap_live_device.html#a00efdbd7aca92b696dd585cf3301add5acf27653531bcc39386aecacd44416052">PCPP_INOUT</a> = 0
, <a class="el" href="classpcpp_1_1_pcap_live_device.html#a00efdbd7aca92b696dd585cf3301add5a9da5011f04f2f9cf302d144d311f27ab">PCPP_IN</a>
, <a class="el" href="classpcpp_1_1_pcap_live_device.html#a00efdbd7aca92b696dd585cf3301add5aa09daf455022a9dab650fdcb2171ba1c">PCPP_OUT</a>
 }</td></tr>
<tr class="separator:a00efdbd7aca92b696dd585cf3301add5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac5b95d68aa486b7ac038096fe1b8d71e"><td class="memItemLeft" align="right" valign="top">enum class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classpcpp_1_1_pcap_live_device.html#ac5b95d68aa486b7ac038096fe1b8d71e">TimestampProvider</a> { <br />
&#160;&#160;<a class="el" href="classpcpp_1_1_pcap_live_device.html#ac5b95d68aa486b7ac038096fe1b8d71eac2ca16d048ec66e04bca283eab048ec2">Host</a> = 0
, <a class="el" href="classpcpp_1_1_pcap_live_device.html#ac5b95d68aa486b7ac038096fe1b8d71ea81a53679545718b26c514315c26db901">HostLowPrecision</a>
, <a class="el" href="classpcpp_1_1_pcap_live_device.html#ac5b95d68aa486b7ac038096fe1b8d71eaa0d6622487e925677aec54f04dd30ac9">HostHighPrecision</a>
, <a class="el" href="classpcpp_1_1_pcap_live_device.html#ac5b95d68aa486b7ac038096fe1b8d71ea8601c10b2797050a900697daac0c0001">Adapter</a>
, <br />
&#160;&#160;<a class="el" href="classpcpp_1_1_pcap_live_device.html#ac5b95d68aa486b7ac038096fe1b8d71ea18ac6b0e8fa6cc2bf36b556bdd3feb70">AdapterUnsynced</a>
, <a class="el" href="classpcpp_1_1_pcap_live_device.html#ac5b95d68aa486b7ac038096fe1b8d71eafd90a006b8288716dc2baebdfe845269">HostHighPrecisionUnsynced</a>
<br />
 }</td></tr>
<tr class="separator:ac5b95d68aa486b7ac038096fe1b8d71e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7b819cd593026da0e65274221f52db82"><td class="memItemLeft" align="right" valign="top">enum class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classpcpp_1_1_pcap_live_device.html#a7b819cd593026da0e65274221f52db82">TimestampPrecision</a> { <a class="el" href="classpcpp_1_1_pcap_live_device.html#a7b819cd593026da0e65274221f52db82a64068ed47d979c5efa036f027d656433">Microseconds</a> = 0
, <a class="el" href="classpcpp_1_1_pcap_live_device.html#a7b819cd593026da0e65274221f52db82afba00bdab687ce01136a86bac8bac578">Nanoseconds</a>
 }</td></tr>
<tr class="separator:a7b819cd593026da0e65274221f52db82"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="pub-methods"></a>
Public Member Functions</h2></td></tr>
<tr class="memitem:a841eda2bc4582ad8f71e68f140aca064"><td class="memItemLeft" align="right" valign="top"><a id="a841eda2bc4582ad8f71e68f140aca064"></a>
&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classpcpp_1_1_pcap_live_device.html#a841eda2bc4582ad8f71e68f140aca064">~PcapLiveDevice</a> () override</td></tr>
<tr class="memdesc:a841eda2bc4582ad8f71e68f140aca064"><td class="mdescLeft">&#160;</td><td class="mdescRight">A destructor for this class. <br /></td></tr>
<tr class="separator:a841eda2bc4582ad8f71e68f140aca064"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a76bd1af9e2079c71a790834e2f14baa7"><td class="memItemLeft" align="right" valign="top">virtual <a class="el" href="classpcpp_1_1_pcap_live_device.html#a0e343585711ee4e02d4b9507467135ab">LiveDeviceType</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classpcpp_1_1_pcap_live_device.html#a76bd1af9e2079c71a790834e2f14baa7">getDeviceType</a> () const</td></tr>
<tr class="separator:a76bd1af9e2079c71a790834e2f14baa7"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8b4bf1bc2bed7dfcbadd30ace0bc84bf"><td class="memItemLeft" align="right" valign="top">std::string&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classpcpp_1_1_pcap_live_device.html#a8b4bf1bc2bed7dfcbadd30ace0bc84bf">getName</a> () const</td></tr>
<tr class="separator:a8b4bf1bc2bed7dfcbadd30ace0bc84bf"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a54ee9e8c709de885bdb738844fca76b3"><td class="memItemLeft" align="right" valign="top">std::string&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classpcpp_1_1_pcap_live_device.html#a54ee9e8c709de885bdb738844fca76b3">getDesc</a> () const</td></tr>
<tr class="separator:a54ee9e8c709de885bdb738844fca76b3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:acafca8ced5f590d537f1aed6fc94fcfe"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classpcpp_1_1_pcap_live_device.html#acafca8ced5f590d537f1aed6fc94fcfe">getLoopback</a> () const</td></tr>
<tr class="separator:acafca8ced5f590d537f1aed6fc94fcfe"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2eeadb33b0e5097213752a76d1e71ba7"><td class="memItemLeft" align="right" valign="top">virtual uint32_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classpcpp_1_1_pcap_live_device.html#a2eeadb33b0e5097213752a76d1e71ba7">getMtu</a> () const</td></tr>
<tr class="separator:a2eeadb33b0e5097213752a76d1e71ba7"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab80a7d9e829f0b0a4c7eddeb746a69be"><td class="memItemLeft" align="right" valign="top">virtual <a class="el" href="namespacepcpp.html#ab3f43dd3ccd8c93acac8b67909be02be">LinkLayerType</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classpcpp_1_1_pcap_live_device.html#ab80a7d9e829f0b0a4c7eddeb746a69be">getLinkType</a> () const</td></tr>
<tr class="separator:ab80a7d9e829f0b0a4c7eddeb746a69be"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af2e91ef6742fdcbbf2f41dc35266c99d"><td class="memItemLeft" align="right" valign="top">std::vector&lt; <a class="el" href="classpcpp_1_1_i_p_address.html">IPAddress</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classpcpp_1_1_pcap_live_device.html#af2e91ef6742fdcbbf2f41dc35266c99d">getIPAddresses</a> () const</td></tr>
<tr class="separator:af2e91ef6742fdcbbf2f41dc35266c99d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4bc13ec8552ffbf5ae2fe281c4d0905b"><td class="memItemLeft" align="right" valign="top">virtual <a class="el" href="classpcpp_1_1_mac_address.html">MacAddress</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classpcpp_1_1_pcap_live_device.html#a4bc13ec8552ffbf5ae2fe281c4d0905b">getMacAddress</a> () const</td></tr>
<tr class="separator:a4bc13ec8552ffbf5ae2fe281c4d0905b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9a3915b20de33f61dd40e434688fa63c"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classpcpp_1_1_i_pv4_address.html">IPv4Address</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classpcpp_1_1_pcap_live_device.html#a9a3915b20de33f61dd40e434688fa63c">getIPv4Address</a> () const</td></tr>
<tr class="separator:a9a3915b20de33f61dd40e434688fa63c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a80e77bde8d290d33376ac8825c272534"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classpcpp_1_1_i_pv6_address.html">IPv6Address</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classpcpp_1_1_pcap_live_device.html#a80e77bde8d290d33376ac8825c272534">getIPv6Address</a> () const</td></tr>
<tr class="separator:a80e77bde8d290d33376ac8825c272534"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a53a12fdc4a19fb23acea4c0ed11c4cfd"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classpcpp_1_1_i_pv4_address.html">IPv4Address</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classpcpp_1_1_pcap_live_device.html#a53a12fdc4a19fb23acea4c0ed11c4cfd">getDefaultGateway</a> () const</td></tr>
<tr class="separator:a53a12fdc4a19fb23acea4c0ed11c4cfd"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6b173d2702c2e33c05eec8f5676affd8"><td class="memItemLeft" align="right" valign="top">const std::vector&lt; <a class="el" href="classpcpp_1_1_i_pv4_address.html">IPv4Address</a> &gt; &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classpcpp_1_1_pcap_live_device.html#a6b173d2702c2e33c05eec8f5676affd8">getDnsServers</a> () const</td></tr>
<tr class="separator:a6b173d2702c2e33c05eec8f5676affd8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a349b001c38b0f1e43a1691fedbd1b0cc"><td class="memItemLeft" align="right" valign="top">virtual bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classpcpp_1_1_pcap_live_device.html#a349b001c38b0f1e43a1691fedbd1b0cc">startCapture</a> (<a class="el" href="namespacepcpp.html#a700592e5086544411957be0242dec0f5">OnPacketArrivesCallback</a> onPacketArrives, void *onPacketArrivesUserCookie)</td></tr>
<tr class="separator:a349b001c38b0f1e43a1691fedbd1b0cc"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a78306fe44879e457df4043a117f6863a"><td class="memItemLeft" align="right" valign="top">virtual bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classpcpp_1_1_pcap_live_device.html#a78306fe44879e457df4043a117f6863a">startCapture</a> (<a class="el" href="namespacepcpp.html#a700592e5086544411957be0242dec0f5">OnPacketArrivesCallback</a> onPacketArrives, void *onPacketArrivesUserCookie, int intervalInSecondsToUpdateStats, <a class="el" href="namespacepcpp.html#a83363d443da98e485f8edb46a4184779">OnStatsUpdateCallback</a> onStatsUpdate, void *onStatsUpdateUserCookie)</td></tr>
<tr class="separator:a78306fe44879e457df4043a117f6863a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2933139d284d7c167283982ec8b56559"><td class="memItemLeft" align="right" valign="top">virtual bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classpcpp_1_1_pcap_live_device.html#a2933139d284d7c167283982ec8b56559">startCapture</a> (int intervalInSecondsToUpdateStats, <a class="el" href="namespacepcpp.html#a83363d443da98e485f8edb46a4184779">OnStatsUpdateCallback</a> onStatsUpdate, void *onStatsUpdateUserCookie)</td></tr>
<tr class="separator:a2933139d284d7c167283982ec8b56559"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a821bbac1ffad5a75c6a0be1ff362eb9f"><td class="memItemLeft" align="right" valign="top">virtual bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classpcpp_1_1_pcap_live_device.html#a821bbac1ffad5a75c6a0be1ff362eb9f">startCapture</a> (<a class="el" href="namespacepcpp.html#a4c0775fb93a0867d2afa7992d55957f0">RawPacketVector</a> &amp;capturedPacketsVector)</td></tr>
<tr class="separator:a821bbac1ffad5a75c6a0be1ff362eb9f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1948c03b6471a5dcea064a7a8950a0a0"><td class="memItemLeft" align="right" valign="top">virtual int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classpcpp_1_1_pcap_live_device.html#a1948c03b6471a5dcea064a7a8950a0a0">startCaptureBlockingMode</a> (<a class="el" href="namespacepcpp.html#a6a83c8855a6bb3681fafec04b00a6339">OnPacketArrivesStopBlocking</a> onPacketArrives, void *userCookie, const double timeout)</td></tr>
<tr class="separator:a1948c03b6471a5dcea064a7a8950a0a0"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a818da3e11e0c953385badf6233ee0f43"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classpcpp_1_1_pcap_live_device.html#a818da3e11e0c953385badf6233ee0f43">stopCapture</a> ()</td></tr>
<tr class="separator:a818da3e11e0c953385badf6233ee0f43"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a058f8bc527935d97bbd044614ab93473"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classpcpp_1_1_pcap_live_device.html#a058f8bc527935d97bbd044614ab93473">captureActive</a> ()</td></tr>
<tr class="separator:a058f8bc527935d97bbd044614ab93473"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4bbfee245406c59d1683610fd8819ec5"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classpcpp_1_1_pcap_live_device.html#a4bbfee245406c59d1683610fd8819ec5">doMtuCheck</a> (int packetPayloadLength) const</td></tr>
<tr class="separator:a4bbfee245406c59d1683610fd8819ec5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9d8a41394806dd5e5245046908f60f16"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classpcpp_1_1_pcap_live_device.html#a9d8a41394806dd5e5245046908f60f16">sendPacket</a> (<a class="el" href="classpcpp_1_1_packet.html">Packet</a> *packet, bool checkMtu=true)</td></tr>
<tr class="separator:a9d8a41394806dd5e5245046908f60f16"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a89a20db2f68dcba1675a4895f03180bb"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classpcpp_1_1_pcap_live_device.html#a89a20db2f68dcba1675a4895f03180bb">sendPacket</a> (<a class="el" href="classpcpp_1_1_packet.html">Packet</a> const &amp;packet, bool checkMtu=true)</td></tr>
<tr class="separator:a89a20db2f68dcba1675a4895f03180bb"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2ec557886562d8af27bb7bce07016544"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classpcpp_1_1_pcap_live_device.html#a2ec557886562d8af27bb7bce07016544">sendPacket</a> (<a class="el" href="classpcpp_1_1_raw_packet.html">RawPacket</a> const &amp;rawPacket, bool checkMtu=false)</td></tr>
<tr class="separator:a2ec557886562d8af27bb7bce07016544"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4e5b87c1864ee727e12bb246b071c964"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classpcpp_1_1_pcap_live_device.html#a4e5b87c1864ee727e12bb246b071c964">sendPacket</a> (const uint8_t *packetData, int packetDataLength, int packetPayloadLength)</td></tr>
<tr class="separator:a4e5b87c1864ee727e12bb246b071c964"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a62c57a5a0fd0427188e4c89ac87f12d8"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classpcpp_1_1_pcap_live_device.html#a62c57a5a0fd0427188e4c89ac87f12d8">sendPacket</a> (const uint8_t *packetData, int packetDataLength, bool checkMtu=false, <a class="el" href="namespacepcpp.html#ab3f43dd3ccd8c93acac8b67909be02be">pcpp::LinkLayerType</a> linkType=<a class="el" href="namespacepcpp.html#ab3f43dd3ccd8c93acac8b67909be02bea4a7bd3283e7f9b30aa9e71e7807de215">pcpp::LINKTYPE_ETHERNET</a>)</td></tr>
<tr class="separator:a62c57a5a0fd0427188e4c89ac87f12d8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa11efe575402d9e06624376d87caf4fb"><td class="memItemLeft" align="right" valign="top">virtual int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classpcpp_1_1_pcap_live_device.html#aa11efe575402d9e06624376d87caf4fb">sendPackets</a> (<a class="el" href="classpcpp_1_1_raw_packet.html">RawPacket</a> *rawPacketsArr, int arrLength, bool checkMtu=false)</td></tr>
<tr class="separator:aa11efe575402d9e06624376d87caf4fb"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a71eb799bb039b9b4b182958bf5fdf563"><td class="memItemLeft" align="right" valign="top">virtual int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classpcpp_1_1_pcap_live_device.html#a71eb799bb039b9b4b182958bf5fdf563">sendPackets</a> (<a class="el" href="classpcpp_1_1_packet.html">Packet</a> **packetsArr, int arrLength, bool checkMtu=true)</td></tr>
<tr class="separator:a71eb799bb039b9b4b182958bf5fdf563"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9fb54c1f769a409743c6710f02b4de56"><td class="memItemLeft" align="right" valign="top">virtual int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classpcpp_1_1_pcap_live_device.html#a9fb54c1f769a409743c6710f02b4de56">sendPackets</a> (const <a class="el" href="namespacepcpp.html#a4c0775fb93a0867d2afa7992d55957f0">RawPacketVector</a> &amp;rawPackets, bool checkMtu=false)</td></tr>
<tr class="separator:a9fb54c1f769a409743c6710f02b4de56"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae40c27c0bfd5b397af813fd37a819e73"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classpcpp_1_1_pcap_live_device.html#ae40c27c0bfd5b397af813fd37a819e73">open</a> () override</td></tr>
<tr class="separator:ae40c27c0bfd5b397af813fd37a819e73"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3f58e22a71cbed9109ae75bd1759e8ed"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classpcpp_1_1_pcap_live_device.html#a3f58e22a71cbed9109ae75bd1759e8ed">open</a> (const <a class="el" href="structpcpp_1_1_pcap_live_device_1_1_device_configuration.html">DeviceConfiguration</a> &amp;config)</td></tr>
<tr class="separator:a3f58e22a71cbed9109ae75bd1759e8ed"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a02254c8ce454a469d9846dfc63fab4f6"><td class="memItemLeft" align="right" valign="top"><a id="a02254c8ce454a469d9846dfc63fab4f6"></a>
void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classpcpp_1_1_pcap_live_device.html#a02254c8ce454a469d9846dfc63fab4f6">close</a> () override</td></tr>
<tr class="memdesc:a02254c8ce454a469d9846dfc63fab4f6"><td class="mdescLeft">&#160;</td><td class="mdescRight">Close the device. <br /></td></tr>
<tr class="separator:a02254c8ce454a469d9846dfc63fab4f6"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:acba1065b450b4caf17e7d0c99959aa99"><td class="memItemLeft" align="right" valign="top">virtual <a class="el" href="classpcpp_1_1_pcap_live_device.html">PcapLiveDevice</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classpcpp_1_1_pcap_live_device.html#acba1065b450b4caf17e7d0c99959aa99">clone</a> () const</td></tr>
<tr class="separator:acba1065b450b4caf17e7d0c99959aa99"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3a5928913d4fb57ffc5b3afe08a10b0f"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classpcpp_1_1_pcap_live_device.html#a3a5928913d4fb57ffc5b3afe08a10b0f">getStatistics</a> (<a class="el" href="structpcpp_1_1internal_1_1_pcap_stats.html">IPcapDevice::PcapStats</a> &amp;stats) const override</td></tr>
<tr class="separator:a3a5928913d4fb57ffc5b3afe08a10b0f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="inherit_header pub_methods_classpcpp_1_1_i_pcap_device"><td colspan="2" onclick="javascript:toggleInherit('pub_methods_classpcpp_1_1_i_pcap_device')"><img src="closed.png" alt="-"/>&#160;Public Member Functions inherited from <a class="el" href="classpcpp_1_1_i_pcap_device.html">pcpp::IPcapDevice</a></td></tr>
<tr class="memitem:a5308f2b55bb22afdef5ddfda63332398 inherit pub_methods_classpcpp_1_1_i_pcap_device"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classpcpp_1_1_i_pcap_device.html#a5308f2b55bb22afdef5ddfda63332398">setFilter</a> (std::string filterAsString) override</td></tr>
<tr class="separator:a5308f2b55bb22afdef5ddfda63332398 inherit pub_methods_classpcpp_1_1_i_pcap_device"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a55ad37f74e67d152ca8973535d5f7ddf inherit pub_methods_classpcpp_1_1_i_pcap_device"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classpcpp_1_1_i_pcap_device.html#a55ad37f74e67d152ca8973535d5f7ddf">clearFilter</a> () override</td></tr>
<tr class="separator:a55ad37f74e67d152ca8973535d5f7ddf inherit pub_methods_classpcpp_1_1_i_pcap_device"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af334503822ac7076373c64109f3e6d64 inherit pub_methods_classpcpp_1_1_i_pcap_device"><td class="memItemLeft" align="right" valign="top">virtual bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classpcpp_1_1_i_pcap_device.html#af334503822ac7076373c64109f3e6d64">setFilter</a> (<a class="el" href="classpcpp_1_1_general_filter.html">GeneralFilter</a> &amp;filter)</td></tr>
<tr class="separator:af334503822ac7076373c64109f3e6d64 inherit pub_methods_classpcpp_1_1_i_pcap_device"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:adf01bb590d975d28fc38053820a69130 inherit pub_methods_classpcpp_1_1_i_pcap_device"><td class="memItemLeft" align="right" valign="top">virtual bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classpcpp_1_1_i_pcap_device.html#adf01bb590d975d28fc38053820a69130">setFilter</a> (std::string filterAsString)=0</td></tr>
<tr class="separator:adf01bb590d975d28fc38053820a69130 inherit pub_methods_classpcpp_1_1_i_pcap_device"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="inherit_header pub_methods_classpcpp_1_1_i_device"><td colspan="2" onclick="javascript:toggleInherit('pub_methods_classpcpp_1_1_i_device')"><img src="closed.png" alt="-"/>&#160;Public Member Functions inherited from <a class="el" href="classpcpp_1_1_i_device.html">pcpp::IDevice</a></td></tr>
<tr class="memitem:a5b75e7491597f271b8f29847bec2ee99 inherit pub_methods_classpcpp_1_1_i_device"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classpcpp_1_1_i_device.html#a5b75e7491597f271b8f29847bec2ee99">isOpened</a> ()</td></tr>
<tr class="separator:a5b75e7491597f271b8f29847bec2ee99 inherit pub_methods_classpcpp_1_1_i_device"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="inherit_header pub_methods_classpcpp_1_1_i_filterable_device"><td colspan="2" onclick="javascript:toggleInherit('pub_methods_classpcpp_1_1_i_filterable_device')"><img src="closed.png" alt="-"/>&#160;Public Member Functions inherited from <a class="el" href="classpcpp_1_1_i_filterable_device.html">pcpp::IFilterableDevice</a></td></tr>
<tr class="memitem:af334503822ac7076373c64109f3e6d64 inherit pub_methods_classpcpp_1_1_i_filterable_device"><td class="memItemLeft" align="right" valign="top">virtual bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classpcpp_1_1_i_filterable_device.html#af334503822ac7076373c64109f3e6d64">setFilter</a> (<a class="el" href="classpcpp_1_1_general_filter.html">GeneralFilter</a> &amp;filter)</td></tr>
<tr class="separator:af334503822ac7076373c64109f3e6d64 inherit pub_methods_classpcpp_1_1_i_filterable_device"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="inherit_header pub_methods_classpcpp_1_1_i_pcap_statistics_provider"><td colspan="2" onclick="javascript:toggleInherit('pub_methods_classpcpp_1_1_i_pcap_statistics_provider')"><img src="closed.png" alt="-"/>&#160;Public Member Functions inherited from <a class="el" href="classpcpp_1_1_i_pcap_statistics_provider.html">pcpp::IPcapStatisticsProvider</a></td></tr>
<tr class="memitem:affac08c8925f77baf4a5db28dd1a0d83 inherit pub_methods_classpcpp_1_1_i_pcap_statistics_provider"><td class="memItemLeft" align="right" valign="top"><a class="el" href="structpcpp_1_1internal_1_1_pcap_stats.html">PcapStats</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classpcpp_1_1_i_pcap_statistics_provider.html#affac08c8925f77baf4a5db28dd1a0d83">getStatistics</a> () const</td></tr>
<tr class="memdesc:affac08c8925f77baf4a5db28dd1a0d83 inherit pub_methods_classpcpp_1_1_i_pcap_statistics_provider"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get statistics from the device.  <a href="classpcpp_1_1_i_pcap_statistics_provider.html#affac08c8925f77baf4a5db28dd1a0d83">More...</a><br /></td></tr>
<tr class="separator:affac08c8925f77baf4a5db28dd1a0d83 inherit pub_methods_classpcpp_1_1_i_pcap_statistics_provider"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="pro-methods"></a>
Protected Member Functions</h2></td></tr>
<tr class="memitem:af9eb88d92d3221c6edb0da7b181869cc"><td class="memItemLeft" align="right" valign="top">virtual void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classpcpp_1_1_pcap_live_device.html#af9eb88d92d3221c6edb0da7b181869cc">prepareCapture</a> (bool asyncCapture, bool captureStats)</td></tr>
<tr class="memdesc:af9eb88d92d3221c6edb0da7b181869cc"><td class="mdescLeft">&#160;</td><td class="mdescRight">Called before starting a capture to prepare the device for capturing packets.  <a href="classpcpp_1_1_pcap_live_device.html#af9eb88d92d3221c6edb0da7b181869cc">More...</a><br /></td></tr>
<tr class="separator:af9eb88d92d3221c6edb0da7b181869cc"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a729d3f09aeb52e59382eef9c6069567e"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classpcpp_1_1_pcap_live_device.html#a729d3f09aeb52e59382eef9c6069567e">isPayloadWithinMtu</a> (size_t payloadLength) const</td></tr>
<tr class="memdesc:a729d3f09aeb52e59382eef9c6069567e"><td class="mdescLeft">&#160;</td><td class="mdescRight">Checks whether the packetPayloadLength is smaller or equal than the device MTU.  <a href="classpcpp_1_1_pcap_live_device.html#a729d3f09aeb52e59382eef9c6069567e">More...</a><br /></td></tr>
<tr class="separator:a729d3f09aeb52e59382eef9c6069567e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab6ada849695721d0b21ca03a00befc3f"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classpcpp_1_1_pcap_live_device.html#ab6ada849695721d0b21ca03a00befc3f">isPayloadWithinMtu</a> (<a class="el" href="classpcpp_1_1_packet.html">Packet</a> const &amp;packet, bool allowUnknownLength=false, size_t *outPayloadLength=nullptr) const</td></tr>
<tr class="memdesc:ab6ada849695721d0b21ca03a00befc3f"><td class="mdescLeft">&#160;</td><td class="mdescRight">Checks whether the packet's payload length is smaller or equal than the device MTU.  <a href="classpcpp_1_1_pcap_live_device.html#ab6ada849695721d0b21ca03a00befc3f">More...</a><br /></td></tr>
<tr class="separator:ab6ada849695721d0b21ca03a00befc3f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:adb224a2e5d31724ac15e11c5bfa7e778"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classpcpp_1_1_pcap_live_device.html#adb224a2e5d31724ac15e11c5bfa7e778">isPayloadWithinMtu</a> (<a class="el" href="classpcpp_1_1_raw_packet.html">RawPacket</a> const &amp;rawPacket, bool allowUnknownLength=false, size_t *outPayloadLength=nullptr) const</td></tr>
<tr class="memdesc:adb224a2e5d31724ac15e11c5bfa7e778"><td class="mdescLeft">&#160;</td><td class="mdescRight">Checks whether the payload length of a <a class="el" href="classpcpp_1_1_raw_packet.html">RawPacket</a> is smaller or equal than the device MTU.  <a href="classpcpp_1_1_pcap_live_device.html#adb224a2e5d31724ac15e11c5bfa7e778">More...</a><br /></td></tr>
<tr class="separator:adb224a2e5d31724ac15e11c5bfa7e778"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8ead45cde4c727a706ff8f9967d65660"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classpcpp_1_1_pcap_live_device.html#a8ead45cde4c727a706ff8f9967d65660">isPayloadWithinMtu</a> (uint8_t const *packetData, size_t packetLen, <a class="el" href="namespacepcpp.html#ab3f43dd3ccd8c93acac8b67909be02be">LinkLayerType</a> linkType=<a class="el" href="namespacepcpp.html#ab3f43dd3ccd8c93acac8b67909be02bea4a7bd3283e7f9b30aa9e71e7807de215">pcpp::LINKTYPE_ETHERNET</a>, bool allowUnknownLength=false, size_t *outPayloadLength=nullptr) const</td></tr>
<tr class="memdesc:a8ead45cde4c727a706ff8f9967d65660"><td class="mdescLeft">&#160;</td><td class="mdescRight">Checks whether the payload length of a packet's raw data is smaller or equal than the device MTU.  <a href="classpcpp_1_1_pcap_live_device.html#a8ead45cde4c727a706ff8f9967d65660">More...</a><br /></td></tr>
<tr class="separator:a8ead45cde4c727a706ff8f9967d65660"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="inherited"></a>
Additional Inherited Members</h2></td></tr>
<tr class="inherit_header pub_static_methods_classpcpp_1_1_i_pcap_device"><td colspan="2" onclick="javascript:toggleInherit('pub_static_methods_classpcpp_1_1_i_pcap_device')"><img src="closed.png" alt="-"/>&#160;Static Public Member Functions inherited from <a class="el" href="classpcpp_1_1_i_pcap_device.html">pcpp::IPcapDevice</a></td></tr>
<tr class="memitem:ac9e91fa6b66ced9a92d09068712ccffc inherit pub_static_methods_classpcpp_1_1_i_pcap_device"><td class="memItemLeft" align="right" valign="top">static std::string&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classpcpp_1_1_i_pcap_device.html#ac9e91fa6b66ced9a92d09068712ccffc">getPcapLibVersionInfo</a> ()</td></tr>
<tr class="separator:ac9e91fa6b66ced9a92d09068712ccffc inherit pub_static_methods_classpcpp_1_1_i_pcap_device"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9095bdfe0c8e79b656b2651a721a2ea2 inherit pub_static_methods_classpcpp_1_1_i_pcap_device"><td class="memItemLeft" align="right" valign="top">static bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classpcpp_1_1_i_pcap_device.html#a9095bdfe0c8e79b656b2651a721a2ea2">matchPacketWithFilter</a> (<a class="el" href="classpcpp_1_1_general_filter.html">GeneralFilter</a> &amp;filter, <a class="el" href="classpcpp_1_1_raw_packet.html">RawPacket</a> *rawPacket)</td></tr>
<tr class="separator:a9095bdfe0c8e79b656b2651a721a2ea2 inherit pub_static_methods_classpcpp_1_1_i_pcap_device"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table>
<a name="details" id="details"></a><h2 class="groupheader">Detailed Description</h2>
<div class="textblock"><p>A class that wraps a network interface (each of the interfaces listed in ifconfig/ipconfig). This class wraps the libpcap capabilities of capturing packets from the network, filtering packets and sending packets back to the network. This class is relevant for Linux applications only. On Windows the <a class="el" href="classpcpp_1_1_win_pcap_live_device.html">WinPcapLiveDevice</a> (which inherits this class) is used. Both classes are almost similar in capabilities, the main difference between them is adapting some capabilities to the specific OS. This class cannot be instantiated by the user (it has a private constructor), as network interfaces aren't dynamic. Instances of this class (one instance per network interface) are created by <a class="el" href="classpcpp_1_1_pcap_live_device_list.html">PcapLiveDeviceList</a> singleton on application startup and the user can get access to them by using <a class="el" href="classpcpp_1_1_pcap_live_device_list.html">PcapLiveDeviceList</a> public methods such as <a class="el" href="classpcpp_1_1_pcap_live_device_list.html#a1921e94307197c9b8f613bb35fc1a0c5">PcapLiveDeviceList::getPcapLiveDeviceByIp()</a><br  />
 Main capabilities of this class:</p><ul>
<li>Get all available information for this network interfaces such as name, IP addresses, MAC address, MTU, etc. This information is taken from both libpcap and the OS</li>
<li>Capture packets from the network. Capturing is always conducted on a different thread. PcapPlusPlus creates this thread when capturing starts and kills it when capturing ends. This prevents the application from being stuck while waiting for packets or processing them. Currently only one capturing thread is allowed, so when the interface is in capture mode, no further capturing is allowed. In addition to capturing the user can get stats on packets that were received by the application, dropped by the NIC (due to full NIC buffers), etc. Stats collection can be initiated by the user by calling <a class="el" href="classpcpp_1_1_pcap_live_device.html#a3a5928913d4fb57ffc5b3afe08a10b0f">getStatistics()</a> or be pushed to the user periodically by supplying a callback and a timeout to <a class="el" href="classpcpp_1_1_pcap_live_device.html#a349b001c38b0f1e43a1691fedbd1b0cc">startCapture()</a></li>
<li>Send packets back to the network. Sending the packets is done on the caller thread. No additional threads are created for this task </li>
</ul>
</div><h2 class="groupheader">Member Enumeration Documentation</h2>
<a id="a2381e7f053285090f0f9620bcbd8f0f3"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a2381e7f053285090f0f9620bcbd8f0f3">&#9670;&nbsp;</a></span>DeviceMode</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">enum <a class="el" href="classpcpp_1_1_pcap_live_device.html#a2381e7f053285090f0f9620bcbd8f0f3">pcpp::PcapLiveDevice::DeviceMode</a></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Device capturing mode. </p>
<table class="fieldtable">
<tr><th colspan="2">Enumerator</th></tr><tr><td class="fieldname"><a id="a2381e7f053285090f0f9620bcbd8f0f3ad57df3ce2415ba6f804539bb268aecdf"></a>Normal&#160;</td><td class="fielddoc"><p>Only packets that their destination is this NIC are captured. </p>
</td></tr>
<tr><td class="fieldname"><a id="a2381e7f053285090f0f9620bcbd8f0f3af1c5bb543295a735a99cc9f88ac67bca"></a>Promiscuous&#160;</td><td class="fielddoc"><p>All packets that arrive to the NIC are captured, even packets that their destination isn't this NIC. </p>
</td></tr>
</table>

</div>
</div>
<a id="a0e343585711ee4e02d4b9507467135ab"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a0e343585711ee4e02d4b9507467135ab">&#9670;&nbsp;</a></span>LiveDeviceType</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">enum <a class="el" href="classpcpp_1_1_pcap_live_device.html#a0e343585711ee4e02d4b9507467135ab">pcpp::PcapLiveDevice::LiveDeviceType</a></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>The type of the live device. </p>
<table class="fieldtable">
<tr><th colspan="2">Enumerator</th></tr><tr><td class="fieldname"><a id="a0e343585711ee4e02d4b9507467135aba975b2663c8a8bcc495a71af5e80f8652"></a>LibPcapDevice&#160;</td><td class="fielddoc"><p>libPcap live device </p>
</td></tr>
<tr><td class="fieldname"><a id="a0e343585711ee4e02d4b9507467135aba0c8c0011ab41d3aeee8e8f1c29fd07b6"></a>WinPcapDevice&#160;</td><td class="fielddoc"><p>WinPcap/Npcap live device. </p>
</td></tr>
<tr><td class="fieldname"><a id="a0e343585711ee4e02d4b9507467135aba47692cc2f098676c70ad0505059f581c"></a>RemoteDevice&#160;</td><td class="fielddoc"><p>WinPcap/Npcap Remote Capture device. </p>
</td></tr>
</table>

</div>
</div>
<a id="a00efdbd7aca92b696dd585cf3301add5"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a00efdbd7aca92b696dd585cf3301add5">&#9670;&nbsp;</a></span>PcapDirection</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">enum <a class="el" href="classpcpp_1_1_pcap_live_device.html#a00efdbd7aca92b696dd585cf3301add5">pcpp::PcapLiveDevice::PcapDirection</a></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Set direction for capturing packets (you can read more here: <a href="https://www.tcpdump.org/manpages/pcap.3pcap.html#lbAI">https://www.tcpdump.org/manpages/pcap.3pcap.html#lbAI</a>) </p>
<table class="fieldtable">
<tr><th colspan="2">Enumerator</th></tr><tr><td class="fieldname"><a id="a00efdbd7aca92b696dd585cf3301add5acf27653531bcc39386aecacd44416052"></a>PCPP_INOUT&#160;</td><td class="fielddoc"><p>Capture traffics both incoming and outgoing. </p>
</td></tr>
<tr><td class="fieldname"><a id="a00efdbd7aca92b696dd585cf3301add5a9da5011f04f2f9cf302d144d311f27ab"></a>PCPP_IN&#160;</td><td class="fielddoc"><p>Only capture incoming traffics. </p>
</td></tr>
<tr><td class="fieldname"><a id="a00efdbd7aca92b696dd585cf3301add5aa09daf455022a9dab650fdcb2171ba1c"></a>PCPP_OUT&#160;</td><td class="fielddoc"><p>Only capture outgoing traffics. </p>
</td></tr>
</table>

</div>
</div>
<a id="a7b819cd593026da0e65274221f52db82"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a7b819cd593026da0e65274221f52db82">&#9670;&nbsp;</a></span>TimestampPrecision</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">enum <a class="el" href="classpcpp_1_1_pcap_live_device.html#a7b819cd593026da0e65274221f52db82">pcpp::PcapLiveDevice::TimestampPrecision</a></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">strong</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Set the precision of timestamps associated to each captured packet (you can read more here: <a href="https://www.tcpdump.org/manpages/pcap-tstamp.7.html">https://www.tcpdump.org/manpages/pcap-tstamp.7.html</a>) </p>
<table class="fieldtable">
<tr><th colspan="2">Enumerator</th></tr><tr><td class="fieldname"><a id="a7b819cd593026da0e65274221f52db82a64068ed47d979c5efa036f027d656433"></a>Microseconds&#160;</td><td class="fielddoc"><p>use timestamps with microsecond precision, default </p>
</td></tr>
<tr><td class="fieldname"><a id="a7b819cd593026da0e65274221f52db82afba00bdab687ce01136a86bac8bac578"></a>Nanoseconds&#160;</td><td class="fielddoc"><p>use timestamps with nanosecond precision </p>
</td></tr>
</table>

</div>
</div>
<a id="ac5b95d68aa486b7ac038096fe1b8d71e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ac5b95d68aa486b7ac038096fe1b8d71e">&#9670;&nbsp;</a></span>TimestampProvider</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">enum <a class="el" href="classpcpp_1_1_pcap_live_device.html#ac5b95d68aa486b7ac038096fe1b8d71e">pcpp::PcapLiveDevice::TimestampProvider</a></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">strong</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Set which source provides timestamps associated to each captured packet (you can read more here: <a href="https://www.tcpdump.org/manpages/pcap-tstamp.7.html">https://www.tcpdump.org/manpages/pcap-tstamp.7.html</a>) </p>
<table class="fieldtable">
<tr><th colspan="2">Enumerator</th></tr><tr><td class="fieldname"><a id="ac5b95d68aa486b7ac038096fe1b8d71eac2ca16d048ec66e04bca283eab048ec2"></a>Host&#160;</td><td class="fielddoc"><p>host-provided, unknown characteristics, default </p>
</td></tr>
<tr><td class="fieldname"><a id="ac5b95d68aa486b7ac038096fe1b8d71ea81a53679545718b26c514315c26db901"></a>HostLowPrecision&#160;</td><td class="fielddoc"><p>host-provided, low precision, synced with the system clock </p>
</td></tr>
<tr><td class="fieldname"><a id="ac5b95d68aa486b7ac038096fe1b8d71eaa0d6622487e925677aec54f04dd30ac9"></a>HostHighPrecision&#160;</td><td class="fielddoc"><p>host-provided, high precision, synced with the system clock </p>
</td></tr>
<tr><td class="fieldname"><a id="ac5b95d68aa486b7ac038096fe1b8d71ea8601c10b2797050a900697daac0c0001"></a>Adapter&#160;</td><td class="fielddoc"><p>device-provided, synced with the system clock </p>
</td></tr>
<tr><td class="fieldname"><a id="ac5b95d68aa486b7ac038096fe1b8d71ea18ac6b0e8fa6cc2bf36b556bdd3feb70"></a>AdapterUnsynced&#160;</td><td class="fielddoc"><p>device-provided, not synced with the system clock </p>
</td></tr>
<tr><td class="fieldname"><a id="ac5b95d68aa486b7ac038096fe1b8d71eafd90a006b8288716dc2baebdfe845269"></a>HostHighPrecisionUnsynced&#160;</td><td class="fielddoc"><p>host-provided, high precision, not synced with the system clock </p>
</td></tr>
</table>

</div>
</div>
<h2 class="groupheader">Member Function Documentation</h2>
<a id="a058f8bc527935d97bbd044614ab93473"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a058f8bc527935d97bbd044614ab93473">&#9670;&nbsp;</a></span>captureActive()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool pcpp::PcapLiveDevice::captureActive </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Check if a capture thread is running </p><dl class="section return"><dt>Returns</dt><dd>True if a capture thread is currently running </dd></dl>

</div>
</div>
<a id="acba1065b450b4caf17e7d0c99959aa99"></a>
<h2 class="memtitle"><span class="permalink"><a href="#acba1065b450b4caf17e7d0c99959aa99">&#9670;&nbsp;</a></span>clone()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual <a class="el" href="classpcpp_1_1_pcap_live_device.html">PcapLiveDevice</a>* pcpp::PcapLiveDevice::clone </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Clones the current device class </p><dl class="section return"><dt>Returns</dt><dd>Pointer to the copied class </dd></dl>

<p>Reimplemented in <a class="el" href="classpcpp_1_1_win_pcap_live_device.html#afa1ea09ecf301d6ae212965383d098a4">pcpp::WinPcapLiveDevice</a>, and <a class="el" href="classpcpp_1_1_pcap_remote_device.html#a13ab40f135b475281db2e833baff5965">pcpp::PcapRemoteDevice</a>.</p>

</div>
</div>
<a id="a4bbfee245406c59d1683610fd8819ec5"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a4bbfee245406c59d1683610fd8819ec5">&#9670;&nbsp;</a></span>doMtuCheck()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool pcpp::PcapLiveDevice::doMtuCheck </td>
          <td>(</td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>packetPayloadLength</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Checks whether the packetPayloadLength is larger than the device MTU. Logs an error if check fails </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">packetPayloadLength</td><td>The length of the IP layer of the packet </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>True if the packetPayloadLength is less than or equal to the device MTU </dd></dl>

</div>
</div>
<a id="a53a12fdc4a19fb23acea4c0ed11c4cfd"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a53a12fdc4a19fb23acea4c0ed11c4cfd">&#9670;&nbsp;</a></span>getDefaultGateway()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classpcpp_1_1_i_pv4_address.html">IPv4Address</a> pcpp::PcapLiveDevice::getDefaultGateway </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">
<dl class="section return"><dt>Returns</dt><dd>The default gateway defined for this interface. If no default gateway is defined, if it's not IPv4 or if couldn't extract default gateway <a class="el" href="classpcpp_1_1_i_pv4_address.html#abd6badbf09d36b21ce83d54fd06bd17b" title="A static value representing a zero value of IPv4 address, meaning address of value &quot;0....">IPv4Address::Zero</a> will be returned. If multiple gateways were defined the first one will be returned </dd></dl>

</div>
</div>
<a id="a54ee9e8c709de885bdb738844fca76b3"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a54ee9e8c709de885bdb738844fca76b3">&#9670;&nbsp;</a></span>getDesc()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">std::string pcpp::PcapLiveDevice::getDesc </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<dl class="section return"><dt>Returns</dt><dd>A human-readable description of the device, taken from pcap_if_t-&gt;description. May be empty string in some interfaces </dd></dl>

</div>
</div>
<a id="a76bd1af9e2079c71a790834e2f14baa7"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a76bd1af9e2079c71a790834e2f14baa7">&#9670;&nbsp;</a></span>getDeviceType()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual <a class="el" href="classpcpp_1_1_pcap_live_device.html#a0e343585711ee4e02d4b9507467135ab">LiveDeviceType</a> pcpp::PcapLiveDevice::getDeviceType </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<dl class="section return"><dt>Returns</dt><dd>The type of the device (libPcap, WinPcap/Npcap or a remote device) </dd></dl>

<p>Reimplemented in <a class="el" href="classpcpp_1_1_win_pcap_live_device.html#aa447e59136942fd86f21933b85d901a3">pcpp::WinPcapLiveDevice</a>, and <a class="el" href="classpcpp_1_1_pcap_remote_device.html#acec79d2c4dd6842632485fa6d9fd78aa">pcpp::PcapRemoteDevice</a>.</p>

</div>
</div>
<a id="a6b173d2702c2e33c05eec8f5676affd8"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a6b173d2702c2e33c05eec8f5676affd8">&#9670;&nbsp;</a></span>getDnsServers()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">const std::vector&lt;<a class="el" href="classpcpp_1_1_i_pv4_address.html">IPv4Address</a>&gt;&amp; pcpp::PcapLiveDevice::getDnsServers </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">
<dl class="section return"><dt>Returns</dt><dd>A list of all DNS servers defined for this machine. If this list is empty it means no DNS servers were defined or they couldn't be extracted from some reason. This list is created in <a class="el" href="classpcpp_1_1_pcap_live_device_list.html">PcapLiveDeviceList</a> class and can be also retrieved from there. This method exists for convenience - so it'll be possible to get this list from <a class="el" href="classpcpp_1_1_pcap_live_device.html">PcapLiveDevice</a> as well </dd></dl>

</div>
</div>
<a id="af2e91ef6742fdcbbf2f41dc35266c99d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#af2e91ef6742fdcbbf2f41dc35266c99d">&#9670;&nbsp;</a></span>getIPAddresses()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">std::vector&lt;<a class="el" href="classpcpp_1_1_i_p_address.html">IPAddress</a>&gt; pcpp::PcapLiveDevice::getIPAddresses </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<dl class="section return"><dt>Returns</dt><dd>A vector containing all IP addresses defined for this interface. </dd></dl>

</div>
</div>
<a id="a9a3915b20de33f61dd40e434688fa63c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a9a3915b20de33f61dd40e434688fa63c">&#9670;&nbsp;</a></span>getIPv4Address()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classpcpp_1_1_i_pv4_address.html">IPv4Address</a> pcpp::PcapLiveDevice::getIPv4Address </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">
<dl class="section return"><dt>Returns</dt><dd>The IPv4 address for this interface. If multiple IPv4 addresses are defined for this interface, the first will be picked. If no IPv4 addresses are defined, a zeroed IPv4 address (<a class="el" href="classpcpp_1_1_i_pv4_address.html#abd6badbf09d36b21ce83d54fd06bd17b" title="A static value representing a zero value of IPv4 address, meaning address of value &quot;0....">IPv4Address::Zero</a>) will be returned </dd></dl>

</div>
</div>
<a id="a80e77bde8d290d33376ac8825c272534"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a80e77bde8d290d33376ac8825c272534">&#9670;&nbsp;</a></span>getIPv6Address()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classpcpp_1_1_i_pv6_address.html">IPv6Address</a> pcpp::PcapLiveDevice::getIPv6Address </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">
<dl class="section return"><dt>Returns</dt><dd>The IPv6 address for this interface. If multiple IPv6 addresses are defined for this interface, the first will be picked. If no IPv6 addresses are defined, a zeroed IPv6 address (<a class="el" href="classpcpp_1_1_i_pv6_address.html#a4a55ced93d845d18f36b01805811c93d">IPv6Address::Zero</a>) will be returned </dd></dl>

</div>
</div>
<a id="ab80a7d9e829f0b0a4c7eddeb746a69be"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ab80a7d9e829f0b0a4c7eddeb746a69be">&#9670;&nbsp;</a></span>getLinkType()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual <a class="el" href="namespacepcpp.html#ab3f43dd3ccd8c93acac8b67909be02be">LinkLayerType</a> pcpp::PcapLiveDevice::getLinkType </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<dl class="section return"><dt>Returns</dt><dd>The device's link layer type </dd></dl>

</div>
</div>
<a id="acafca8ced5f590d537f1aed6fc94fcfe"></a>
<h2 class="memtitle"><span class="permalink"><a href="#acafca8ced5f590d537f1aed6fc94fcfe">&#9670;&nbsp;</a></span>getLoopback()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool pcpp::PcapLiveDevice::getLoopback </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<dl class="section return"><dt>Returns</dt><dd>True if this interface is a loopback interface, false otherwise </dd></dl>

</div>
</div>
<a id="a4bc13ec8552ffbf5ae2fe281c4d0905b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a4bc13ec8552ffbf5ae2fe281c4d0905b">&#9670;&nbsp;</a></span>getMacAddress()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual <a class="el" href="classpcpp_1_1_mac_address.html">MacAddress</a> pcpp::PcapLiveDevice::getMacAddress </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<dl class="section return"><dt>Returns</dt><dd>The MAC address for this interface </dd></dl>

<p>Reimplemented in <a class="el" href="classpcpp_1_1_pcap_remote_device.html#a84ef0acd04879b3ef4dd0c90fe7d901f">pcpp::PcapRemoteDevice</a>.</p>

</div>
</div>
<a id="a2eeadb33b0e5097213752a76d1e71ba7"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a2eeadb33b0e5097213752a76d1e71ba7">&#9670;&nbsp;</a></span>getMtu()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual uint32_t pcpp::PcapLiveDevice::getMtu </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<dl class="section return"><dt>Returns</dt><dd>The device's maximum transmission unit (MTU) in bytes </dd></dl>

<p>Reimplemented in <a class="el" href="classpcpp_1_1_pcap_remote_device.html#a575d0d6348053f6063ac90a156bdfd6d">pcpp::PcapRemoteDevice</a>.</p>

</div>
</div>
<a id="a8b4bf1bc2bed7dfcbadd30ace0bc84bf"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a8b4bf1bc2bed7dfcbadd30ace0bc84bf">&#9670;&nbsp;</a></span>getName()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">std::string pcpp::PcapLiveDevice::getName </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<dl class="section return"><dt>Returns</dt><dd>The name of the device (e.g eth0), taken from pcap_if_t-&gt;name </dd></dl>

</div>
</div>
<a id="a3a5928913d4fb57ffc5b3afe08a10b0f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a3a5928913d4fb57ffc5b3afe08a10b0f">&#9670;&nbsp;</a></span>getStatistics()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void pcpp::PcapLiveDevice::getStatistics </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structpcpp_1_1internal_1_1_pcap_stats.html">IPcapDevice::PcapStats</a> &amp;&#160;</td>
          <td class="paramname"><em>stats</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">override</span><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Get statistics from the device </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[out]</td><td class="paramname">stats</td><td>An object containing the stats </td></tr>
  </table>
  </dd>
</dl>

<p>Implements <a class="el" href="classpcpp_1_1_i_pcap_statistics_provider.html#a04c676bd9013cf597f7b6512924b7ee2">pcpp::IPcapStatisticsProvider</a>.</p>

<p>Reimplemented in <a class="el" href="classpcpp_1_1_pcap_remote_device.html#a00ca1adcbd9baccfcb89d167934b929d">pcpp::PcapRemoteDevice</a>.</p>

</div>
</div>
<a id="ab6ada849695721d0b21ca03a00befc3f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ab6ada849695721d0b21ca03a00befc3f">&#9670;&nbsp;</a></span>isPayloadWithinMtu() <span class="overload">[1/4]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool pcpp::PcapLiveDevice::isPayloadWithinMtu </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classpcpp_1_1_packet.html">Packet</a> const &amp;&#160;</td>
          <td class="paramname"><em>packet</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>allowUnknownLength</em> = <code>false</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t *&#160;</td>
          <td class="paramname"><em>outPayloadLength</em> = <code>nullptr</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">protected</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Checks whether the packet's payload length is smaller or equal than the device MTU. </p>
<p>If the payload length cannot be determined, the function will return the value of allowUnknownLength. In such cases, if outPayloadLength is not nullptr, it will be set to the maximum value of size_t (i.e., std::numeric_limits&lt;size_t&gt;::max()), indicating that the payload length could not be determined.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">packet</td><td>The packet to check </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">allowUnknownLength</td><td>Controls whether packets with unknown payload length are allowed. </td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">outPayloadLength</td><td>If not nullptr, the payload length of the packet will be written to this pointer. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>True if the packet's payload length is less than or equal to the device MTU. If the packet's length cannot be determined, it will return true if allowUnknownLength is true. </dd></dl>

</div>
</div>
<a id="adb224a2e5d31724ac15e11c5bfa7e778"></a>
<h2 class="memtitle"><span class="permalink"><a href="#adb224a2e5d31724ac15e11c5bfa7e778">&#9670;&nbsp;</a></span>isPayloadWithinMtu() <span class="overload">[2/4]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool pcpp::PcapLiveDevice::isPayloadWithinMtu </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classpcpp_1_1_raw_packet.html">RawPacket</a> const &amp;&#160;</td>
          <td class="paramname"><em>rawPacket</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>allowUnknownLength</em> = <code>false</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t *&#160;</td>
          <td class="paramname"><em>outPayloadLength</em> = <code>nullptr</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">protected</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Checks whether the payload length of a <a class="el" href="classpcpp_1_1_raw_packet.html">RawPacket</a> is smaller or equal than the device MTU. </p>
<p>If the payload length cannot be determined, the function will return the value of allowUnknownLength. In such cases, if outPayloadLength is not nullptr, it will be set to the maximum value of size_t (i.e., std::numeric_limits&lt;size_t&gt;::max()), indicating that the payload length could not be determined.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">rawPacket</td><td>The <a class="el" href="classpcpp_1_1_raw_packet.html">RawPacket</a> to check. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">allowUnknownLength</td><td>Controls whether packets with unknown payload length are allowed. </td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">outPayloadLength</td><td>If not nullptr, the payload length of the packet will be written to this pointer. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>True if the packet's payload length is less than or equal to the device MTU. If the packet's length cannot be determined, it will return true if allowUnknownLength is true. </dd></dl>

</div>
</div>
<a id="a729d3f09aeb52e59382eef9c6069567e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a729d3f09aeb52e59382eef9c6069567e">&#9670;&nbsp;</a></span>isPayloadWithinMtu() <span class="overload">[3/4]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool pcpp::PcapLiveDevice::isPayloadWithinMtu </td>
          <td>(</td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>payloadLength</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">protected</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Checks whether the packetPayloadLength is smaller or equal than the device MTU. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">payloadLength</td><td>The length of the IP layer of the packet </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>True if the payloadLength is less than or equal to the device MTU </dd></dl>

</div>
</div>
<a id="a8ead45cde4c727a706ff8f9967d65660"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a8ead45cde4c727a706ff8f9967d65660">&#9670;&nbsp;</a></span>isPayloadWithinMtu() <span class="overload">[4/4]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool pcpp::PcapLiveDevice::isPayloadWithinMtu </td>
          <td>(</td>
          <td class="paramtype">uint8_t const *&#160;</td>
          <td class="paramname"><em>packetData</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>packetLen</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="namespacepcpp.html#ab3f43dd3ccd8c93acac8b67909be02be">LinkLayerType</a>&#160;</td>
          <td class="paramname"><em>linkType</em> = <code><a class="el" href="namespacepcpp.html#ab3f43dd3ccd8c93acac8b67909be02bea4a7bd3283e7f9b30aa9e71e7807de215">pcpp::LINKTYPE_ETHERNET</a></code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>allowUnknownLength</em> = <code>false</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t *&#160;</td>
          <td class="paramname"><em>outPayloadLength</em> = <code>nullptr</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">protected</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Checks whether the payload length of a packet's raw data is smaller or equal than the device MTU. </p>
<p>If the payload length cannot be determined, the function will return the value of allowUnknownLength. In such cases, if outPayloadLength is not nullptr, it will be set to the maximum value of size_t (i.e., std::numeric_limits&lt;size_t&gt;::max()), indicating that the payload length could not be determined.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">packetData</td><td>A pointer to the raw data of the packet. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">packetLen</td><td>The length of the raw data in bytes. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">linkType</td><td>The link layer type of the packet. Default is <a class="el" href="namespacepcpp.html#ab3f43dd3ccd8c93acac8b67909be02bea4a7bd3283e7f9b30aa9e71e7807de215" title="IEEE 802.3 Ethernet.">pcpp::LINKTYPE_ETHERNET</a>. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">allowUnknownLength</td><td>Controls whether packets with unknown payload length are allowed. </td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">outPayloadLength</td><td>If not nullptr, the payload length of the packet will be written to this pointer. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>True if the packet's payload length is less than or equal to the device MTU. If the packet's length cannot be determined, it will return true if allowUnknownLength is true. </dd></dl>

</div>
</div>
<a id="ae40c27c0bfd5b397af813fd37a819e73"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ae40c27c0bfd5b397af813fd37a819e73">&#9670;&nbsp;</a></span>open() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool pcpp::PcapLiveDevice::open </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">override</span><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Open the device using libpcap pcap_open_live. Opening the device only makes the device ready for use, it doesn't start packet capturing. For packet capturing the user should call <a class="el" href="classpcpp_1_1_pcap_live_device.html#a349b001c38b0f1e43a1691fedbd1b0cc">startCapture()</a>. This implies that calling this method is a must before calling <a class="el" href="classpcpp_1_1_pcap_live_device.html#a349b001c38b0f1e43a1691fedbd1b0cc">startCapture()</a> (otherwise <a class="el" href="classpcpp_1_1_pcap_live_device.html#a349b001c38b0f1e43a1691fedbd1b0cc">startCapture()</a> will fail with a "device not open" error). The device is opened in promiscuous mode </p><dl class="section return"><dt>Returns</dt><dd>True if the device was opened successfully, false otherwise. When opening the device fails an error will be printed to log as well </dd></dl>

<p>Implements <a class="el" href="classpcpp_1_1_i_device.html#ad7bed3f1134e8b4329295b4af6733b9f">pcpp::IDevice</a>.</p>

<p>Reimplemented in <a class="el" href="classpcpp_1_1_pcap_remote_device.html#a100631422d0528e12c0184ddd79f7c06">pcpp::PcapRemoteDevice</a>.</p>

</div>
</div>
<a id="a3f58e22a71cbed9109ae75bd1759e8ed"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a3f58e22a71cbed9109ae75bd1759e8ed">&#9670;&nbsp;</a></span>open() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool pcpp::PcapLiveDevice::open </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="structpcpp_1_1_pcap_live_device_1_1_device_configuration.html">DeviceConfiguration</a> &amp;&#160;</td>
          <td class="paramname"><em>config</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Enables to open a device in a non-default configuration. Configuration has parameters like packet buffer timeout &amp; size, open in promiscuous/non-promiscuous mode, etc. Please check <a class="el" href="structpcpp_1_1_pcap_live_device_1_1_device_configuration.html">DeviceConfiguration</a> for more details </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">config</td><td>The requested configuration </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Same as <a class="el" href="classpcpp_1_1_pcap_live_device.html#ae40c27c0bfd5b397af813fd37a819e73">open()</a> </dd></dl>

</div>
</div>
<a id="af9eb88d92d3221c6edb0da7b181869cc"></a>
<h2 class="memtitle"><span class="permalink"><a href="#af9eb88d92d3221c6edb0da7b181869cc">&#9670;&nbsp;</a></span>prepareCapture()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual void pcpp::PcapLiveDevice::prepareCapture </td>
          <td>(</td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>asyncCapture</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>captureStats</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">protected</span><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Called before starting a capture to prepare the device for capturing packets. </p>
<p>This method can be overridden by derived classes to perform additional preparations before starting the packet capture.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">asyncCapture</td><td>True if the capture is asynchronous (i.e. packets are captured in a separate thread), </td></tr>
    <tr><td class="paramname">captureStats</td><td>True if statistics should be captured during the capture process. </td></tr>
  </table>
  </dd>
</dl>

<p>Reimplemented in <a class="el" href="classpcpp_1_1_win_pcap_live_device.html#aad3ce3cfe5b02316936a986a4f270da2">pcpp::WinPcapLiveDevice</a>.</p>

</div>
</div>
<a id="a62c57a5a0fd0427188e4c89ac87f12d8"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a62c57a5a0fd0427188e4c89ac87f12d8">&#9670;&nbsp;</a></span>sendPacket() <span class="overload">[1/5]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool pcpp::PcapLiveDevice::sendPacket </td>
          <td>(</td>
          <td class="paramtype">const uint8_t *&#160;</td>
          <td class="paramname"><em>packetData</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>packetDataLength</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>checkMtu</em> = <code>false</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="namespacepcpp.html#ab3f43dd3ccd8c93acac8b67909be02be">pcpp::LinkLayerType</a>&#160;</td>
          <td class="paramname"><em>linkType</em> = <code><a class="el" href="namespacepcpp.html#ab3f43dd3ccd8c93acac8b67909be02bea4a7bd3283e7f9b30aa9e71e7807de215">pcpp::LINKTYPE_ETHERNET</a></code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Send a buffer containing packet raw data (including all layers) to the network </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">packetData</td><td>The buffer containing the packet raw data </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">packetDataLength</td><td>The length of the buffer </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">checkMtu</td><td>Whether the length of the packet's payload should be checked against the MTU. If enabled this comes with a small performance penalty. Default value is false to avoid performance overhead. Set to true if you don't know whether packets fit the live device's MTU and you can afford the overhead. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">linkType</td><td>Only used if checkMtu is true. Defines the layer type for parsing the first layer of the packet. Used for parsing the packet to perform the MTU check. Default value is <a class="el" href="namespacepcpp.html#ab3f43dd3ccd8c93acac8b67909be02bea4a7bd3283e7f9b30aa9e71e7807de215" title="IEEE 802.3 Ethernet.">pcpp::LINKTYPE_ETHERNET</a>. Ensure this parameter matches the linktype of the packet if checkMtu is true. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>True if packet was sent successfully. False will be returned in the following cases (relevant log error is printed in any case):<ul>
<li>Device is not opened</li>
<li><a class="el" href="classpcpp_1_1_packet.html">Packet</a> length is 0</li>
<li><a class="el" href="classpcpp_1_1_packet.html">Packet</a> length is larger than device MTU and checkMtu is true</li>
<li><a class="el" href="classpcpp_1_1_packet.html">Packet</a> could not be sent due to some error in libpcap/WinPcap/Npcap </li>
</ul>
</dd></dl>

</div>
</div>
<a id="a4e5b87c1864ee727e12bb246b071c964"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a4e5b87c1864ee727e12bb246b071c964">&#9670;&nbsp;</a></span>sendPacket() <span class="overload">[2/5]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool pcpp::PcapLiveDevice::sendPacket </td>
          <td>(</td>
          <td class="paramtype">const uint8_t *&#160;</td>
          <td class="paramname"><em>packetData</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>packetDataLength</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>packetPayloadLength</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Send a buffer containing packet raw data (including all layers) to the network. This particular version of the sendPacket method should only be used if you already have access to the size of the network layer of the packet, since it allows you to check the payload size (see packetPayloadLength parameter) MTU of the live device without incurring a parsing overhead. If the packetPayloadLength is unknown, please use a different implementation of the sendPacket method. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">packetData</td><td>The buffer containing the packet raw data </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">packetDataLength</td><td>The length of the buffer (this is the entire packet, including link layer) </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">packetPayloadLength</td><td>The length of the payload for the data link layer. This includes all data apart from the header for the data link layer. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>True if the packet was sent successfully. False will be returned in the following cases (relevant log error is printed in any case):<ul>
<li>Device is not opened</li>
<li><a class="el" href="classpcpp_1_1_packet.html">Packet</a> data length is 0</li>
<li><a class="el" href="classpcpp_1_1_packet.html">Packet</a> payload length is larger than device MTU</li>
<li><a class="el" href="classpcpp_1_1_packet.html">Packet</a> could not be sent due to some error in libpcap/WinPcap/Npcap </li>
</ul>
</dd></dl>

</div>
</div>
<a id="a9d8a41394806dd5e5245046908f60f16"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a9d8a41394806dd5e5245046908f60f16">&#9670;&nbsp;</a></span>sendPacket() <span class="overload">[3/5]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool pcpp::PcapLiveDevice::sendPacket </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classpcpp_1_1_packet.html">Packet</a> *&#160;</td>
          <td class="paramname"><em>packet</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>checkMtu</em> = <code>true</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Send a parsed <a class="el" href="classpcpp_1_1_packet.html">Packet</a> to the network </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">packet</td><td>A pointer to the packet to send. This method treats the packet as read-only, it doesn't change anything in it </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">checkMtu</td><td>Whether the length of the packet's payload should be checked against the MTU. Default value is true, since the packet being passed in has already been parsed, so checking the MTU does not incur significant processing overhead. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>True if packet was sent successfully. False will be returned in the following cases (relevant log error is printed in any case):<ul>
<li>Device is not opened</li>
<li><a class="el" href="classpcpp_1_1_packet.html">Packet</a> length is 0</li>
<li><a class="el" href="classpcpp_1_1_packet.html">Packet</a> length is larger than device MTU and checkMtu is true</li>
<li><a class="el" href="classpcpp_1_1_packet.html">Packet</a> could not be sent due to some error in libpcap/WinPcap/Npcap </li>
</ul>
</dd></dl>
<dl class="deprecated"><dt><b><a class="el" href="deprecated.html#_deprecated000015">Deprecated:</a></b></dt><dd>This method is deprecated. Use <a class="el" href="classpcpp_1_1_pcap_live_device.html#a89a20db2f68dcba1675a4895f03180bb">sendPacket(Packet const&amp; packet, bool checkMtu)</a> instead. </dd></dl>

</div>
</div>
<a id="a89a20db2f68dcba1675a4895f03180bb"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a89a20db2f68dcba1675a4895f03180bb">&#9670;&nbsp;</a></span>sendPacket() <span class="overload">[4/5]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool pcpp::PcapLiveDevice::sendPacket </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classpcpp_1_1_packet.html">Packet</a> const &amp;&#160;</td>
          <td class="paramname"><em>packet</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>checkMtu</em> = <code>true</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Send a parsed <a class="el" href="classpcpp_1_1_packet.html">Packet</a> to the network </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">packet</td><td>A reference to the packet to send. This method treats the packet as read-only, it doesn't change anything in it </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">checkMtu</td><td>Whether the length of the packet's payload should be checked against the MTU. Default value is true, since the packet being passed in has already been parsed, so checking the MTU does not incur significant processing overhead. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>True if packet was sent successfully. False will be returned in the following cases (relevant log error is printed in any case):<ul>
<li>Device is not opened</li>
<li><a class="el" href="classpcpp_1_1_packet.html">Packet</a> length is 0</li>
<li><a class="el" href="classpcpp_1_1_packet.html">Packet</a> length is larger than device MTU and checkMtu is true</li>
<li><a class="el" href="classpcpp_1_1_packet.html">Packet</a> could not be sent due to some error in libpcap/WinPcap/Npcap </li>
</ul>
</dd></dl>

</div>
</div>
<a id="a2ec557886562d8af27bb7bce07016544"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a2ec557886562d8af27bb7bce07016544">&#9670;&nbsp;</a></span>sendPacket() <span class="overload">[5/5]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool pcpp::PcapLiveDevice::sendPacket </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classpcpp_1_1_raw_packet.html">RawPacket</a> const &amp;&#160;</td>
          <td class="paramname"><em>rawPacket</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>checkMtu</em> = <code>false</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Send a <a class="el" href="classpcpp_1_1_raw_packet.html">RawPacket</a> to the network </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">rawPacket</td><td>A reference to the raw packet to send. This method treats the raw packet as read-only, it doesn't change anything in it </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">checkMtu</td><td>Whether the length of the packet's payload should be checked against the MTU. If enabled this comes with a small performance penalty. Default value is false to avoid performance overhead. Set to true if you don't know whether packets fit the live device's MTU and you can afford the overhead. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>True if packet was sent successfully. False will be returned in the following cases (relevant log error is printed in any case):<ul>
<li>Device is not opened</li>
<li><a class="el" href="classpcpp_1_1_packet.html">Packet</a> length is 0</li>
<li><a class="el" href="classpcpp_1_1_packet.html">Packet</a> length is larger than device MTU</li>
<li><a class="el" href="classpcpp_1_1_packet.html">Packet</a> could not be sent due to some error in libpcap/WinPcap/Npcap </li>
</ul>
</dd></dl>

</div>
</div>
<a id="a9fb54c1f769a409743c6710f02b4de56"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a9fb54c1f769a409743c6710f02b4de56">&#9670;&nbsp;</a></span>sendPackets() <span class="overload">[1/3]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual int pcpp::PcapLiveDevice::sendPackets </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="namespacepcpp.html#a4c0775fb93a0867d2afa7992d55957f0">RawPacketVector</a> &amp;&#160;</td>
          <td class="paramname"><em>rawPackets</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>checkMtu</em> = <code>false</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Send a vector of pointers to <a class="el" href="classpcpp_1_1_raw_packet.html">RawPacket</a> objects to the network </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">rawPackets</td><td>The array of pointers to <a class="el" href="classpcpp_1_1_raw_packet.html">RawPacket</a> objects to send. This method treats all packets as read-only, it doesn't change anything in them </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">checkMtu</td><td>Whether to check the size of the packet payload against MTU size. Incurs a parsing overhead. Default value is false to avoid performance overhead. Set to true if you don't know whether packets fit the live device's MTU and you can afford the overhead. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The number of packets sent successfully. Sending a packet can fail if:<ul>
<li>Device is not opened. In this case no packets will be sent, return value will be 0</li>
<li><a class="el" href="classpcpp_1_1_packet.html">Packet</a> length is 0</li>
<li><a class="el" href="classpcpp_1_1_packet.html">Packet</a> length is larger than device MTU and checkMtu is true</li>
<li><a class="el" href="classpcpp_1_1_packet.html">Packet</a> could not be sent due to some error in libpcap/WinPcap/Npcap </li>
</ul>
</dd></dl>

</div>
</div>
<a id="a71eb799bb039b9b4b182958bf5fdf563"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a71eb799bb039b9b4b182958bf5fdf563">&#9670;&nbsp;</a></span>sendPackets() <span class="overload">[2/3]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual int pcpp::PcapLiveDevice::sendPackets </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classpcpp_1_1_packet.html">Packet</a> **&#160;</td>
          <td class="paramname"><em>packetsArr</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>arrLength</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>checkMtu</em> = <code>true</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Send an array of pointers to <a class="el" href="classpcpp_1_1_packet.html">Packet</a> objects to the network </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">packetsArr</td><td>The array of pointers to <a class="el" href="classpcpp_1_1_packet.html">Packet</a> objects to send. This method treats all packets as read-only, it doesn't change anything in them </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">arrLength</td><td>The length of the array </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">checkMtu</td><td>Whether to check the size of the packet payload against MTU size. Default value is true, since the packets being passed in has already been parsed, so checking the MTU does not incur significant processing overhead. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The number of packets sent successfully. Sending a packet can fail if:<ul>
<li>Device is not opened. In this case no packets will be sent, return value will be 0</li>
<li><a class="el" href="classpcpp_1_1_packet.html">Packet</a> length is 0</li>
<li><a class="el" href="classpcpp_1_1_packet.html">Packet</a> length is larger than device MTU and checkMtu is true</li>
<li><a class="el" href="classpcpp_1_1_packet.html">Packet</a> could not be sent due to some error in libpcap/WinPcap/Npcap </li>
</ul>
</dd></dl>

</div>
</div>
<a id="aa11efe575402d9e06624376d87caf4fb"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aa11efe575402d9e06624376d87caf4fb">&#9670;&nbsp;</a></span>sendPackets() <span class="overload">[3/3]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual int pcpp::PcapLiveDevice::sendPackets </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classpcpp_1_1_raw_packet.html">RawPacket</a> *&#160;</td>
          <td class="paramname"><em>rawPacketsArr</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>arrLength</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>checkMtu</em> = <code>false</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Send an array of <a class="el" href="classpcpp_1_1_raw_packet.html">RawPacket</a> objects to the network </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">rawPacketsArr</td><td>The array of <a class="el" href="classpcpp_1_1_raw_packet.html">RawPacket</a> objects to send. This method treats all packets as read-only, it doesn't change anything in them </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">arrLength</td><td>The length of the array </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">checkMtu</td><td>Whether to check the size of the packet payload against MTU size. Incurs a parsing overhead. Default value is false to avoid performance overhead. Set to true if you don't know whether packets fit the live device's MTU and you can afford the overhead. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The number of packets sent successfully. Sending a packet can fail if:<ul>
<li>Device is not opened. In this case no packets will be sent, return value will be 0</li>
<li><a class="el" href="classpcpp_1_1_packet.html">Packet</a> length is 0</li>
<li><a class="el" href="classpcpp_1_1_packet.html">Packet</a> length is larger than device MTU and checkMtu is true</li>
<li><a class="el" href="classpcpp_1_1_packet.html">Packet</a> could not be sent due to some error in libpcap/WinPcap/Npcap </li>
</ul>
</dd></dl>

</div>
</div>
<a id="a2933139d284d7c167283982ec8b56559"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a2933139d284d7c167283982ec8b56559">&#9670;&nbsp;</a></span>startCapture() <span class="overload">[1/4]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual bool pcpp::PcapLiveDevice::startCapture </td>
          <td>(</td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>intervalInSecondsToUpdateStats</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="namespacepcpp.html#a83363d443da98e485f8edb46a4184779">OnStatsUpdateCallback</a>&#160;</td>
          <td class="paramname"><em>onStatsUpdate</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">void *&#160;</td>
          <td class="paramname"><em>onStatsUpdateUserCookie</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Start capturing packets on this network interface (device) with periodic stats collection only. This means that packets arriving to the network interface aren't delivered to the user but only counted. Each intervalInSecondsToUpdateStats seconds stats are collected from the device and the onStatsUpdate callback is called with the updated counters. The periodic stats collection is done on a new thread created by this method, meaning all callback calls are done in threads other than the caller thread. Stats collection will stop and threads will be terminated when calling <a class="el" href="classpcpp_1_1_pcap_live_device.html#a818da3e11e0c953385badf6233ee0f43">stopCapture()</a>. This method must be called after the device is opened (i.e the <a class="el" href="classpcpp_1_1_pcap_live_device.html#ae40c27c0bfd5b397af813fd37a819e73">open()</a> method was called), otherwise an error will be returned. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">intervalInSecondsToUpdateStats</td><td>The interval in seconds to activate periodic stats collection </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">onStatsUpdate</td><td>A callback that will be called each time intervalInSecondsToUpdateStats expires and stats are collected. This callback will contain the collected stats </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">onStatsUpdateUserCookie</td><td>A pointer to a user provided object. This object will be transferred to the onStatsUpdate callback each time it is called </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>True if capture started successfully, false if (relevant log error is printed in any case):<ul>
<li>Capture is already running</li>
<li>Device is not opened</li>
<li>Stats collection thread could not be created </li>
</ul>
</dd></dl>
<dl class="section remark"><dt>Remarks</dt><dd>This method is planned for conversion to non-virtual in the future, so it should not be overridden. </dd></dl>

</div>
</div>
<a id="a349b001c38b0f1e43a1691fedbd1b0cc"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a349b001c38b0f1e43a1691fedbd1b0cc">&#9670;&nbsp;</a></span>startCapture() <span class="overload">[2/4]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual bool pcpp::PcapLiveDevice::startCapture </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="namespacepcpp.html#a700592e5086544411957be0242dec0f5">OnPacketArrivesCallback</a>&#160;</td>
          <td class="paramname"><em>onPacketArrives</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">void *&#160;</td>
          <td class="paramname"><em>onPacketArrivesUserCookie</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Start capturing packets on this network interface (device). Each time a packet is captured the onPacketArrives callback is called. The capture is done on a new thread created by this method, meaning all callback calls are done in a thread other than the caller thread. Capture process will stop and this capture thread will be terminated when calling <a class="el" href="classpcpp_1_1_pcap_live_device.html#a818da3e11e0c953385badf6233ee0f43">stopCapture()</a>. This method must be called after the device is opened (i.e the <a class="el" href="classpcpp_1_1_pcap_live_device.html#ae40c27c0bfd5b397af813fd37a819e73">open()</a> method was called), otherwise an error will be returned. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">onPacketArrives</td><td>A callback that is called each time a packet is captured </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">onPacketArrivesUserCookie</td><td>A pointer to a user provided object. This object will be transferred to the onPacketArrives callback each time it is called. This cookie is very useful for transferring objects that give context to the capture callback, for example: objects that counts packets, manages flow state or manages the application state according to the packet that was captured </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>True if capture started successfully, false if (relevant log error is printed in any case):<ul>
<li>Capture is already running</li>
<li>Device is not opened</li>
<li>Capture thread could not be created </li>
</ul>
</dd></dl>
<dl class="section remark"><dt>Remarks</dt><dd>This method is planned for conversion to non-virtual in the future, so it should not be overridden. </dd></dl>

</div>
</div>
<a id="a78306fe44879e457df4043a117f6863a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a78306fe44879e457df4043a117f6863a">&#9670;&nbsp;</a></span>startCapture() <span class="overload">[3/4]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual bool pcpp::PcapLiveDevice::startCapture </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="namespacepcpp.html#a700592e5086544411957be0242dec0f5">OnPacketArrivesCallback</a>&#160;</td>
          <td class="paramname"><em>onPacketArrives</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">void *&#160;</td>
          <td class="paramname"><em>onPacketArrivesUserCookie</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>intervalInSecondsToUpdateStats</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="namespacepcpp.html#a83363d443da98e485f8edb46a4184779">OnStatsUpdateCallback</a>&#160;</td>
          <td class="paramname"><em>onStatsUpdate</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">void *&#160;</td>
          <td class="paramname"><em>onStatsUpdateUserCookie</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Start capturing packets on this network interface (device) with periodic stats collection. Each time a packet is captured the onPacketArrives callback is called. In addition, each intervalInSecondsToUpdateStats seconds stats are collected from the device and the onStatsUpdate callback is called. Both the capture and periodic stats collection are done on new threads created by this method, each on a different thread, meaning all callback calls are done in threads other than the caller thread. Capture process and stats collection will stop and threads will be terminated when calling <a class="el" href="classpcpp_1_1_pcap_live_device.html#a818da3e11e0c953385badf6233ee0f43">stopCapture()</a>. This method must be called after the device is opened (i.e the <a class="el" href="classpcpp_1_1_pcap_live_device.html#ae40c27c0bfd5b397af813fd37a819e73">open()</a> method was called), otherwise an error will be returned. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">onPacketArrives</td><td>A callback that is called each time a packet is captured </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">onPacketArrivesUserCookie</td><td>A pointer to a user provided object. This object will be transferred to the onPacketArrives callback each time it is called. This cookie is very useful for transferring objects that give context to the capture callback, for example: objects that counts packets, manages flow state or manages the application state according to the packet that was captured </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">intervalInSecondsToUpdateStats</td><td>The interval in seconds to activate periodic stats collection </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">onStatsUpdate</td><td>A callback that will be called each time intervalInSecondsToUpdateStats expires and stats are collected. This callback will contain the collected stats </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">onStatsUpdateUserCookie</td><td>A pointer to a user provided object. This object will be transferred to the onStatsUpdate callback each time it is called </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>True if capture started successfully, false if (relevant log error is printed in any case):<ul>
<li>Capture is already running</li>
<li>Device is not opened</li>
<li>Capture thread could not be created</li>
<li>Stats collection thread could not be created </li>
</ul>
</dd></dl>
<dl class="section remark"><dt>Remarks</dt><dd>This method is planned for conversion to non-virtual in the future, so it should not be overridden. </dd></dl>

</div>
</div>
<a id="a821bbac1ffad5a75c6a0be1ff362eb9f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a821bbac1ffad5a75c6a0be1ff362eb9f">&#9670;&nbsp;</a></span>startCapture() <span class="overload">[4/4]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual bool pcpp::PcapLiveDevice::startCapture </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="namespacepcpp.html#a4c0775fb93a0867d2afa7992d55957f0">RawPacketVector</a> &amp;&#160;</td>
          <td class="paramname"><em>capturedPacketsVector</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Start capturing packets on this network interface (device). All captured packets are added to capturedPacketsVector, so at the end of the capture (when calling <a class="el" href="classpcpp_1_1_pcap_live_device.html#a818da3e11e0c953385badf6233ee0f43">stopCapture()</a>) this vector contains pointers to all captured packets in the form of <a class="el" href="classpcpp_1_1_raw_packet.html">RawPacket</a>. The capture is done on a new thread created by this method, meaning capturedPacketsVector is updated from another thread other than the caller thread (so user should avoid changing or iterating this vector while capture is on). Capture process will stop and this capture thread will be terminated when calling <a class="el" href="classpcpp_1_1_pcap_live_device.html#a818da3e11e0c953385badf6233ee0f43">stopCapture()</a>. This method must be called after the device is opened (i.e the <a class="el" href="classpcpp_1_1_pcap_live_device.html#ae40c27c0bfd5b397af813fd37a819e73">open()</a> method was called), otherwise an error will be returned. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">capturedPacketsVector</td><td>A reference to a RawPacketVector, meaning a vector of pointer to <a class="el" href="classpcpp_1_1_raw_packet.html">RawPacket</a> objects </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>True if capture started successfully, false if (relevant log error is printed in any case):<ul>
<li>Capture is already running</li>
<li>Device is not opened</li>
<li>Capture thread could not be created </li>
</ul>
</dd></dl>
<dl class="section remark"><dt>Remarks</dt><dd>This method is planned for conversion to non-virtual in the future, so it should not be overridden. </dd></dl>

</div>
</div>
<a id="a1948c03b6471a5dcea064a7a8950a0a0"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a1948c03b6471a5dcea064a7a8950a0a0">&#9670;&nbsp;</a></span>startCaptureBlockingMode()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual int pcpp::PcapLiveDevice::startCaptureBlockingMode </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="namespacepcpp.html#a6a83c8855a6bb3681fafec04b00a6339">OnPacketArrivesStopBlocking</a>&#160;</td>
          <td class="paramname"><em>onPacketArrives</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">void *&#160;</td>
          <td class="paramname"><em>userCookie</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const double&#160;</td>
          <td class="paramname"><em>timeout</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Start capturing packets on this network interface (device) in blocking mode, meaning this method blocks and won't return until the user frees the blocking (via onPacketArrives callback) or until a user defined timeout expires. Whenever a packets is captured the onPacketArrives callback is called and lets the user handle the packet. In each callback call the user should return true if he wants to release the block or false if it wants it to keep blocking. Regardless of this callback a timeout is defined when start capturing. When this timeout expires the method will return.<br  />
 Please notice that <a class="el" href="classpcpp_1_1_pcap_live_device.html#a818da3e11e0c953385badf6233ee0f43">stopCapture()</a> isn't needed here because when the method returns (after timeout or per user decision) capturing on the device is stopped </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">onPacketArrives</td><td>A callback given by the user for handling incoming packets. After handling each packet the user needs to return a boolean value. True value indicates stop capturing and stop blocking and false value indicates continue capturing and blocking </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">userCookie</td><td>A pointer to a user provided object. This object will be transferred to the onPacketArrives callback each time it is called. This cookie is very useful for transferring objects that give context to the capture callback, for example: objects that counts packets, manages flow state or manages the application state according to the packet that was captured </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">timeout</td><td>A timeout in seconds for the blocking to stop even if the user didn't return "true" in the onPacketArrives callback. The precision of <code>timeout</code> is millisecond, e.g. 2.345 seconds means 2345 milliseconds. If this timeout is set to 0 or less the timeout will be ignored, meaning the method will keep handling packets until the <code>onPacketArrives</code> callback returns <code>true</code>. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>-1 if timeout expired, 1 if blocking was stopped via onPacketArrives callback or 0 if an error occurred (such as device not open etc.). When returning 0 an appropriate error message is printed to log </dd></dl>
<dl class="section note"><dt>Note</dt><dd>On Unix-like systems, enabling the <code>usePoll</code> option in <code><a class="el" href="structpcpp_1_1_pcap_live_device_1_1_device_configuration.html">DeviceConfiguration</a></code> prevents the method from blocking indefinitely when no packets are available, even if a timeout is set. </dd></dl>
<dl class="section remark"><dt>Remarks</dt><dd>This method is planned for conversion to non-virtual in the future, so it should not be overridden. </dd></dl>

</div>
</div>
<a id="a818da3e11e0c953385badf6233ee0f43"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a818da3e11e0c953385badf6233ee0f43">&#9670;&nbsp;</a></span>stopCapture()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void pcpp::PcapLiveDevice::stopCapture </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Stop a currently running packet capture. This method terminates gracefully both packet capture thread and periodic stats collection thread (both if exist) </p><dl class="section remark"><dt>Remarks</dt><dd>This method should not be called from the onPacketArrives callback, as it will cause a deadlock. </dd></dl>

</div>
</div>
</div><!-- contents -->
</div><!-- doc-content -->
<!-- start footer part -->
<div id="nav-path" class="navpath"><!-- id is needed for treeview function! -->
  <ul>
    <li class="navelem"><a class="el" href="namespacepcpp.html">pcpp</a></li><li class="navelem"><a class="el" href="classpcpp_1_1_pcap_live_device.html">PcapLiveDevice</a></li>
    <li class="footer">Generated on Tue Jul 22 2025 08:34:55 for PcapPlusPlus by <a href="https://www.doxygen.org/index.html"><img class="footer" src="doxygen.svg" width="104" height="31" alt="doxygen"/></a> 1.9.1 </li>
  </ul>
</div>
</body>
</html>
