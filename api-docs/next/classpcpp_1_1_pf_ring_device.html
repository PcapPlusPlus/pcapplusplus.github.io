<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "https://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=9"/>
<meta name="generator" content="Doxygen 1.9.1"/>
<meta name="viewport" content="width=device-width, initial-scale=1"/>
<title>PcapPlusPlus: pcpp::PfRingDevice Class Reference</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<link href="navtree.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="resize.js"></script>
<script type="text/javascript" src="navtreedata.js"></script>
<script type="text/javascript" src="navtree.js"></script>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/searchdata.js"></script>
<script type="text/javascript" src="search/search.js"></script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
<link href="doxygen-mobile.css" rel="stylesheet" type="text/css"/>
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr style="height: 56px;">
  <td id="projectlogo"><img alt="Logo" src="logo_icon_large.ico"/></td>
  <td id="projectalign" style="padding-left: 0.5em;">
   <div id="projectname">PcapPlusPlus
   &#160;<span id="projectnumber">Next</span>
   </div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.9.1 -->
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:cf05388f2679ee054f2beb29a391d25f4e673ac3&amp;dn=gpl-2.0.txt GPL-v2 */
var searchBox = new SearchBox("searchBox", "search",false,'Search','.html');
/* @license-end */
</script>
<script type="text/javascript" src="menudata.js"></script>
<script type="text/javascript" src="menu.js"></script>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:cf05388f2679ee054f2beb29a391d25f4e673ac3&amp;dn=gpl-2.0.txt GPL-v2 */
$(function() {
  initMenu('',true,false,'search.php','Search');
  $(document).ready(function() { init_search(); });
});
/* @license-end */</script>
<div id="main-nav"></div>
</div><!-- top -->
<div id="side-nav" class="ui-resizable side-nav-resizable">
  <div id="nav-tree">
    <div id="nav-tree-contents">
      <div id="nav-sync" class="sync"></div>
    </div>
  </div>
  <div id="splitbar" style="-moz-user-select:none;" 
       class="ui-resizable-handle">
  </div>
</div>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:cf05388f2679ee054f2beb29a391d25f4e673ac3&amp;dn=gpl-2.0.txt GPL-v2 */
$(document).ready(function(){initNavTree('classpcpp_1_1_pf_ring_device.html',''); initResizable(); });
/* @license-end */
</script>
<div id="doc-content">
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
</div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<iframe src="javascript:void(0)" frameborder="0" 
        name="MSearchResults" id="MSearchResults">
</iframe>
</div>

<div class="header">
  <div class="summary">
<a href="#nested-classes">Classes</a> &#124;
<a href="#pub-types">Public Types</a> &#124;
<a href="#pub-methods">Public Member Functions</a> &#124;
<a href="classpcpp_1_1_pf_ring_device-members.html">List of all members</a>  </div>
  <div class="headertitle">
<div class="title">pcpp::PfRingDevice Class Reference</div>  </div>
</div><!--header-->
<div class="contents">

<p><code>#include &lt;<a class="el" href="_pf_ring_device_8h_source.html">PfRingDevice.h</a>&gt;</code></p>
<div class="dynheader">
Inheritance diagram for pcpp::PfRingDevice:</div>
<div class="dyncontent">
 <div class="center">
  <img src="classpcpp_1_1_pf_ring_device.png" usemap="#pcpp::PfRingDevice_map" alt=""/>
  <map id="pcpp::PfRingDevice_map" name="pcpp::PfRingDevice_map">
<area href="classpcpp_1_1_i_device.html" alt="pcpp::IDevice" shape="rect" coords="0,0,142,24"/>
<area href="classpcpp_1_1_i_filterable_device.html" alt="pcpp::IFilterableDevice" shape="rect" coords="152,0,294,24"/>
  </map>
</div></div>
<table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="nested-classes"></a>
Classes</h2></td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structpcpp_1_1_pf_ring_device_1_1_pf_ring_stats.html">PfRingStats</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="pub-types"></a>
Public Types</h2></td></tr>
<tr class="memitem:a2a7113725490fea52c9702998e6a8f78"><td class="memItemLeft" align="right" valign="top">enum &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classpcpp_1_1_pf_ring_device.html#a2a7113725490fea52c9702998e6a8f78">ChannelDistribution</a> { <a class="el" href="classpcpp_1_1_pf_ring_device.html#a2a7113725490fea52c9702998e6a8f78a707c1b0c55e37f2cb7d4978370332712">RoundRobin</a>
, <a class="el" href="classpcpp_1_1_pf_ring_device.html#a2a7113725490fea52c9702998e6a8f78a7b91b5daaad7f4b2f754afa4b69f48b6">PerFlow</a>
 }</td></tr>
<tr class="memdesc:a2a7113725490fea52c9702998e6a8f78"><td class="mdescLeft">&#160;</td><td class="mdescRight">An enum representing the type of packet distribution between different RX channels.  <a href="classpcpp_1_1_pf_ring_device.html#a2a7113725490fea52c9702998e6a8f78">More...</a><br /></td></tr>
<tr class="separator:a2a7113725490fea52c9702998e6a8f78"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="pub-methods"></a>
Public Member Functions</h2></td></tr>
<tr class="memitem:a72463fcbd7eae62523c58fec6ecd2385"><td class="memItemLeft" align="right" valign="top"><a id="a72463fcbd7eae62523c58fec6ecd2385"></a>
&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classpcpp_1_1_pf_ring_device.html#a72463fcbd7eae62523c58fec6ecd2385">~PfRingDevice</a> ()</td></tr>
<tr class="memdesc:a72463fcbd7eae62523c58fec6ecd2385"><td class="mdescLeft">&#160;</td><td class="mdescRight">A destructor for <a class="el" href="classpcpp_1_1_pf_ring_device.html">PfRingDevice</a> class. <br /></td></tr>
<tr class="separator:a72463fcbd7eae62523c58fec6ecd2385"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab3f349a204036f5de153e5a45e1a4f50"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classpcpp_1_1_mac_address.html">MacAddress</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classpcpp_1_1_pf_ring_device.html#ab3f349a204036f5de153e5a45e1a4f50">getMacAddress</a> ()</td></tr>
<tr class="separator:ab3f349a204036f5de153e5a45e1a4f50"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9d939956173c6246d02aa5bcbc576c0f"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classpcpp_1_1_pf_ring_device.html#a9d939956173c6246d02aa5bcbc576c0f">getInterfaceIndex</a> ()</td></tr>
<tr class="separator:a9d939956173c6246d02aa5bcbc576c0f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3a783b9949814723e1e3e7dc76c5e4fc"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classpcpp_1_1_pf_ring_device.html#a3a783b9949814723e1e3e7dc76c5e4fc">getMtu</a> ()</td></tr>
<tr class="separator:a3a783b9949814723e1e3e7dc76c5e4fc"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3d897e1f5c1f9ef15987b82eff1a736b"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classpcpp_1_1_pf_ring_device.html#a3d897e1f5c1f9ef15987b82eff1a736b">isHwClockEnabledForDevice</a> ()</td></tr>
<tr class="separator:a3d897e1f5c1f9ef15987b82eff1a736b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9ac18b4561b579975dfd6c89722eab9e"><td class="memItemLeft" align="right" valign="top">std::string&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classpcpp_1_1_pf_ring_device.html#a9ac18b4561b579975dfd6c89722eab9e">getDeviceName</a> () const</td></tr>
<tr class="separator:a9ac18b4561b579975dfd6c89722eab9e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2d15fc696287e4a5dc16bd809fdce893"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classpcpp_1_1_pf_ring_device.html#a2d15fc696287e4a5dc16bd809fdce893">startCaptureSingleThread</a> (OnPfRingPacketsArriveCallback onPacketsArrive, void *onPacketsArriveUserCookie)</td></tr>
<tr class="separator:a2d15fc696287e4a5dc16bd809fdce893"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2267f74af554b8651d771ab7f453dc50"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classpcpp_1_1_pf_ring_device.html#a2267f74af554b8651d771ab7f453dc50">startCaptureMultiThread</a> (OnPfRingPacketsArriveCallback onPacketsArrive, void *onPacketsArriveUserCookie, CoreMask coreMask)</td></tr>
<tr class="separator:a2267f74af554b8651d771ab7f453dc50"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a31d086cb96e4e8de1e1d5ee640812575"><td class="memItemLeft" align="right" valign="top"><a id="a31d086cb96e4e8de1e1d5ee640812575"></a>
void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classpcpp_1_1_pf_ring_device.html#a31d086cb96e4e8de1e1d5ee640812575">stopCapture</a> ()</td></tr>
<tr class="memdesc:a31d086cb96e4e8de1e1d5ee640812575"><td class="mdescLeft">&#160;</td><td class="mdescRight">Stops capturing packets (works will all type of startCapture*) <br /></td></tr>
<tr class="separator:a31d086cb96e4e8de1e1d5ee640812575"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4a06e5e4364538de4b4fc71df0153c27"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classpcpp_1_1_pf_ring_device.html#a4a06e5e4364538de4b4fc71df0153c27">openSingleRxChannel</a> (uint8_t channelId)</td></tr>
<tr class="separator:a4a06e5e4364538de4b4fc71df0153c27"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a923fa6c928456417a5985be210e3e487"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classpcpp_1_1_pf_ring_device.html#a923fa6c928456417a5985be210e3e487">openMultiRxChannels</a> (const uint8_t *channelIds, int numOfChannelIds)</td></tr>
<tr class="separator:a923fa6c928456417a5985be210e3e487"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a42fa0b515215e8801f3e5f955dff095c"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classpcpp_1_1_pf_ring_device.html#a42fa0b515215e8801f3e5f955dff095c">openMultiRxChannels</a> (uint8_t numOfRxChannelsToOpen, <a class="el" href="classpcpp_1_1_pf_ring_device.html#a2a7113725490fea52c9702998e6a8f78">ChannelDistribution</a> dist)</td></tr>
<tr class="separator:a42fa0b515215e8801f3e5f955dff095c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9954fb008030336858d57be7f3ccbc78"><td class="memItemLeft" align="right" valign="top">uint8_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classpcpp_1_1_pf_ring_device.html#a9954fb008030336858d57be7f3ccbc78">getNumOfOpenedRxChannels</a> () const</td></tr>
<tr class="separator:a9954fb008030336858d57be7f3ccbc78"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a540956cbcbac10ca854a76e15227aec1"><td class="memItemLeft" align="right" valign="top">uint8_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classpcpp_1_1_pf_ring_device.html#a540956cbcbac10ca854a76e15227aec1">getTotalNumOfRxChannels</a> () const</td></tr>
<tr class="separator:a540956cbcbac10ca854a76e15227aec1"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa7a1e30e857daf58422bbf82b57c68d5"><td class="memItemLeft" align="right" valign="top"><a class="el" href="structpcpp_1_1_system_core.html">SystemCore</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classpcpp_1_1_pf_ring_device.html#aa7a1e30e857daf58422bbf82b57c68d5">getCurrentCoreId</a> () const</td></tr>
<tr class="separator:aa7a1e30e857daf58422bbf82b57c68d5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6953e3efa57b5a8698586db135d87569"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classpcpp_1_1_pf_ring_device.html#a6953e3efa57b5a8698586db135d87569">getThreadStatistics</a> (<a class="el" href="structpcpp_1_1_system_core.html">SystemCore</a> core, <a class="el" href="structpcpp_1_1_pf_ring_device_1_1_pf_ring_stats.html">PfRingStats</a> &amp;stats) const</td></tr>
<tr class="separator:a6953e3efa57b5a8698586db135d87569"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab087acddadc1c3f65058f4cf54b09c78"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classpcpp_1_1_pf_ring_device.html#ab087acddadc1c3f65058f4cf54b09c78">getCurrentThreadStatistics</a> (<a class="el" href="structpcpp_1_1_pf_ring_device_1_1_pf_ring_stats.html">PfRingStats</a> &amp;stats) const</td></tr>
<tr class="separator:ab087acddadc1c3f65058f4cf54b09c78"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aeade33242ac31b8e7ddff4888853cc19"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classpcpp_1_1_pf_ring_device.html#aeade33242ac31b8e7ddff4888853cc19">getStatistics</a> (<a class="el" href="structpcpp_1_1_pf_ring_device_1_1_pf_ring_stats.html">PfRingStats</a> &amp;stats) const</td></tr>
<tr class="separator:aeade33242ac31b8e7ddff4888853cc19"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa4088e46b8bd058c6b0832731586dc51"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classpcpp_1_1_pf_ring_device.html#aa4088e46b8bd058c6b0832731586dc51">isFilterCurrentlySet</a> () const</td></tr>
<tr class="separator:aa4088e46b8bd058c6b0832731586dc51"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1a5f1744d29145bf929e943c02f35a6b"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classpcpp_1_1_pf_ring_device.html#a1a5f1744d29145bf929e943c02f35a6b">sendPacket</a> (const <a class="el" href="classpcpp_1_1_raw_packet.html">RawPacket</a> &amp;rawPacket)</td></tr>
<tr class="separator:a1a5f1744d29145bf929e943c02f35a6b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:abe92b5e338eeb7086527b9f468e1a05e"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classpcpp_1_1_pf_ring_device.html#abe92b5e338eeb7086527b9f468e1a05e">sendPacket</a> (const uint8_t *packetData, int packetDataLength)</td></tr>
<tr class="separator:abe92b5e338eeb7086527b9f468e1a05e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8cbdc286e019385205d4528d80af9484"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classpcpp_1_1_pf_ring_device.html#a8cbdc286e019385205d4528d80af9484">sendPacket</a> (const <a class="el" href="classpcpp_1_1_packet.html">Packet</a> &amp;packet)</td></tr>
<tr class="separator:a8cbdc286e019385205d4528d80af9484"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af825fb6acf7cfbc6da7dd19f854be1ad"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classpcpp_1_1_pf_ring_device.html#af825fb6acf7cfbc6da7dd19f854be1ad">sendPackets</a> (const <a class="el" href="classpcpp_1_1_raw_packet.html">RawPacket</a> *rawPacketsArr, int arrLength)</td></tr>
<tr class="separator:af825fb6acf7cfbc6da7dd19f854be1ad"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8fabac9d1c87b2a6e79d5ce0bbfb7eeb"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classpcpp_1_1_pf_ring_device.html#a8fabac9d1c87b2a6e79d5ce0bbfb7eeb">sendPackets</a> (const <a class="el" href="classpcpp_1_1_packet.html">Packet</a> **packetsArr, int arrLength)</td></tr>
<tr class="separator:a8fabac9d1c87b2a6e79d5ce0bbfb7eeb"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9259bcfd0d7e94822ec2a2930314c52e"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classpcpp_1_1_pf_ring_device.html#a9259bcfd0d7e94822ec2a2930314c52e">sendPackets</a> (const <a class="el" href="namespacepcpp.html#a4c0775fb93a0867d2afa7992d55957f0">RawPacketVector</a> &amp;rawPackets)</td></tr>
<tr class="separator:a9259bcfd0d7e94822ec2a2930314c52e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a94f3512928cf7ccdb4f8a28532c6ee51"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classpcpp_1_1_pf_ring_device.html#a94f3512928cf7ccdb4f8a28532c6ee51">open</a> ()</td></tr>
<tr class="separator:a94f3512928cf7ccdb4f8a28532c6ee51"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad9df26e45654c94c08bfd73c0c18474d"><td class="memItemLeft" align="right" valign="top"><a id="ad9df26e45654c94c08bfd73c0c18474d"></a>
void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classpcpp_1_1_pf_ring_device.html#ad9df26e45654c94c08bfd73c0c18474d">close</a> ()</td></tr>
<tr class="memdesc:ad9df26e45654c94c08bfd73c0c18474d"><td class="mdescLeft">&#160;</td><td class="mdescRight">Closes all RX channels currently opened in device. <br /></td></tr>
<tr class="separator:ad9df26e45654c94c08bfd73c0c18474d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:addd683b41cf717a08248ddf86b08df49"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classpcpp_1_1_pf_ring_device.html#addd683b41cf717a08248ddf86b08df49">setFilter</a> (std::string filterAsString)</td></tr>
<tr class="separator:addd683b41cf717a08248ddf86b08df49"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4077ed601329e70176e0717507a25824"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classpcpp_1_1_pf_ring_device.html#a4077ed601329e70176e0717507a25824">clearFilter</a> ()</td></tr>
<tr class="separator:a4077ed601329e70176e0717507a25824"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af334503822ac7076373c64109f3e6d64"><td class="memItemLeft" align="right" valign="top">virtual bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classpcpp_1_1_pf_ring_device.html#af334503822ac7076373c64109f3e6d64">setFilter</a> (<a class="el" href="classpcpp_1_1_general_filter.html">GeneralFilter</a> &amp;filter)</td></tr>
<tr class="separator:af334503822ac7076373c64109f3e6d64"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:adf01bb590d975d28fc38053820a69130"><td class="memItemLeft" align="right" valign="top">virtual bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classpcpp_1_1_pf_ring_device.html#adf01bb590d975d28fc38053820a69130">setFilter</a> (std::string filterAsString)=0</td></tr>
<tr class="separator:adf01bb590d975d28fc38053820a69130"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="inherit_header pub_methods_classpcpp_1_1_i_device"><td colspan="2" onclick="javascript:toggleInherit('pub_methods_classpcpp_1_1_i_device')"><img src="closed.png" alt="-"/>&#160;Public Member Functions inherited from <a class="el" href="classpcpp_1_1_i_device.html">pcpp::IDevice</a></td></tr>
<tr class="memitem:a5b75e7491597f271b8f29847bec2ee99 inherit pub_methods_classpcpp_1_1_i_device"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classpcpp_1_1_i_device.html#a5b75e7491597f271b8f29847bec2ee99">isOpened</a> ()</td></tr>
<tr class="separator:a5b75e7491597f271b8f29847bec2ee99 inherit pub_methods_classpcpp_1_1_i_device"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="inherit_header pub_methods_classpcpp_1_1_i_filterable_device"><td colspan="2" onclick="javascript:toggleInherit('pub_methods_classpcpp_1_1_i_filterable_device')"><img src="closed.png" alt="-"/>&#160;Public Member Functions inherited from <a class="el" href="classpcpp_1_1_i_filterable_device.html">pcpp::IFilterableDevice</a></td></tr>
<tr class="memitem:af334503822ac7076373c64109f3e6d64 inherit pub_methods_classpcpp_1_1_i_filterable_device"><td class="memItemLeft" align="right" valign="top">virtual bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classpcpp_1_1_i_filterable_device.html#af334503822ac7076373c64109f3e6d64">setFilter</a> (<a class="el" href="classpcpp_1_1_general_filter.html">GeneralFilter</a> &amp;filter)</td></tr>
<tr class="separator:af334503822ac7076373c64109f3e6d64 inherit pub_methods_classpcpp_1_1_i_filterable_device"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table>
<a name="details" id="details"></a><h2 class="groupheader">Detailed Description</h2>
<div class="textblock"><p>A class representing a PF_RING port </p>
</div><h2 class="groupheader">Member Enumeration Documentation</h2>
<a id="a2a7113725490fea52c9702998e6a8f78"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a2a7113725490fea52c9702998e6a8f78">&#9670;&nbsp;</a></span>ChannelDistribution</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">enum <a class="el" href="classpcpp_1_1_pf_ring_device.html#a2a7113725490fea52c9702998e6a8f78">pcpp::PfRingDevice::ChannelDistribution</a></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>An enum representing the type of packet distribution between different RX channels. </p>
<table class="fieldtable">
<tr><th colspan="2">Enumerator</th></tr><tr><td class="fieldname"><a id="a2a7113725490fea52c9702998e6a8f78a707c1b0c55e37f2cb7d4978370332712"></a>RoundRobin&#160;</td><td class="fielddoc"><p>Packets are distributed between channels in a round-robin manner. </p>
</td></tr>
<tr><td class="fieldname"><a id="a2a7113725490fea52c9702998e6a8f78a7b91b5daaad7f4b2f754afa4b69f48b6"></a>PerFlow&#160;</td><td class="fielddoc"><p>Packets are distributed between channels per flow (each flow goes for different channel) </p>
</td></tr>
</table>

</div>
</div>
<h2 class="groupheader">Member Function Documentation</h2>
<a id="a4077ed601329e70176e0717507a25824"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a4077ed601329e70176e0717507a25824">&#9670;&nbsp;</a></span>clearFilter()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool pcpp::PfRingDevice::clearFilter </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Remove a filter if currently set </p><dl class="section return"><dt>Returns</dt><dd>True if filter was removed successfully or if no filter was set, false otherwise </dd></dl>

<p>Implements <a class="el" href="classpcpp_1_1_i_filterable_device.html#abfccd588fbbbb6634332a834e039ddf3">pcpp::IFilterableDevice</a>.</p>

</div>
</div>
<a id="aa7a1e30e857daf58422bbf82b57c68d5"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aa7a1e30e857daf58422bbf82b57c68d5">&#9670;&nbsp;</a></span>getCurrentCoreId()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structpcpp_1_1_system_core.html">SystemCore</a> pcpp::PfRingDevice::getCurrentCoreId </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Gets the core used in the current thread context </p><dl class="section return"><dt>Returns</dt><dd>The system core used in the current thread context </dd></dl>

</div>
</div>
<a id="ab087acddadc1c3f65058f4cf54b09c78"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ab087acddadc1c3f65058f4cf54b09c78">&#9670;&nbsp;</a></span>getCurrentThreadStatistics()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void pcpp::PfRingDevice::getCurrentThreadStatistics </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structpcpp_1_1_pf_ring_device_1_1_pf_ring_stats.html">PfRingStats</a> &amp;&#160;</td>
          <td class="paramname"><em>stats</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Get the statistics of the current thread/core (=RX channel) </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[out]</td><td class="paramname">stats</td><td>A reference for the stats object where the stats are written. Current values will be overridden </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a9ac18b4561b579975dfd6c89722eab9e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a9ac18b4561b579975dfd6c89722eab9e">&#9670;&nbsp;</a></span>getDeviceName()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">std::string pcpp::PfRingDevice::getDeviceName </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Gets the interface name (e.g eth0, eth1, etc.) </p><dl class="section return"><dt>Returns</dt><dd>The interface name </dd></dl>

</div>
</div>
<a id="a9d939956173c6246d02aa5bcbc576c0f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a9d939956173c6246d02aa5bcbc576c0f">&#9670;&nbsp;</a></span>getInterfaceIndex()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">int pcpp::PfRingDevice::getInterfaceIndex </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Get PF_RING interface index of the current device </p><dl class="section return"><dt>Returns</dt><dd>PF_RING interface index of the current device </dd></dl>

</div>
</div>
<a id="ab3f349a204036f5de153e5a45e1a4f50"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ab3f349a204036f5de153e5a45e1a4f50">&#9670;&nbsp;</a></span>getMacAddress()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classpcpp_1_1_mac_address.html">MacAddress</a> pcpp::PfRingDevice::getMacAddress </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Get the MAC address of the current device </p><dl class="section return"><dt>Returns</dt><dd>The MAC address of the current device </dd></dl>

</div>
</div>
<a id="a3a783b9949814723e1e3e7dc76c5e4fc"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a3a783b9949814723e1e3e7dc76c5e4fc">&#9670;&nbsp;</a></span>getMtu()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">int pcpp::PfRingDevice::getMtu </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Get MTU of the current device </p><dl class="section return"><dt>Returns</dt><dd>Upon success return the device MTU, 0 otherwise </dd></dl>

</div>
</div>
<a id="a9954fb008030336858d57be7f3ccbc78"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a9954fb008030336858d57be7f3ccbc78">&#9670;&nbsp;</a></span>getNumOfOpenedRxChannels()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">uint8_t pcpp::PfRingDevice::getNumOfOpenedRxChannels </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Gets the number of RX channels currently open. RX channels aren't necessary interface's RX queues because in some cases the user asks to open several channels on the same queue. For example: if the user uses <a class="el" href="classpcpp_1_1_pf_ring_device.html#a923fa6c928456417a5985be210e3e487">openMultiRxChannels()</a> and asks to open 8 channels but interface has only 4 RX queues, 2 channels will be opened for each RX queue </p><dl class="section return"><dt>Returns</dt><dd>Number of opened RX channels </dd></dl>

</div>
</div>
<a id="aeade33242ac31b8e7ddff4888853cc19"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aeade33242ac31b8e7ddff4888853cc19">&#9670;&nbsp;</a></span>getStatistics()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void pcpp::PfRingDevice::getStatistics </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structpcpp_1_1_pf_ring_device_1_1_pf_ring_stats.html">PfRingStats</a> &amp;&#160;</td>
          <td class="paramname"><em>stats</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Get the statistics for the entire device. If more than 1 RX channel is opened, this method aggregates the stats of all channels </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[out]</td><td class="paramname">stats</td><td>A reference for the stats object where the stats are written. Current values will be overridden </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a6953e3efa57b5a8698586db135d87569"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a6953e3efa57b5a8698586db135d87569">&#9670;&nbsp;</a></span>getThreadStatistics()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void pcpp::PfRingDevice::getThreadStatistics </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structpcpp_1_1_system_core.html">SystemCore</a>&#160;</td>
          <td class="paramname"><em>core</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structpcpp_1_1_pf_ring_device_1_1_pf_ring_stats.html">PfRingStats</a> &amp;&#160;</td>
          <td class="paramname"><em>stats</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Get the statistics of a specific thread/core (=RX channel) </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">core</td><td>The requested core </td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">stats</td><td>A reference for the stats object where the stats are written. Current values will be overridden </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a540956cbcbac10ca854a76e15227aec1"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a540956cbcbac10ca854a76e15227aec1">&#9670;&nbsp;</a></span>getTotalNumOfRxChannels()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">uint8_t pcpp::PfRingDevice::getTotalNumOfRxChannels </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Gets the total number of RX channels (RX queues) this interface has </p><dl class="section return"><dt>Returns</dt><dd>The number of RX channels (queues) for this interface </dd></dl>

</div>
</div>
<a id="aa4088e46b8bd058c6b0832731586dc51"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aa4088e46b8bd058c6b0832731586dc51">&#9670;&nbsp;</a></span>isFilterCurrentlySet()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool pcpp::PfRingDevice::isFilterCurrentlySet </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Return true if filter is currently set </p><dl class="section return"><dt>Returns</dt><dd>True if filter is currently set, false otherwise </dd></dl>

</div>
</div>
<a id="a3d897e1f5c1f9ef15987b82eff1a736b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a3d897e1f5c1f9ef15987b82eff1a736b">&#9670;&nbsp;</a></span>isHwClockEnabledForDevice()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool pcpp::PfRingDevice::isHwClockEnabledForDevice </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Return true if device supports hardware timestamping. If it does, this feature will be automatically set for this device. You can read more about this in PF_RING documentation </p><dl class="section return"><dt>Returns</dt><dd>True if device supports hardware timestamping, false otherwise </dd></dl>

</div>
</div>
<a id="a94f3512928cf7ccdb4f8a28532c6ee51"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a94f3512928cf7ccdb4f8a28532c6ee51">&#9670;&nbsp;</a></span>open()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool pcpp::PfRingDevice::open </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Opens the entire device (including all RX channels/queues on this interface). All packets will be received on a single thread without core affinity </p><dl class="section return"><dt>Returns</dt><dd>True if this action succeeds, false otherwise </dd></dl>

<p>Implements <a class="el" href="classpcpp_1_1_i_device.html#ad7bed3f1134e8b4329295b4af6733b9f">pcpp::IDevice</a>.</p>

</div>
</div>
<a id="a923fa6c928456417a5985be210e3e487"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a923fa6c928456417a5985be210e3e487">&#9670;&nbsp;</a></span>openMultiRxChannels() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool pcpp::PfRingDevice::openMultiRxChannels </td>
          <td>(</td>
          <td class="paramtype">const uint8_t *&#160;</td>
          <td class="paramname"><em>channelIds</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>numOfChannelIds</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Opens a set of RX channels (=RX queues) on this interface, identified by their IDs. All packets will be received on a single thread without core affinity. If one of the channel IDs requested doesn't exist on this interface, the method will fail (return false) </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">channelIds</td><td>An array of channel IDs </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">numOfChannelIds</td><td>The channel ID array size </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>True if this action succeeds, false otherwise </dd></dl>

</div>
</div>
<a id="a42fa0b515215e8801f3e5f955dff095c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a42fa0b515215e8801f3e5f955dff095c">&#9670;&nbsp;</a></span>openMultiRxChannels() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool pcpp::PfRingDevice::openMultiRxChannels </td>
          <td>(</td>
          <td class="paramtype">uint8_t&#160;</td>
          <td class="paramname"><em>numOfRxChannelsToOpen</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classpcpp_1_1_pf_ring_device.html#a2a7113725490fea52c9702998e6a8f78">ChannelDistribution</a>&#160;</td>
          <td class="paramname"><em>dist</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Opens numOfRxChannelsToOpen RX channels. If numOfRxChannelsToOpen is larger than available RX queues for this interface than a number of RX channels will be opened on each RX queue. For example: if the user asks for 10 RX channels but the interface has only 4 RX queues, then 3 RX channels will be opened for RX-queue0 and RX-queue2, and 2 RX channels will be opened for RX-queue2 and RX-queue3. Packets will be distributed between different RX queues on per-flow manner, but within multiple RX channels in the same RX queue packet will be distributed according to distribution requested by "dist" </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">numOfRxChannelsToOpen</td><td>Number of RX channels to open </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">dist</td><td>Distribution method </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>True if this action succeeds, false otherwise </dd></dl>

</div>
</div>
<a id="a4a06e5e4364538de4b4fc71df0153c27"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a4a06e5e4364538de4b4fc71df0153c27">&#9670;&nbsp;</a></span>openSingleRxChannel()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool pcpp::PfRingDevice::openSingleRxChannel </td>
          <td>(</td>
          <td class="paramtype">uint8_t&#160;</td>
          <td class="paramname"><em>channelId</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Opens a single RX channel (=RX queue) on this interface. All packets will be received on a single thread without core affinity. If the channel ID requested doesn't exist on this interface, the method will fail (return false) </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">channelId</td><td>The requested channel ID </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>True if this action succeeds, false otherwise </dd></dl>

</div>
</div>
<a id="a8cbdc286e019385205d4528d80af9484"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a8cbdc286e019385205d4528d80af9484">&#9670;&nbsp;</a></span>sendPacket() <span class="overload">[1/3]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool pcpp::PfRingDevice::sendPacket </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classpcpp_1_1_packet.html">Packet</a> &amp;&#160;</td>
          <td class="paramname"><em>packet</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Send a packet. This packet must be fully specified (the MAC address up) and it will be transmitted as-is without any further manipulation. This method doesn't change or manipulate the data in any way (hence the "const" declaration). Note this method flushes the TX queues after the data is sent. So if you want to send several packets In the burst please use <a class="el" href="classpcpp_1_1_pf_ring_device.html#af825fb6acf7cfbc6da7dd19f854be1ad">sendPackets()</a> </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">packet</td><td>The packet to send </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>True if raw packet was sent completely, false otherwise </dd></dl>

</div>
</div>
<a id="a1a5f1744d29145bf929e943c02f35a6b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a1a5f1744d29145bf929e943c02f35a6b">&#9670;&nbsp;</a></span>sendPacket() <span class="overload">[2/3]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool pcpp::PfRingDevice::sendPacket </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classpcpp_1_1_raw_packet.html">RawPacket</a> &amp;&#160;</td>
          <td class="paramname"><em>rawPacket</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Send a raw packet. This packet must be fully specified (the MAC address up) and it will be transmitted as-is without any further manipulation. This method doesn't change or manipulate the data in any way (hence the "const" declaration). Note this method flushes the TX queues after the data is sent. So if you want to send several packets In the burst please use <a class="el" href="classpcpp_1_1_pf_ring_device.html#af825fb6acf7cfbc6da7dd19f854be1ad">sendPackets()</a> </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">rawPacket</td><td>The raw packet to send </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>True if raw packet was sent completely, false otherwise </dd></dl>

</div>
</div>
<a id="abe92b5e338eeb7086527b9f468e1a05e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#abe92b5e338eeb7086527b9f468e1a05e">&#9670;&nbsp;</a></span>sendPacket() <span class="overload">[3/3]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool pcpp::PfRingDevice::sendPacket </td>
          <td>(</td>
          <td class="paramtype">const uint8_t *&#160;</td>
          <td class="paramname"><em>packetData</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>packetDataLength</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Send raw data. This data must be a valid and fully specified packet (the MAC address up); it will be transmitted as-is without any further manipulation. This method doesn't change or manipulate the data in any way (hence the "const" declaration). Note this method flushes the TX queues after the data is sent. So if you want to send several packets in the burst please use <a class="el" href="classpcpp_1_1_pf_ring_device.html#af825fb6acf7cfbc6da7dd19f854be1ad">sendPackets()</a> </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">packetData</td><td>The raw data to send </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">packetDataLength</td><td>the length of packetData </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>True if raw packet was sent completely, false otherwise </dd></dl>

</div>
</div>
<a id="a8fabac9d1c87b2a6e79d5ce0bbfb7eeb"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a8fabac9d1c87b2a6e79d5ce0bbfb7eeb">&#9670;&nbsp;</a></span>sendPackets() <span class="overload">[1/3]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int pcpp::PfRingDevice::sendPackets </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classpcpp_1_1_packet.html">Packet</a> **&#160;</td>
          <td class="paramname"><em>packetsArr</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>arrLength</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Send packets. All packets must be fully specified (the MAC address up) and it will be transmitted as-is without any further manipulation. This method doesn't change or manipulate the packets data in any way (hence the "const" declaration). This method flushes the TX queues only when the last packet is sent </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">packetsArr</td><td>An array of pointers to <a class="el" href="classpcpp_1_1_packet.html">Packet</a> objects </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">arrLength</td><td><a class="el" href="classpcpp_1_1_packet.html">Packet</a> pointers array length </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Number of packets that were sent completely </dd></dl>

</div>
</div>
<a id="af825fb6acf7cfbc6da7dd19f854be1ad"></a>
<h2 class="memtitle"><span class="permalink"><a href="#af825fb6acf7cfbc6da7dd19f854be1ad">&#9670;&nbsp;</a></span>sendPackets() <span class="overload">[2/3]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int pcpp::PfRingDevice::sendPackets </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classpcpp_1_1_raw_packet.html">RawPacket</a> *&#160;</td>
          <td class="paramname"><em>rawPacketsArr</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>arrLength</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Send raw packets. All raw packets must be fully specified (the MAC address up) and it will be transmitted as-is without any further manipulation. This method doesn't change or manipulate the raw packets data in any way (hence the "const" declaration). This method flushes the TX queues only when the last packet is sent </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">rawPacketsArr</td><td>The <a class="el" href="classpcpp_1_1_raw_packet.html">RawPacket</a> array </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">arrLength</td><td><a class="el" href="classpcpp_1_1_raw_packet.html">RawPacket</a> array length </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Number of packets that were sent completely </dd></dl>

</div>
</div>
<a id="a9259bcfd0d7e94822ec2a2930314c52e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a9259bcfd0d7e94822ec2a2930314c52e">&#9670;&nbsp;</a></span>sendPackets() <span class="overload">[3/3]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int pcpp::PfRingDevice::sendPackets </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="namespacepcpp.html#a4c0775fb93a0867d2afa7992d55957f0">RawPacketVector</a> &amp;&#160;</td>
          <td class="paramname"><em>rawPackets</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Send all raw packets pointed by the RawPacketVector. All packets must be fully specified (the MAC address up) and it will be transmitted as-is without any further manipulation. This method doesn't change or manipulate the packets data in any way (hence the "const" declaration). This method flushes the TX queues only when the last packet is sent </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">rawPackets</td><td>The raw packet vector </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Number of raw packets that were sent completely </dd></dl>

</div>
</div>
<a id="af334503822ac7076373c64109f3e6d64"></a>
<h2 class="memtitle"><span class="permalink"><a href="#af334503822ac7076373c64109f3e6d64">&#9670;&nbsp;</a></span>setFilter() <span class="overload">[1/3]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual bool pcpp::IFilterableDevice::setFilter</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Set a filter for the device. When implemented by the device, only packets that match the filter will be received </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">filter</td><td>The filter to be set in PcapPlusPlus' <a class="el" href="classpcpp_1_1_general_filter.html">GeneralFilter</a> format </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>True if filter set successfully, false otherwise </dd></dl>

</div>
</div>
<a id="addd683b41cf717a08248ddf86b08df49"></a>
<h2 class="memtitle"><span class="permalink"><a href="#addd683b41cf717a08248ddf86b08df49">&#9670;&nbsp;</a></span>setFilter() <span class="overload">[2/3]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool pcpp::PfRingDevice::setFilter </td>
          <td>(</td>
          <td class="paramtype">std::string&#160;</td>
          <td class="paramname"><em>filterAsString</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Sets a BPF filter to the device </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">filterAsString</td><td>The BPF filter in string format </td></tr>
  </table>
  </dd>
</dl>

<p>Implements <a class="el" href="classpcpp_1_1_i_filterable_device.html#adf01bb590d975d28fc38053820a69130">pcpp::IFilterableDevice</a>.</p>

</div>
</div>
<a id="adf01bb590d975d28fc38053820a69130"></a>
<h2 class="memtitle"><span class="permalink"><a href="#adf01bb590d975d28fc38053820a69130">&#9670;&nbsp;</a></span>setFilter() <span class="overload">[3/3]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">virtual bool pcpp::IFilterableDevice::setFilter</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Set a filter for the device. When implemented by the device, only packets that match the filter will be received </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">filterAsString</td><td>The filter to be set in Berkeley <a class="el" href="classpcpp_1_1_packet.html">Packet</a> Filter (BPF) syntax (<a href="http://biot.com/capstats/bpf.html">http://biot.com/capstats/bpf.html</a>) </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>True if filter set successfully, false otherwise </dd></dl>

</div>
</div>
<a id="a2267f74af554b8651d771ab7f453dc50"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a2267f74af554b8651d771ab7f453dc50">&#9670;&nbsp;</a></span>startCaptureMultiThread()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool pcpp::PfRingDevice::startCaptureMultiThread </td>
          <td>(</td>
          <td class="paramtype">OnPfRingPacketsArriveCallback&#160;</td>
          <td class="paramname"><em>onPacketsArrive</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">void *&#160;</td>
          <td class="paramname"><em>onPacketsArriveUserCookie</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">CoreMask&#160;</td>
          <td class="paramname"><em>coreMask</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Start multi-threaded (multi-core) capturing with callback. Works with <a class="el" href="classpcpp_1_1_pf_ring_device.html#a923fa6c928456417a5985be210e3e487">openMultiRxChannels()</a>. This method will return an error if the number of opened channels is different than the number of threads/cores requested </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">onPacketsArrive</td><td>A callback to call whenever a packet arrives </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">onPacketsArriveUserCookie</td><td>A cookie that will be delivered to onPacketsArrive callback on every packet </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">coreMask</td><td>The cores to be used as mask. For example: </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>True if this action succeeds, false otherwise </dd></dl>

</div>
</div>
<a id="a2d15fc696287e4a5dc16bd809fdce893"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a2d15fc696287e4a5dc16bd809fdce893">&#9670;&nbsp;</a></span>startCaptureSingleThread()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool pcpp::PfRingDevice::startCaptureSingleThread </td>
          <td>(</td>
          <td class="paramtype">OnPfRingPacketsArriveCallback&#160;</td>
          <td class="paramname"><em>onPacketsArrive</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">void *&#160;</td>
          <td class="paramname"><em>onPacketsArriveUserCookie</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Start single-threaded capturing with callback. Works with <a class="el" href="classpcpp_1_1_pf_ring_device.html#a94f3512928cf7ccdb4f8a28532c6ee51">open()</a> or openSingleRxChannel(). </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">onPacketsArrive</td><td>A callback to call whenever a packet arrives </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">onPacketsArriveUserCookie</td><td>A cookie that will be delivered to onPacketsArrive callback on every packet </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>True if this action succeeds, false otherwise </dd></dl>

</div>
</div>
</div><!-- contents -->
</div><!-- doc-content -->
<!-- start footer part -->
<div id="nav-path" class="navpath"><!-- id is needed for treeview function! -->
  <ul>
    <li class="navelem"><a class="el" href="namespacepcpp.html">pcpp</a></li><li class="navelem"><a class="el" href="classpcpp_1_1_pf_ring_device.html">PfRingDevice</a></li>
    <li class="footer">Generated on Sat Apr 26 2025 08:23:50 for PcapPlusPlus by <a href="https://www.doxygen.org/index.html"><img class="footer" src="doxygen.svg" width="104" height="31" alt="doxygen"/></a> 1.9.1 </li>
  </ul>
</div>
</body>
</html>
