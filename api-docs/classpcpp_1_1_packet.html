<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "https://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=9"/>
<meta name="generator" content="Doxygen 1.8.16"/>
<meta name="viewport" content="width=device-width, initial-scale=1"/>
<title>PcapPlusPlus: pcpp::Packet Class Reference</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<link href="navtree.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="resize.js"></script>
<script type="text/javascript" src="navtreedata.js"></script>
<script type="text/javascript" src="navtree.js"></script>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:cf05388f2679ee054f2beb29a391d25f4e673ac3&amp;dn=gpl-2.0.txt GPL-v2 */
  $(document).ready(initResizable);
/* @license-end */</script>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/searchdata.js"></script>
<script type="text/javascript" src="search/search.js"></script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
<link href="doxygen-mobile.css" rel="stylesheet" type="text/css"/>
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr style="height: 56px;">
  <td id="projectlogo"><img alt="Logo" src="logo_icon_large.ico"/></td>
  <td id="projectalign" style="padding-left: 0.5em;">
   <div id="projectname">PcapPlusPlus
   &#160;<span id="projectnumber">19.12</span>
   </div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.8.16 -->
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:cf05388f2679ee054f2beb29a391d25f4e673ac3&amp;dn=gpl-2.0.txt GPL-v2 */
var searchBox = new SearchBox("searchBox", "search",false,'Search');
/* @license-end */
</script>
<script type="text/javascript" src="menudata.js"></script>
<script type="text/javascript" src="menu.js"></script>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:cf05388f2679ee054f2beb29a391d25f4e673ac3&amp;dn=gpl-2.0.txt GPL-v2 */
$(function() {
  initMenu('',true,false,'search.php','Search');
  $(document).ready(function() { init_search(); });
});
/* @license-end */</script>
<div id="main-nav"></div>
</div><!-- top -->
<div id="side-nav" class="ui-resizable side-nav-resizable">
  <div id="nav-tree">
    <div id="nav-tree-contents">
      <div id="nav-sync" class="sync"></div>
    </div>
  </div>
  <div id="splitbar" style="-moz-user-select:none;" 
       class="ui-resizable-handle">
  </div>
</div>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:cf05388f2679ee054f2beb29a391d25f4e673ac3&amp;dn=gpl-2.0.txt GPL-v2 */
$(document).ready(function(){initNavTree('classpcpp_1_1_packet.html','');});
/* @license-end */
</script>
<div id="doc-content">
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
</div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<iframe src="javascript:void(0)" frameborder="0" 
        name="MSearchResults" id="MSearchResults">
</iframe>
</div>

<div class="header">
  <div class="summary">
<a href="#pub-methods">Public Member Functions</a> &#124;
<a href="classpcpp_1_1_packet-members.html">List of all members</a>  </div>
  <div class="headertitle">
<div class="title">pcpp::Packet Class Reference</div>  </div>
</div><!--header-->
<div class="contents">

<p><code>#include &lt;<a class="el" href="_packet_8h_source.html">Packet.h</a>&gt;</code></p>
<table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="pub-methods"></a>
Public Member Functions</h2></td></tr>
<tr class="memitem:a1a6d4e157661ba7ec6f552c78c82d7fa"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classpcpp_1_1_packet.html#a1a6d4e157661ba7ec6f552c78c82d7fa">Packet</a> (size_t maxPacketLen=1)</td></tr>
<tr class="separator:a1a6d4e157661ba7ec6f552c78c82d7fa"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aaf61c3f9a5c12a7047774b42f31ee2ec"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classpcpp_1_1_packet.html#aaf61c3f9a5c12a7047774b42f31ee2ec">Packet</a> (<a class="el" href="classpcpp_1_1_raw_packet.html">RawPacket</a> *rawPacket, bool freeRawPacket=false, <a class="el" href="namespacepcpp.html#a1d761f7cf37d3b1efb1574fb1177e6eb">ProtocolType</a> parseUntil=<a class="el" href="namespacepcpp.html#a1d761f7cf37d3b1efb1574fb1177e6eba8576597b751111eab8ec156233a7fd29">UnknownProtocol</a>, <a class="el" href="namespacepcpp.html#a69e2ee6a9dc68797612cf8dc38461025">OsiModelLayer</a> parseUntilLayer=<a class="el" href="namespacepcpp.html#a69e2ee6a9dc68797612cf8dc38461025aaa1b22ad907997f669b20cc0d3b7e87f">OsiModelLayerUnknown</a>)</td></tr>
<tr class="separator:aaf61c3f9a5c12a7047774b42f31ee2ec"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa9b12034dca53509c273e4ef954b8099"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classpcpp_1_1_packet.html#aa9b12034dca53509c273e4ef954b8099">Packet</a> (<a class="el" href="classpcpp_1_1_raw_packet.html">RawPacket</a> *rawPacket, <a class="el" href="namespacepcpp.html#a1d761f7cf37d3b1efb1574fb1177e6eb">ProtocolType</a> parseUntil)</td></tr>
<tr class="separator:aa9b12034dca53509c273e4ef954b8099"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9af7caebc8d97ac92910d8a91186b461"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classpcpp_1_1_packet.html#a9af7caebc8d97ac92910d8a91186b461">Packet</a> (<a class="el" href="classpcpp_1_1_raw_packet.html">RawPacket</a> *rawPacket, <a class="el" href="namespacepcpp.html#a69e2ee6a9dc68797612cf8dc38461025">OsiModelLayer</a> parseUntilLayer)</td></tr>
<tr class="separator:a9af7caebc8d97ac92910d8a91186b461"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a54ccf8336cf3c3f6a5ad58ad12f06656"><td class="memItemLeft" align="right" valign="top">virtual&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classpcpp_1_1_packet.html#a54ccf8336cf3c3f6a5ad58ad12f06656">~Packet</a> ()</td></tr>
<tr class="separator:a54ccf8336cf3c3f6a5ad58ad12f06656"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a11d603615d2f100eec547d51b4a6282e"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classpcpp_1_1_packet.html#a11d603615d2f100eec547d51b4a6282e">Packet</a> (const <a class="el" href="classpcpp_1_1_packet.html">Packet</a> &amp;other)</td></tr>
<tr class="separator:a11d603615d2f100eec547d51b4a6282e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a26af180628893e454e9d6e0f2f1ebb98"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classpcpp_1_1_packet.html">Packet</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classpcpp_1_1_packet.html#a26af180628893e454e9d6e0f2f1ebb98">operator=</a> (const <a class="el" href="classpcpp_1_1_packet.html">Packet</a> &amp;other)</td></tr>
<tr class="separator:a26af180628893e454e9d6e0f2f1ebb98"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a56ef03e8516ee79b8ac397db0f052e89"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classpcpp_1_1_raw_packet.html">RawPacket</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classpcpp_1_1_packet.html#a56ef03e8516ee79b8ac397db0f052e89">getRawPacket</a> () const</td></tr>
<tr class="separator:a56ef03e8516ee79b8ac397db0f052e89"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1dee26fe9bb8c7ae6cd90f45e67446ef"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classpcpp_1_1_packet.html#a1dee26fe9bb8c7ae6cd90f45e67446ef">setRawPacket</a> (<a class="el" href="classpcpp_1_1_raw_packet.html">RawPacket</a> *rawPacket, bool freeRawPacket, <a class="el" href="namespacepcpp.html#a1d761f7cf37d3b1efb1574fb1177e6eb">ProtocolType</a> parseUntil=<a class="el" href="namespacepcpp.html#a1d761f7cf37d3b1efb1574fb1177e6eba8576597b751111eab8ec156233a7fd29">UnknownProtocol</a>, <a class="el" href="namespacepcpp.html#a69e2ee6a9dc68797612cf8dc38461025">OsiModelLayer</a> parseUntilLayer=<a class="el" href="namespacepcpp.html#a69e2ee6a9dc68797612cf8dc38461025aaa1b22ad907997f669b20cc0d3b7e87f">OsiModelLayerUnknown</a>)</td></tr>
<tr class="separator:a1dee26fe9bb8c7ae6cd90f45e67446ef"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1c4fede8a4bee643ee85bfbc4ddd7174"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classpcpp_1_1_raw_packet.html">RawPacket</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classpcpp_1_1_packet.html#a1c4fede8a4bee643ee85bfbc4ddd7174">getRawPacketReadOnly</a> () const</td></tr>
<tr class="separator:a1c4fede8a4bee643ee85bfbc4ddd7174"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:afbe8bb3d1c8ef829120fa1bc9bac5677"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classpcpp_1_1_layer.html">Layer</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classpcpp_1_1_packet.html#afbe8bb3d1c8ef829120fa1bc9bac5677">getFirstLayer</a> () const</td></tr>
<tr class="separator:afbe8bb3d1c8ef829120fa1bc9bac5677"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa207dcf476921fbd53959e7da47ad1ac"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classpcpp_1_1_layer.html">Layer</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classpcpp_1_1_packet.html#aa207dcf476921fbd53959e7da47ad1ac">getLastLayer</a> () const</td></tr>
<tr class="separator:aa207dcf476921fbd53959e7da47ad1ac"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad43e09f561e9b8bfe32bc498c2fa3ec1"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classpcpp_1_1_packet.html#ad43e09f561e9b8bfe32bc498c2fa3ec1">addLayer</a> (<a class="el" href="classpcpp_1_1_layer.html">Layer</a> *newLayer, bool ownInPacket=false)</td></tr>
<tr class="separator:ad43e09f561e9b8bfe32bc498c2fa3ec1"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0b84fbbd9a0e0074445b95d89103fa3e"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classpcpp_1_1_packet.html#a0b84fbbd9a0e0074445b95d89103fa3e">insertLayer</a> (<a class="el" href="classpcpp_1_1_layer.html">Layer</a> *prevLayer, <a class="el" href="classpcpp_1_1_layer.html">Layer</a> *newLayer, bool ownInPacket=false)</td></tr>
<tr class="separator:a0b84fbbd9a0e0074445b95d89103fa3e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a28fbabf49349df90548ac7c085b1cff3"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classpcpp_1_1_packet.html#a28fbabf49349df90548ac7c085b1cff3">removeLayer</a> (<a class="el" href="namespacepcpp.html#a1d761f7cf37d3b1efb1574fb1177e6eb">ProtocolType</a> layerType, int index=0)</td></tr>
<tr class="separator:a28fbabf49349df90548ac7c085b1cff3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2e7755654f74cc1280409f3f42d9c9e3"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classpcpp_1_1_packet.html#a2e7755654f74cc1280409f3f42d9c9e3">removeFirstLayer</a> ()</td></tr>
<tr class="separator:a2e7755654f74cc1280409f3f42d9c9e3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:abda544ac8ac70142f086f63b25ff200c"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classpcpp_1_1_packet.html#abda544ac8ac70142f086f63b25ff200c">removeLastLayer</a> ()</td></tr>
<tr class="separator:abda544ac8ac70142f086f63b25ff200c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a864c0024b5bc88a4ba7c55373ff2ee01"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classpcpp_1_1_packet.html#a864c0024b5bc88a4ba7c55373ff2ee01">removeAllLayersAfter</a> (<a class="el" href="classpcpp_1_1_layer.html">Layer</a> *layer)</td></tr>
<tr class="separator:a864c0024b5bc88a4ba7c55373ff2ee01"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a54d83577cda897699f28595477f2d92d"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classpcpp_1_1_layer.html">Layer</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classpcpp_1_1_packet.html#a54d83577cda897699f28595477f2d92d">detachLayer</a> (<a class="el" href="namespacepcpp.html#a1d761f7cf37d3b1efb1574fb1177e6eb">ProtocolType</a> layerType, int index=0)</td></tr>
<tr class="separator:a54d83577cda897699f28595477f2d92d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad4dbb6b0bedb3f58f6855aa0329a8908"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classpcpp_1_1_packet.html#ad4dbb6b0bedb3f58f6855aa0329a8908">detachLayer</a> (<a class="el" href="classpcpp_1_1_layer.html">Layer</a> *layer)</td></tr>
<tr class="separator:ad4dbb6b0bedb3f58f6855aa0329a8908"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a952f7939f5044c45bef2bde38ed22b61"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classpcpp_1_1_layer.html">Layer</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classpcpp_1_1_packet.html#a952f7939f5044c45bef2bde38ed22b61">getLayerOfType</a> (<a class="el" href="namespacepcpp.html#a1d761f7cf37d3b1efb1574fb1177e6eb">ProtocolType</a> layerType, int index=0) const</td></tr>
<tr class="separator:a952f7939f5044c45bef2bde38ed22b61"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aeb239964f13a6d47b54bfd919f9af25e"><td class="memTemplParams" colspan="2">template&lt;class TLayer &gt; </td></tr>
<tr class="memitem:aeb239964f13a6d47b54bfd919f9af25e"><td class="memTemplItemLeft" align="right" valign="top">TLayer *&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classpcpp_1_1_packet.html#aeb239964f13a6d47b54bfd919f9af25e">getLayerOfType</a> () const</td></tr>
<tr class="separator:aeb239964f13a6d47b54bfd919f9af25e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7c9c78143afae5d5e91ce89f0b38acb3"><td class="memTemplParams" colspan="2">template&lt;class TLayer &gt; </td></tr>
<tr class="memitem:a7c9c78143afae5d5e91ce89f0b38acb3"><td class="memTemplItemLeft" align="right" valign="top">TLayer *&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classpcpp_1_1_packet.html#a7c9c78143afae5d5e91ce89f0b38acb3">getNextLayerOfType</a> (<a class="el" href="classpcpp_1_1_layer.html">Layer</a> *after) const</td></tr>
<tr class="separator:a7c9c78143afae5d5e91ce89f0b38acb3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0638363f7edf78cbedd239c92c647c24"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classpcpp_1_1_packet.html#a0638363f7edf78cbedd239c92c647c24">isPacketOfType</a> (<a class="el" href="namespacepcpp.html#a1d761f7cf37d3b1efb1574fb1177e6eb">ProtocolType</a> protocolType) const</td></tr>
<tr class="separator:a0638363f7edf78cbedd239c92c647c24"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab19addb15ea46927076227436fde753e"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classpcpp_1_1_packet.html#ab19addb15ea46927076227436fde753e">computeCalculateFields</a> ()</td></tr>
<tr class="separator:ab19addb15ea46927076227436fde753e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8c3a62bbd020dc2e88147be71876a758"><td class="memItemLeft" align="right" valign="top">std::string&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classpcpp_1_1_packet.html#a8c3a62bbd020dc2e88147be71876a758">toString</a> (bool timeAsLocalTime=true)</td></tr>
<tr class="separator:a8c3a62bbd020dc2e88147be71876a758"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab565f9f2bb5099c83ccf25e917e6257c"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classpcpp_1_1_packet.html#ab565f9f2bb5099c83ccf25e917e6257c">toStringList</a> (std::vector&lt; std::string &gt; &amp;result, bool timeAsLocalTime=true) const</td></tr>
<tr class="separator:ab565f9f2bb5099c83ccf25e917e6257c"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table>
<a name="details" id="details"></a><h2 class="groupheader">Detailed Description</h2>
<div class="textblock"><p>This class represents a parsed packet. It contains the raw data (<a class="el" href="classpcpp_1_1_raw_packet.html">RawPacket</a> instance), and a linked list of layers, each layer is a parsed protocol that this packet contains. The layers linked list is ordered where the first layer is the lowest in the packet (currently it's always Ethernet protocol as PcapPlusPlus supports only Ethernet packets), the next layer will be L2.5 or L3 (e.g VLAN, IPv4, IPv6, etc.), and so on. etc.), etc. The last layer in the linked list will be the highest in the packet. For example: for a standard HTTP request packet the layer will look like this: <a class="el" href="classpcpp_1_1_eth_layer.html">EthLayer</a> -&gt; <a class="el" href="classpcpp_1_1_i_pv4_layer.html">IPv4Layer</a> -&gt; <a class="el" href="classpcpp_1_1_tcp_layer.html">TcpLayer</a> -&gt; <a class="el" href="classpcpp_1_1_http_request_layer.html">HttpRequestLayer</a> <br  />
 <a class="el" href="classpcpp_1_1_packet.html">Packet</a> instance isn't read only. The user can add or remove layers, update current layer, etc. </p>
</div><h2 class="groupheader">Constructor &amp; Destructor Documentation</h2>
<a id="a1a6d4e157661ba7ec6f552c78c82d7fa"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a1a6d4e157661ba7ec6f552c78c82d7fa">&#9670;&nbsp;</a></span>Packet() <span class="overload">[1/5]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">pcpp::Packet::Packet </td>
          <td>(</td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>maxPacketLen</em> = <code>1</code></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>A constructor for creating a new packet. Very useful when creating packets. When using this constructor an empty raw buffer is allocated (with the size of maxPacketLen) and a new <a class="el" href="classpcpp_1_1_raw_packet.html">RawPacket</a> is created </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">maxPacketLen</td><td>The expected packet length in bytes </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="aaf61c3f9a5c12a7047774b42f31ee2ec"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aaf61c3f9a5c12a7047774b42f31ee2ec">&#9670;&nbsp;</a></span>Packet() <span class="overload">[2/5]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">pcpp::Packet::Packet </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classpcpp_1_1_raw_packet.html">RawPacket</a> *&#160;</td>
          <td class="paramname"><em>rawPacket</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>freeRawPacket</em> = <code>false</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="namespacepcpp.html#a1d761f7cf37d3b1efb1574fb1177e6eb">ProtocolType</a>&#160;</td>
          <td class="paramname"><em>parseUntil</em> = <code><a class="el" href="namespacepcpp.html#a1d761f7cf37d3b1efb1574fb1177e6eba8576597b751111eab8ec156233a7fd29">UnknownProtocol</a></code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="namespacepcpp.html#a69e2ee6a9dc68797612cf8dc38461025">OsiModelLayer</a>&#160;</td>
          <td class="paramname"><em>parseUntilLayer</em> = <code><a class="el" href="namespacepcpp.html#a69e2ee6a9dc68797612cf8dc38461025aaa1b22ad907997f669b20cc0d3b7e87f">OsiModelLayerUnknown</a></code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>A constructor for creating a packet out of already allocated <a class="el" href="classpcpp_1_1_raw_packet.html">RawPacket</a>. Very useful when parsing packets that came from the network. When using this constructor a pointer to the <a class="el" href="classpcpp_1_1_raw_packet.html">RawPacket</a> is saved (data isn't copied) and the <a class="el" href="classpcpp_1_1_raw_packet.html">RawPacket</a> is parsed, meaning all layers are created and linked to each other in the right order. In this overload of the constructor the user can specify whether to free the instance of raw packet when the <a class="el" href="classpcpp_1_1_packet.html">Packet</a> is free or not </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">rawPacket</td><td>A pointer to the raw packet </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">freeRawPacket</td><td>Optional parameter. A flag indicating if the destructor should also call the raw packet destructor or not. Default value is false </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">parseUntil</td><td>Optional parameter. Parse the packet until you reach a certain protocol (inclusive). Can be useful for cases when you need to parse only up to a certain layer and want to avoid the performance impact and memory consumption of parsing the whole packet. Default value is <a class="el" href="namespacepcpp.html#a1d761f7cf37d3b1efb1574fb1177e6eba8576597b751111eab8ec156233a7fd29">UnknownProtocol</a> which means don't take this parameter into account </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">parseUntilLayer</td><td>Optional parameter. Parse the packet until you reach a certain layer in the OSI model (inclusive). Can be useful for cases when you need to parse only up to a certain OSI layer (for example transport layer) and want to avoid the performance impact and memory consumption of parsing the whole packet. Default value is <a class="el" href="namespacepcpp.html#a69e2ee6a9dc68797612cf8dc38461025aaa1b22ad907997f669b20cc0d3b7e87f">OsiModelLayerUnknown</a> which means don't take this parameter into account </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="aa9b12034dca53509c273e4ef954b8099"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aa9b12034dca53509c273e4ef954b8099">&#9670;&nbsp;</a></span>Packet() <span class="overload">[3/5]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">pcpp::Packet::Packet </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classpcpp_1_1_raw_packet.html">RawPacket</a> *&#160;</td>
          <td class="paramname"><em>rawPacket</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="namespacepcpp.html#a1d761f7cf37d3b1efb1574fb1177e6eb">ProtocolType</a>&#160;</td>
          <td class="paramname"><em>parseUntil</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>A constructor for creating a packet out of already allocated <a class="el" href="classpcpp_1_1_raw_packet.html">RawPacket</a>. Very useful when parsing packets that came from the network. When using this constructor a pointer to the <a class="el" href="classpcpp_1_1_raw_packet.html">RawPacket</a> is saved (data isn't copied) and the <a class="el" href="classpcpp_1_1_raw_packet.html">RawPacket</a> is parsed, meaning all layers are created and linked to each other in the right order. In this overload of the constructor the user can specify whether to free the instance of raw packet when the <a class="el" href="classpcpp_1_1_packet.html">Packet</a> is free or not. This constructor should be used to parse the packet up to a certain layer </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">rawPacket</td><td>A pointer to the raw packet </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">parseUntil</td><td>Optional parameter. Parse the packet until you reach a certain protocol (inclusive). Can be useful for cases when you need to parse only up to a certain layer and want to avoid the performance impact and memory consumption of parsing the whole packet </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a9af7caebc8d97ac92910d8a91186b461"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a9af7caebc8d97ac92910d8a91186b461">&#9670;&nbsp;</a></span>Packet() <span class="overload">[4/5]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">pcpp::Packet::Packet </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classpcpp_1_1_raw_packet.html">RawPacket</a> *&#160;</td>
          <td class="paramname"><em>rawPacket</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="namespacepcpp.html#a69e2ee6a9dc68797612cf8dc38461025">OsiModelLayer</a>&#160;</td>
          <td class="paramname"><em>parseUntilLayer</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>A constructor for creating a packet out of already allocated <a class="el" href="classpcpp_1_1_raw_packet.html">RawPacket</a>. Very useful when parsing packets that came from the network. When using this constructor a pointer to the <a class="el" href="classpcpp_1_1_raw_packet.html">RawPacket</a> is saved (data isn't copied) and the <a class="el" href="classpcpp_1_1_raw_packet.html">RawPacket</a> is parsed, meaning all layers are created and linked to each other in the right order. In this overload of the constructor the user can specify whether to free the instance of raw packet when the <a class="el" href="classpcpp_1_1_packet.html">Packet</a> is free or not. . This constructor should be used to parse the packet up to a certain layer in the OSI model </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">rawPacket</td><td>A pointer to the raw packet </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">parseUntilLayer</td><td>Optional parameter. Parse the packet until you reach a certain layer in the OSI model (inclusive). Can be useful for cases when you need to parse only up to a certain OSI layer (for example transport layer) and want to avoid the performance impact and memory consumption of parsing the whole packet </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a54ccf8336cf3c3f6a5ad58ad12f06656"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a54ccf8336cf3c3f6a5ad58ad12f06656">&#9670;&nbsp;</a></span>~Packet()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual pcpp::Packet::~Packet </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>A destructor for this class. Frees all layers allocated by this instance (Notice: it doesn't free layers that weren't allocated by this class, for example layers that were added by <a class="el" href="classpcpp_1_1_packet.html#ad43e09f561e9b8bfe32bc498c2fa3ec1">addLayer()</a> or <a class="el" href="classpcpp_1_1_packet.html#a0b84fbbd9a0e0074445b95d89103fa3e">insertLayer()</a> ). In addition it frees the raw packet if it was allocated by this instance (meaning if it was allocated by this instance constructor) </p>

</div>
</div>
<a id="a11d603615d2f100eec547d51b4a6282e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a11d603615d2f100eec547d51b4a6282e">&#9670;&nbsp;</a></span>Packet() <span class="overload">[5/5]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">pcpp::Packet::Packet </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classpcpp_1_1_packet.html">Packet</a> &amp;&#160;</td>
          <td class="paramname"><em>other</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>A copy constructor for this class. This copy constructor copies all the raw data and re-create all layers. So when the original <a class="el" href="classpcpp_1_1_packet.html">Packet</a> is being freed, no data will be lost in the copied instance </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">other</td><td>The instance to copy from </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<h2 class="groupheader">Member Function Documentation</h2>
<a id="ad43e09f561e9b8bfe32bc498c2fa3ec1"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ad43e09f561e9b8bfe32bc498c2fa3ec1">&#9670;&nbsp;</a></span>addLayer()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool pcpp::Packet::addLayer </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classpcpp_1_1_layer.html">Layer</a> *&#160;</td>
          <td class="paramname"><em>newLayer</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>ownInPacket</em> = <code>false</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Add a new layer as the last layer in the packet. This method gets a pointer to the new layer as a parameter and attaches it to the packet. Notice after calling this method the input layer is attached to the packet so every change you make in it affect the packet; Also it cannot be attached to other packets </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">newLayer</td><td>A pointer to the new layer to be added to the packet </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">ownInPacket</td><td>If true, <a class="el" href="classpcpp_1_1_packet.html">Packet</a> fully owns newLayer, including memory deletion upon destruct. Default is false. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>True if everything went well or false otherwise (an appropriate error log message will be printed in such cases) </dd></dl>

</div>
</div>
<a id="ab19addb15ea46927076227436fde753e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ab19addb15ea46927076227436fde753e">&#9670;&nbsp;</a></span>computeCalculateFields()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void pcpp::Packet::computeCalculateFields </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Each layer can have fields that can be calculate automatically from other fields using <a class="el" href="classpcpp_1_1_layer.html#abea112176d18e896f48214ca7accac71">Layer::computeCalculateFields()</a>. This method forces all layers to calculate these fields values </p>

</div>
</div>
<a id="ad4dbb6b0bedb3f58f6855aa0329a8908"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ad4dbb6b0bedb3f58f6855aa0329a8908">&#9670;&nbsp;</a></span>detachLayer() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool pcpp::Packet::detachLayer </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classpcpp_1_1_layer.html">Layer</a> *&#160;</td>
          <td class="paramname"><em>layer</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Detach a layer from the packet. Detaching means the layer instance will not be deleted, but rather seperated from the packet - e.g it will be removed from the layer chain of the packet and its data will be copied from the packet buffer into an internal layer buffer. After a layer is detached, it can be added into another packet (but it's impossible to attach a layer to multiple packets at the same time). After layer is detached, it's the user's responsibility to delete it when it's not needed anymore </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">layer</td><td>A pointer to the layer to detach </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>True if the layer was detached successfully, or false if something went wrong. In any case of failure an appropriate error log message will be printed </dd></dl>

</div>
</div>
<a id="a54d83577cda897699f28595477f2d92d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a54d83577cda897699f28595477f2d92d">&#9670;&nbsp;</a></span>detachLayer() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classpcpp_1_1_layer.html">Layer</a>* pcpp::Packet::detachLayer </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="namespacepcpp.html#a1d761f7cf37d3b1efb1574fb1177e6eb">ProtocolType</a>&#160;</td>
          <td class="paramname"><em>layerType</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>index</em> = <code>0</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Detach a layer from the packet. Detaching means the layer instance will not be deleted, but rather seperated from the packet - e.g it will be removed from the layer chain of the packet and its data will be copied from the packet buffer into an internal layer buffer. After a layer is detached, it can be added into another packet (but it's impossible to attach a layer to multiple packets in the same time). After layer is detached, it's the user's responsibility to delete it when it's not needed anymore </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">layerType</td><td>The layer type (protocol) to detach from the packet </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">index</td><td>If there are multiple layers of the same type, indicate which instance to detach. The default value is 0, meaning detach the first layer of this type </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>A pointer to the detached layer or NULL if detaching process failed. In any case of failure an appropriate error log message will be printed </dd></dl>

</div>
</div>
<a id="afbe8bb3d1c8ef829120fa1bc9bac5677"></a>
<h2 class="memtitle"><span class="permalink"><a href="#afbe8bb3d1c8ef829120fa1bc9bac5677">&#9670;&nbsp;</a></span>getFirstLayer()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classpcpp_1_1_layer.html">Layer</a>* pcpp::Packet::getFirstLayer </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Get a pointer to the first (lowest) layer in the packet </p><dl class="section return"><dt>Returns</dt><dd>A pointer to the first (lowest) layer in the packet </dd></dl>

</div>
</div>
<a id="aa207dcf476921fbd53959e7da47ad1ac"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aa207dcf476921fbd53959e7da47ad1ac">&#9670;&nbsp;</a></span>getLastLayer()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classpcpp_1_1_layer.html">Layer</a>* pcpp::Packet::getLastLayer </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Get a pointer to the last (highest) layer in the packet </p><dl class="section return"><dt>Returns</dt><dd>A pointer to the last (highest) layer in the packet </dd></dl>

</div>
</div>
<a id="aeb239964f13a6d47b54bfd919f9af25e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aeb239964f13a6d47b54bfd919f9af25e">&#9670;&nbsp;</a></span>getLayerOfType() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class TLayer &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">TLayer * pcpp::Packet::getLayerOfType </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>A templated method to get a layer of a certain type (protocol). If no layer of such type is found, NULL is returned </p><dl class="section return"><dt>Returns</dt><dd>A pointer to the layer of the requested type, NULL if not found </dd></dl>

</div>
</div>
<a id="a952f7939f5044c45bef2bde38ed22b61"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a952f7939f5044c45bef2bde38ed22b61">&#9670;&nbsp;</a></span>getLayerOfType() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classpcpp_1_1_layer.html">Layer</a>* pcpp::Packet::getLayerOfType </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="namespacepcpp.html#a1d761f7cf37d3b1efb1574fb1177e6eb">ProtocolType</a>&#160;</td>
          <td class="paramname"><em>layerType</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>index</em> = <code>0</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Get a pointer to the layer of a certain type (protocol). This method goes through the layers and returns a layer that matches the give protocol type </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">layerType</td><td>The layer type (protocol) to fetch </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">index</td><td>If there are multiple layers of the same type, indicate which instance to fetch. The default value is 0, meaning fetch the first layer of this type </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>A pointer to the layer or NULL if no such layer was found </dd></dl>

</div>
</div>
<a id="a7c9c78143afae5d5e91ce89f0b38acb3"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a7c9c78143afae5d5e91ce89f0b38acb3">&#9670;&nbsp;</a></span>getNextLayerOfType()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class TLayer &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">TLayer * pcpp::Packet::getNextLayerOfType </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classpcpp_1_1_layer.html">Layer</a> *&#160;</td>
          <td class="paramname"><em>after</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>A templated method to get the first layer of a certain type (protocol), start searching from a certain layer. For example: if a packet looks like: <a class="el" href="classpcpp_1_1_eth_layer.html">EthLayer</a> -&gt; VlanLayer(1) -&gt; VlanLayer(2) -&gt; VlanLayer(3) -&gt; <a class="el" href="classpcpp_1_1_i_pv4_layer.html">IPv4Layer</a> and the user put VlanLayer(2) as a parameter and wishes to search for a <a class="el" href="classpcpp_1_1_vlan_layer.html">VlanLayer</a>, VlanLayer(3) will be returned If no layer of such type is found, NULL is returned </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">after</td><td>A pointer to the layer to start search from </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>A pointer to the layer of the requested type, NULL if not found </dd></dl>

</div>
</div>
<a id="a56ef03e8516ee79b8ac397db0f052e89"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a56ef03e8516ee79b8ac397db0f052e89">&#9670;&nbsp;</a></span>getRawPacket()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classpcpp_1_1_raw_packet.html">RawPacket</a>* pcpp::Packet::getRawPacket </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Get a pointer to the <a class="el" href="classpcpp_1_1_packet.html">Packet</a>'s <a class="el" href="classpcpp_1_1_raw_packet.html">RawPacket</a> </p><dl class="section return"><dt>Returns</dt><dd>A pointer to the <a class="el" href="classpcpp_1_1_packet.html">Packet</a>'s <a class="el" href="classpcpp_1_1_raw_packet.html">RawPacket</a> </dd></dl>

</div>
</div>
<a id="a1c4fede8a4bee643ee85bfbc4ddd7174"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a1c4fede8a4bee643ee85bfbc4ddd7174">&#9670;&nbsp;</a></span>getRawPacketReadOnly()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classpcpp_1_1_raw_packet.html">RawPacket</a>* pcpp::Packet::getRawPacketReadOnly </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Get a pointer to the <a class="el" href="classpcpp_1_1_packet.html">Packet</a>'s <a class="el" href="classpcpp_1_1_raw_packet.html">RawPacket</a> in a read-only manner </p><dl class="section return"><dt>Returns</dt><dd>A pointer to the <a class="el" href="classpcpp_1_1_packet.html">Packet</a>'s <a class="el" href="classpcpp_1_1_raw_packet.html">RawPacket</a> </dd></dl>

</div>
</div>
<a id="a0b84fbbd9a0e0074445b95d89103fa3e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a0b84fbbd9a0e0074445b95d89103fa3e">&#9670;&nbsp;</a></span>insertLayer()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool pcpp::Packet::insertLayer </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classpcpp_1_1_layer.html">Layer</a> *&#160;</td>
          <td class="paramname"><em>prevLayer</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classpcpp_1_1_layer.html">Layer</a> *&#160;</td>
          <td class="paramname"><em>newLayer</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>ownInPacket</em> = <code>false</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Insert a new layer after an existing layer in the packet. This method gets a pointer to the new layer as a parameter and attaches it to the packet. Notice after calling this method the input layer is attached to the packet so every change you make in it affect the packet; Also it cannot be attached to other packets </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">prevLayer</td><td>A pointer to an existing layer in the packet which the new layer should followed by. If this layer isn't attached to a packet and error will be printed to log and false will be returned </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">newLayer</td><td>A pointer to the new layer to be added to the packet </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">ownInPacket</td><td>If true, <a class="el" href="classpcpp_1_1_packet.html">Packet</a> fully owns newLayer, including memory deletion upon destruct. Default is false. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>True if everything went well or false otherwise (an appropriate error log message will be printed in such cases) </dd></dl>

</div>
</div>
<a id="a0638363f7edf78cbedd239c92c647c24"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a0638363f7edf78cbedd239c92c647c24">&#9670;&nbsp;</a></span>isPacketOfType()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool pcpp::Packet::isPacketOfType </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="namespacepcpp.html#a1d761f7cf37d3b1efb1574fb1177e6eb">ProtocolType</a>&#160;</td>
          <td class="paramname"><em>protocolType</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Check whether the packet contains a certain protocol </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">protocolType</td><td>The protocol type to search </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>True if the packet contains the protocol, false otherwise </dd></dl>

</div>
</div>
<a id="a26af180628893e454e9d6e0f2f1ebb98"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a26af180628893e454e9d6e0f2f1ebb98">&#9670;&nbsp;</a></span>operator=()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classpcpp_1_1_packet.html">Packet</a>&amp; pcpp::Packet::operator= </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classpcpp_1_1_packet.html">Packet</a> &amp;&#160;</td>
          <td class="paramname"><em>other</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Assignment operator overloading. It first frees all layers allocated by this instance (Notice: it doesn't free layers that weren't allocated by this class, for example layers that were added by <a class="el" href="classpcpp_1_1_packet.html#ad43e09f561e9b8bfe32bc498c2fa3ec1">addLayer()</a> or <a class="el" href="classpcpp_1_1_packet.html#a0b84fbbd9a0e0074445b95d89103fa3e">insertLayer()</a> ). In addition it frees the raw packet if it was allocated by this instance (meaning if it was allocated by this instance constructor). Afterwards it copies the data from the other packet in the same way used in the copy constructor. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">other</td><td>The instance to copy from </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a864c0024b5bc88a4ba7c55373ff2ee01"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a864c0024b5bc88a4ba7c55373ff2ee01">&#9670;&nbsp;</a></span>removeAllLayersAfter()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool pcpp::Packet::removeAllLayersAfter </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classpcpp_1_1_layer.html">Layer</a> *&#160;</td>
          <td class="paramname"><em>layer</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Remove all layers that come after a certain layer. All layers removed will be deleted if they were allocated during packet creation or detached if were allocated outside of the packet, please refer to <a class="el" href="classpcpp_1_1_packet.html#a28fbabf49349df90548ac7c085b1cff3">removeLayer()</a> to get more info </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">layer</td><td>A pointer to the layer to begin removing from. Please note this layer will not be removed, only the layers that come after it will be removed. Also, if removal of one layer failed, the method will return immediately and the following layers won't be deleted </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>True if all layers were removed successfully, or false if failed to remove at least one layer. In any case of failure an appropriate error log message will be printed </dd></dl>

</div>
</div>
<a id="a2e7755654f74cc1280409f3f42d9c9e3"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a2e7755654f74cc1280409f3f42d9c9e3">&#9670;&nbsp;</a></span>removeFirstLayer()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool pcpp::Packet::removeFirstLayer </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Remove the first layer in the packet. The layer will be deleted if it was allocated during packet creation, or detached if was allocated outside of the packet. Please refer to <a class="el" href="classpcpp_1_1_packet.html#a28fbabf49349df90548ac7c085b1cff3">removeLayer()</a> to get more info </p><dl class="section return"><dt>Returns</dt><dd>True if layer removed successfully, or false if removing the layer failed or if there are no layers in the packet. In any case of failure an appropriate error log message will be printed </dd></dl>

</div>
</div>
<a id="abda544ac8ac70142f086f63b25ff200c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#abda544ac8ac70142f086f63b25ff200c">&#9670;&nbsp;</a></span>removeLastLayer()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool pcpp::Packet::removeLastLayer </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Remove the last layer in the packet. The layer will be deleted if it was allocated during packet creation, or detached if was allocated outside of the packet. Please refer to <a class="el" href="classpcpp_1_1_packet.html#a28fbabf49349df90548ac7c085b1cff3">removeLayer()</a> to get more info </p><dl class="section return"><dt>Returns</dt><dd>True if layer removed successfully, or false if removing the layer failed or if there are no layers in the packet. In any case of failure an appropriate error log message will be printed </dd></dl>

</div>
</div>
<a id="a28fbabf49349df90548ac7c085b1cff3"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a28fbabf49349df90548ac7c085b1cff3">&#9670;&nbsp;</a></span>removeLayer()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool pcpp::Packet::removeLayer </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="namespacepcpp.html#a1d761f7cf37d3b1efb1574fb1177e6eb">ProtocolType</a>&#160;</td>
          <td class="paramname"><em>layerType</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>index</em> = <code>0</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Remove an existing layer from the packet. The layer to removed is identified by its type (protocol). If the packet has multiple layers of the same type in the packet the user may specify the index of the layer to remove (the default index is 0 - remove the first layer of this type). If the layer was allocated during packet creation it will be deleted and any pointer to it will get invalid. However if the layer was allocated by the user and manually added to the packet it will simply get detached from the packet, meaning the pointer to it will stay valid and its data (that was removed from the packet) will be copied back to the layer. In that case it's the user's responsibility to delete the layer instance </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">layerType</td><td>The layer type (protocol) to remove </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">index</td><td>If there are multiple layers of the same type, indicate which instance to remove. The default value is 0, meaning remove the first layer of this type </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>True if everything went well or false otherwise (an appropriate error log message will be printed in such cases) </dd></dl>

</div>
</div>
<a id="a1dee26fe9bb8c7ae6cd90f45e67446ef"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a1dee26fe9bb8c7ae6cd90f45e67446ef">&#9670;&nbsp;</a></span>setRawPacket()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void pcpp::Packet::setRawPacket </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classpcpp_1_1_raw_packet.html">RawPacket</a> *&#160;</td>
          <td class="paramname"><em>rawPacket</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>freeRawPacket</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="namespacepcpp.html#a1d761f7cf37d3b1efb1574fb1177e6eb">ProtocolType</a>&#160;</td>
          <td class="paramname"><em>parseUntil</em> = <code><a class="el" href="namespacepcpp.html#a1d761f7cf37d3b1efb1574fb1177e6eba8576597b751111eab8ec156233a7fd29">UnknownProtocol</a></code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="namespacepcpp.html#a69e2ee6a9dc68797612cf8dc38461025">OsiModelLayer</a>&#160;</td>
          <td class="paramname"><em>parseUntilLayer</em> = <code><a class="el" href="namespacepcpp.html#a69e2ee6a9dc68797612cf8dc38461025aaa1b22ad907997f669b20cc0d3b7e87f">OsiModelLayerUnknown</a></code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Set a <a class="el" href="classpcpp_1_1_raw_packet.html">RawPacket</a> and re-construct all packet layers </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">rawPacket</td><td>Raw packet to set </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">freeRawPacket</td><td>A flag indicating if the destructor should also call the raw packet destructor or not </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">parseUntil</td><td>Parse the packet until it reaches this protocol. Can be useful for cases when you need to parse only up to a certain layer and want to avoid the performance impact and memory consumption of parsing the whole packet. Default value is <a class="el" href="namespacepcpp.html#a1d761f7cf37d3b1efb1574fb1177e6eba8576597b751111eab8ec156233a7fd29">UnknownProtocol</a> which means don't take this parameter into account </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">parseUntilLayer</td><td>Parse the packet until certain layer in OSI model. Can be useful for cases when you need to parse only up to a certain layer and want to avoid the performance impact and memory consumption of parsing the whole packet. Default value is <a class="el" href="namespacepcpp.html#a69e2ee6a9dc68797612cf8dc38461025aaa1b22ad907997f669b20cc0d3b7e87f">OsiModelLayerUnknown</a> which means don't take this parameter into account </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a8c3a62bbd020dc2e88147be71876a758"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a8c3a62bbd020dc2e88147be71876a758">&#9670;&nbsp;</a></span>toString()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">std::string pcpp::Packet::toString </td>
          <td>(</td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>timeAsLocalTime</em> = <code>true</code></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Each layer can print a string representation of the layer most important data using <a class="el" href="classpcpp_1_1_layer.html#a1d07ea14d02b4a5cb383f89b3f40ed63">Layer::toString()</a>. This method aggregates this string from all layers and print it to a complete string containing all packet's relevant data </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">timeAsLocalTime</td><td>Print time as local time or GMT. Default (true value) is local time, for GMT set to false </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>A string containing most relevant data from all layers (looks like the packet description in Wireshark) </dd></dl>

</div>
</div>
<a id="ab565f9f2bb5099c83ccf25e917e6257c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ab565f9f2bb5099c83ccf25e917e6257c">&#9670;&nbsp;</a></span>toStringList()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void pcpp::Packet::toStringList </td>
          <td>(</td>
          <td class="paramtype">std::vector&lt; std::string &gt; &amp;&#160;</td>
          <td class="paramname"><em>result</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>timeAsLocalTime</em> = <code>true</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Similar to <a class="el" href="classpcpp_1_1_packet.html#a8c3a62bbd020dc2e88147be71876a758">toString()</a>, but instead of one string it outputs a list of strings, one string for every layer </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[out]</td><td class="paramname">result</td><td>A string vector that will contain all strings </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">timeAsLocalTime</td><td>Print time as local time or GMT. Default (true value) is local time, for GMT set to false </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
</div><!-- contents -->
</div><!-- doc-content -->
<!-- start footer part -->
<div id="nav-path" class="navpath"><!-- id is needed for treeview function! -->
  <ul>
    <li class="navelem"><a class="el" href="namespacepcpp.html">pcpp</a></li><li class="navelem"><a class="el" href="classpcpp_1_1_packet.html">Packet</a></li>
    <li class="footer">Generated on Mon Dec 2 2019 23:53:23 for PcapPlusPlus by
    <a href="http://www.doxygen.org/index.html">
    <img class="footer" src="doxygen.png" alt="doxygen"/></a> 1.8.16 </li>
  </ul>
</div>
</body>
</html>
