<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "https://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=9"/>
<meta name="generator" content="Doxygen 1.8.16"/>
<meta name="viewport" content="width=device-width, initial-scale=1"/>
<title>PcapPlusPlus: pcpp::IPReassembly Class Reference</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<link href="navtree.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="resize.js"></script>
<script type="text/javascript" src="navtreedata.js"></script>
<script type="text/javascript" src="navtree.js"></script>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:cf05388f2679ee054f2beb29a391d25f4e673ac3&amp;dn=gpl-2.0.txt GPL-v2 */
  $(document).ready(initResizable);
/* @license-end */</script>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/searchdata.js"></script>
<script type="text/javascript" src="search/search.js"></script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
<link href="doxygen-mobile.css" rel="stylesheet" type="text/css"/>
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr style="height: 56px;">
  <td id="projectlogo"><img alt="Logo" src="logo_icon_large.ico"/></td>
  <td id="projectalign" style="padding-left: 0.5em;">
   <div id="projectname">PcapPlusPlus
   &#160;<span id="projectnumber">19.12</span>
   </div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.8.16 -->
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:cf05388f2679ee054f2beb29a391d25f4e673ac3&amp;dn=gpl-2.0.txt GPL-v2 */
var searchBox = new SearchBox("searchBox", "search",false,'Search');
/* @license-end */
</script>
<script type="text/javascript" src="menudata.js"></script>
<script type="text/javascript" src="menu.js"></script>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:cf05388f2679ee054f2beb29a391d25f4e673ac3&amp;dn=gpl-2.0.txt GPL-v2 */
$(function() {
  initMenu('',true,false,'search.php','Search');
  $(document).ready(function() { init_search(); });
});
/* @license-end */</script>
<div id="main-nav"></div>
</div><!-- top -->
<div id="side-nav" class="ui-resizable side-nav-resizable">
  <div id="nav-tree">
    <div id="nav-tree-contents">
      <div id="nav-sync" class="sync"></div>
    </div>
  </div>
  <div id="splitbar" style="-moz-user-select:none;" 
       class="ui-resizable-handle">
  </div>
</div>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:cf05388f2679ee054f2beb29a391d25f4e673ac3&amp;dn=gpl-2.0.txt GPL-v2 */
$(document).ready(function(){initNavTree('classpcpp_1_1_i_p_reassembly.html','');});
/* @license-end */
</script>
<div id="doc-content">
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
</div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<iframe src="javascript:void(0)" frameborder="0" 
        name="MSearchResults" id="MSearchResults">
</iframe>
</div>

<div class="header">
  <div class="summary">
<a href="#nested-classes">Classes</a> &#124;
<a href="#pub-types">Public Types</a> &#124;
<a href="#pub-methods">Public Member Functions</a> &#124;
<a href="classpcpp_1_1_i_p_reassembly-members.html">List of all members</a>  </div>
  <div class="headertitle">
<div class="title">pcpp::IPReassembly Class Reference</div>  </div>
</div><!--header-->
<div class="contents">

<p><code>#include &lt;<a class="el" href="_i_p_reassembly_8h_source.html">IPReassembly.h</a>&gt;</code></p>
<table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="nested-classes"></a>
Classes</h2></td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classpcpp_1_1_i_p_reassembly_1_1_i_pv4_packet_key.html">IPv4PacketKey</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classpcpp_1_1_i_p_reassembly_1_1_i_pv6_packet_key.html">IPv6PacketKey</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classpcpp_1_1_i_p_reassembly_1_1_packet_key.html">PacketKey</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="pub-types"></a>
Public Types</h2></td></tr>
<tr class="memitem:aae7f2e113808978827abf3b7cdbe91af"><td class="memItemLeft" align="right" valign="top">enum &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classpcpp_1_1_i_p_reassembly.html#aae7f2e113808978827abf3b7cdbe91af">ReassemblyStatus</a> { <br />
&#160;&#160;<a class="el" href="classpcpp_1_1_i_p_reassembly.html#aae7f2e113808978827abf3b7cdbe91afae35ca23b99eef8c92cb89994c1ee5e04">NON_IP_PACKET</a> = 0x00, 
<a class="el" href="classpcpp_1_1_i_p_reassembly.html#aae7f2e113808978827abf3b7cdbe91afad646e48ec06733b9c603a3dc89d57494">NON_FRAGMENT</a> = 0x01, 
<a class="el" href="classpcpp_1_1_i_p_reassembly.html#aae7f2e113808978827abf3b7cdbe91afa0314585fac91b7f1260e0c2ac8409425">FIRST_FRAGMENT</a> = 0x02, 
<a class="el" href="classpcpp_1_1_i_p_reassembly.html#aae7f2e113808978827abf3b7cdbe91afa59d0c69d880e6597e02931f805416653">FRAGMENT</a> = 0x04, 
<br />
&#160;&#160;<a class="el" href="classpcpp_1_1_i_p_reassembly.html#aae7f2e113808978827abf3b7cdbe91afa720ffdf993a5a1f3e344be2cfda6cb1c">OUT_OF_ORDER_FRAGMENT</a> = 0x08, 
<a class="el" href="classpcpp_1_1_i_p_reassembly.html#aae7f2e113808978827abf3b7cdbe91afa9bfbeeb420ef09c3bc62c3e56f28c6b0">MALFORMED_FRAGMENT</a> = 0x10, 
<a class="el" href="classpcpp_1_1_i_p_reassembly.html#aae7f2e113808978827abf3b7cdbe91afa91beabc1fd8775d590a7d6415aeb6a31">REASSEMBLED</a> = 0x20
<br />
 }</td></tr>
<tr class="separator:aae7f2e113808978827abf3b7cdbe91af"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8836fa2c9aca7ee90a2f6cf44ec12a8a"><td class="memItemLeft" align="right" valign="top">typedef void(*&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classpcpp_1_1_i_p_reassembly.html#a8836fa2c9aca7ee90a2f6cf44ec12a8a">OnFragmentsClean</a>) (const <a class="el" href="classpcpp_1_1_i_p_reassembly_1_1_packet_key.html">PacketKey</a> *key, void *userCookie)</td></tr>
<tr class="separator:a8836fa2c9aca7ee90a2f6cf44ec12a8a"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="pub-methods"></a>
Public Member Functions</h2></td></tr>
<tr class="memitem:a9a55c126f0361bc1a928d0e39924c16d"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classpcpp_1_1_i_p_reassembly.html#a9a55c126f0361bc1a928d0e39924c16d">IPReassembly</a> (<a class="el" href="classpcpp_1_1_i_p_reassembly.html#a8836fa2c9aca7ee90a2f6cf44ec12a8a">OnFragmentsClean</a> onFragmentsCleanCallback=NULL, void *callbackUserCookie=NULL, size_t maxPacketsToStore=500000)</td></tr>
<tr class="separator:a9a55c126f0361bc1a928d0e39924c16d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad3a3885752f5254e99d8a3b0d59f1507"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classpcpp_1_1_i_p_reassembly.html#ad3a3885752f5254e99d8a3b0d59f1507">~IPReassembly</a> ()</td></tr>
<tr class="separator:ad3a3885752f5254e99d8a3b0d59f1507"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a92fcfd5f8b3cfe10c0c69ee24d2766f7"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classpcpp_1_1_packet.html">Packet</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classpcpp_1_1_i_p_reassembly.html#a92fcfd5f8b3cfe10c0c69ee24d2766f7">processPacket</a> (<a class="el" href="classpcpp_1_1_packet.html">Packet</a> *fragment, <a class="el" href="classpcpp_1_1_i_p_reassembly.html#aae7f2e113808978827abf3b7cdbe91af">ReassemblyStatus</a> &amp;status, <a class="el" href="namespacepcpp.html#a1d761f7cf37d3b1efb1574fb1177e6eb">ProtocolType</a> parseUntil=<a class="el" href="namespacepcpp.html#a1d761f7cf37d3b1efb1574fb1177e6eba8576597b751111eab8ec156233a7fd29">UnknownProtocol</a>, <a class="el" href="namespacepcpp.html#a69e2ee6a9dc68797612cf8dc38461025">OsiModelLayer</a> parseUntilLayer=<a class="el" href="namespacepcpp.html#a69e2ee6a9dc68797612cf8dc38461025aaa1b22ad907997f669b20cc0d3b7e87f">OsiModelLayerUnknown</a>)</td></tr>
<tr class="separator:a92fcfd5f8b3cfe10c0c69ee24d2766f7"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a97763fcf5926f60684cbbe3fda79cba4"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classpcpp_1_1_packet.html">Packet</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classpcpp_1_1_i_p_reassembly.html#a97763fcf5926f60684cbbe3fda79cba4">processPacket</a> (<a class="el" href="classpcpp_1_1_raw_packet.html">RawPacket</a> *fragment, <a class="el" href="classpcpp_1_1_i_p_reassembly.html#aae7f2e113808978827abf3b7cdbe91af">ReassemblyStatus</a> &amp;status, <a class="el" href="namespacepcpp.html#a1d761f7cf37d3b1efb1574fb1177e6eb">ProtocolType</a> parseUntil=<a class="el" href="namespacepcpp.html#a1d761f7cf37d3b1efb1574fb1177e6eba8576597b751111eab8ec156233a7fd29">UnknownProtocol</a>, <a class="el" href="namespacepcpp.html#a69e2ee6a9dc68797612cf8dc38461025">OsiModelLayer</a> parseUntilLayer=<a class="el" href="namespacepcpp.html#a69e2ee6a9dc68797612cf8dc38461025aaa1b22ad907997f669b20cc0d3b7e87f">OsiModelLayerUnknown</a>)</td></tr>
<tr class="separator:a97763fcf5926f60684cbbe3fda79cba4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0efa8ec7258bbc0a83348bae42f93506"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classpcpp_1_1_packet.html">Packet</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classpcpp_1_1_i_p_reassembly.html#a0efa8ec7258bbc0a83348bae42f93506">getCurrentPacket</a> (const <a class="el" href="classpcpp_1_1_i_p_reassembly_1_1_packet_key.html">PacketKey</a> &amp;key)</td></tr>
<tr class="separator:a0efa8ec7258bbc0a83348bae42f93506"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a72d9dea60bb16f09caadd0b82c00afd6"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classpcpp_1_1_i_p_reassembly.html#a72d9dea60bb16f09caadd0b82c00afd6">removePacket</a> (const <a class="el" href="classpcpp_1_1_i_p_reassembly_1_1_packet_key.html">PacketKey</a> &amp;key)</td></tr>
<tr class="separator:a72d9dea60bb16f09caadd0b82c00afd6"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5bb295b6ae27f40ca10c379340540e3f"><td class="memItemLeft" align="right" valign="top">size_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classpcpp_1_1_i_p_reassembly.html#a5bb295b6ae27f40ca10c379340540e3f">getMaxCapacity</a> () const</td></tr>
<tr class="separator:a5bb295b6ae27f40ca10c379340540e3f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:adc24c508640b64fe41eefa99a5296800"><td class="memItemLeft" align="right" valign="top">size_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classpcpp_1_1_i_p_reassembly.html#adc24c508640b64fe41eefa99a5296800">getCurrentCapacity</a> () const</td></tr>
<tr class="separator:adc24c508640b64fe41eefa99a5296800"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table>
<a name="details" id="details"></a><h2 class="groupheader">Detailed Description</h2>
<div class="textblock"><p>Contains the IP reassembly (a.k.a IP de-fragmentation) mechanism. Encapsulates both IPv4 and IPv6 reassembly. Please refer to the documentation at the top of <a class="el" href="_i_p_reassembly_8h.html">IPReassembly.h</a> to understand how this mechanism works. The main APIs are:</p><ul>
<li><a class="el" href="classpcpp_1_1_i_p_reassembly.html#a92fcfd5f8b3cfe10c0c69ee24d2766f7">IPReassembly::processPacket()</a> - process a fragment. This is the main method which should be called whenever a new fragment arrives. This method processes the fragment, runs the reassembly logic and returns the result packet when it's fully reassembled</li>
<li><a class="el" href="classpcpp_1_1_i_p_reassembly.html#a0efa8ec7258bbc0a83348bae42f93506">IPReassembly::getCurrentPacket()</a> - get the reassembled data that is currently available, even if reassembly process is not yet completed</li>
<li><a class="el" href="classpcpp_1_1_i_p_reassembly.html#a72d9dea60bb16f09caadd0b82c00afd6">IPReassembly::removePacket()</a> - remove all data that is currently stored for a packet, including the reassembled data that was gathered so far </li>
</ul>
</div><h2 class="groupheader">Member Typedef Documentation</h2>
<a id="a8836fa2c9aca7ee90a2f6cf44ec12a8a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a8836fa2c9aca7ee90a2f6cf44ec12a8a">&#9670;&nbsp;</a></span>OnFragmentsClean</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">pcpp::IPReassembly::OnFragmentsClean</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>The IP reassembly mechanism has a certain capacity of concurrent packets it can handle. This capacity is determined in its c'tor (default value is <a class="el" href="_i_p_reassembly_8h.html#a15bf1bb934fcb4a1d7ea4093edd598c5">PCPP_IP_REASSEMBLY_DEFAULT_MAX_PACKETS_TO_STORE</a>). When traffic volume exceeds this capacity the mechanism starts dropping packets in a LRU manner (least recently used are dropped first). Whenever a packet is dropped this callback is fired </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">key</td><td>A pointer to the identifier of the packet that is being dropped </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">userCookie</td><td>A pointer to the cookie provided by the user in IPReassemby c'tor (or NULL if no cookie provided) </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<h2 class="groupheader">Member Enumeration Documentation</h2>
<a id="aae7f2e113808978827abf3b7cdbe91af"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aae7f2e113808978827abf3b7cdbe91af">&#9670;&nbsp;</a></span>ReassemblyStatus</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">enum <a class="el" href="classpcpp_1_1_i_p_reassembly.html#aae7f2e113808978827abf3b7cdbe91af">pcpp::IPReassembly::ReassemblyStatus</a></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>An enum representing the status returned from processing a fragment </p>
<table class="fieldtable">
<tr><th colspan="2">Enumerator</th></tr><tr><td class="fieldname"><a id="aae7f2e113808978827abf3b7cdbe91afae35ca23b99eef8c92cb89994c1ee5e04"></a>NON_IP_PACKET&#160;</td><td class="fielddoc"><p>The processed packet isn't of type IPv4 or IPv6 </p>
</td></tr>
<tr><td class="fieldname"><a id="aae7f2e113808978827abf3b7cdbe91afad646e48ec06733b9c603a3dc89d57494"></a>NON_FRAGMENT&#160;</td><td class="fielddoc"><p>The processed packet isn't a fragment </p>
</td></tr>
<tr><td class="fieldname"><a id="aae7f2e113808978827abf3b7cdbe91afa0314585fac91b7f1260e0c2ac8409425"></a>FIRST_FRAGMENT&#160;</td><td class="fielddoc"><p>The processed fragment is the first fragment </p>
</td></tr>
<tr><td class="fieldname"><a id="aae7f2e113808978827abf3b7cdbe91afa59d0c69d880e6597e02931f805416653"></a>FRAGMENT&#160;</td><td class="fielddoc"><p>The processed fragment is a fragment (but not the first one) </p>
</td></tr>
<tr><td class="fieldname"><a id="aae7f2e113808978827abf3b7cdbe91afa720ffdf993a5a1f3e344be2cfda6cb1c"></a>OUT_OF_ORDER_FRAGMENT&#160;</td><td class="fielddoc"><p>The processed fragment is not the fragment that was expected at this time </p>
</td></tr>
<tr><td class="fieldname"><a id="aae7f2e113808978827abf3b7cdbe91afa9bfbeeb420ef09c3bc62c3e56f28c6b0"></a>MALFORMED_FRAGMENT&#160;</td><td class="fielddoc"><p>The processed fragment is malformed, meaning a fragment which has offset of zero but isn't the first fragment </p>
</td></tr>
<tr><td class="fieldname"><a id="aae7f2e113808978827abf3b7cdbe91afa91beabc1fd8775d590a7d6415aeb6a31"></a>REASSEMBLED&#160;</td><td class="fielddoc"><p><a class="el" href="classpcpp_1_1_packet.html">Packet</a> is now fully reassembled </p>
</td></tr>
</table>

</div>
</div>
<h2 class="groupheader">Constructor &amp; Destructor Documentation</h2>
<a id="a9a55c126f0361bc1a928d0e39924c16d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a9a55c126f0361bc1a928d0e39924c16d">&#9670;&nbsp;</a></span>IPReassembly()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">pcpp::IPReassembly::IPReassembly </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classpcpp_1_1_i_p_reassembly.html#a8836fa2c9aca7ee90a2f6cf44ec12a8a">OnFragmentsClean</a>&#160;</td>
          <td class="paramname"><em>onFragmentsCleanCallback</em> = <code>NULL</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">void *&#160;</td>
          <td class="paramname"><em>callbackUserCookie</em> = <code>NULL</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>maxPacketsToStore</em> = <code>500000</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>A c'tor for this class. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">onFragmentsCleanCallback</td><td>The callback to be called when packets are dropped due to capacity limit. Please read more about capacity limit in <a class="el" href="_i_p_reassembly_8h.html">IPReassembly.h</a> file description. This parameter is optional, default value is NULL (no callback) </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">callbackUserCookie</td><td>A pointer to an object provided by the user. This pointer will be returned when invoking the onFragmentsCleanCallback. This parameter is optional, default cookie is NULL </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">maxPacketsToStore</td><td>Set the capacity limit of the IP reassembly mechanism. Default capacity is <a class="el" href="_i_p_reassembly_8h.html#a15bf1bb934fcb4a1d7ea4093edd598c5">PCPP_IP_REASSEMBLY_DEFAULT_MAX_PACKETS_TO_STORE</a> </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="ad3a3885752f5254e99d8a3b0d59f1507"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ad3a3885752f5254e99d8a3b0d59f1507">&#9670;&nbsp;</a></span>~IPReassembly()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">pcpp::IPReassembly::~IPReassembly </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>A d'tor for this class </p>

</div>
</div>
<h2 class="groupheader">Member Function Documentation</h2>
<a id="adc24c508640b64fe41eefa99a5296800"></a>
<h2 class="memtitle"><span class="permalink"><a href="#adc24c508640b64fe41eefa99a5296800">&#9670;&nbsp;</a></span>getCurrentCapacity()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">size_t pcpp::IPReassembly::getCurrentCapacity </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Get the current number of packets being processed </p>

</div>
</div>
<a id="a0efa8ec7258bbc0a83348bae42f93506"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a0efa8ec7258bbc0a83348bae42f93506">&#9670;&nbsp;</a></span>getCurrentPacket()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classpcpp_1_1_packet.html">Packet</a>* pcpp::IPReassembly::getCurrentPacket </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classpcpp_1_1_i_p_reassembly_1_1_packet_key.html">PacketKey</a> &amp;&#160;</td>
          <td class="paramname"><em>key</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Get a partially reassembled packet. This method returns all the reassembled data that was gathered so far which is obviously not a fully reassembled packet (otherwise it would have returned by <a class="el" href="classpcpp_1_1_i_p_reassembly.html#a92fcfd5f8b3cfe10c0c69ee24d2766f7">processPacket()</a>). Notice all data is being copied so the user is responsible to free the returned <a class="el" href="classpcpp_1_1_packet.html">Packet</a> object when done using it. Notice#2 - calling this method doesn't interfere with the reassembly of this packet - all internal structures and data remain </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">key</td><td>The identifiers of the packet to return </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>A pointer to a <a class="el" href="classpcpp_1_1_packet.html">Packet</a> object containing the partially reassembled packet. Notice the user is responsible to free this object when done using it </dd></dl>

</div>
</div>
<a id="a5bb295b6ae27f40ca10c379340540e3f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a5bb295b6ae27f40ca10c379340540e3f">&#9670;&nbsp;</a></span>getMaxCapacity()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">size_t pcpp::IPReassembly::getMaxCapacity </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Get the maximum capacity as determined in the c'tor </p>

</div>
</div>
<a id="a92fcfd5f8b3cfe10c0c69ee24d2766f7"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a92fcfd5f8b3cfe10c0c69ee24d2766f7">&#9670;&nbsp;</a></span>processPacket() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classpcpp_1_1_packet.html">Packet</a>* pcpp::IPReassembly::processPacket </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classpcpp_1_1_packet.html">Packet</a> *&#160;</td>
          <td class="paramname"><em>fragment</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classpcpp_1_1_i_p_reassembly.html#aae7f2e113808978827abf3b7cdbe91af">ReassemblyStatus</a> &amp;&#160;</td>
          <td class="paramname"><em>status</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="namespacepcpp.html#a1d761f7cf37d3b1efb1574fb1177e6eb">ProtocolType</a>&#160;</td>
          <td class="paramname"><em>parseUntil</em> = <code><a class="el" href="namespacepcpp.html#a1d761f7cf37d3b1efb1574fb1177e6eba8576597b751111eab8ec156233a7fd29">UnknownProtocol</a></code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="namespacepcpp.html#a69e2ee6a9dc68797612cf8dc38461025">OsiModelLayer</a>&#160;</td>
          <td class="paramname"><em>parseUntilLayer</em> = <code><a class="el" href="namespacepcpp.html#a69e2ee6a9dc68797612cf8dc38461025aaa1b22ad907997f669b20cc0d3b7e87f">OsiModelLayerUnknown</a></code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>The main API that drives <a class="el" href="classpcpp_1_1_i_p_reassembly.html">IPReassembly</a>. This method should be called whenever a fragment arrives. This method finds the relevant packet this fragment belongs to and runs the IP reassembly logic that is described in <a class="el" href="_i_p_reassembly_8h.html">IPReassembly.h</a>. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">fragment</td><td>The fragment to process (IPv4 or IPv6). Please notice that the reassembly logic doesn't change or manipulate this object in any way. All of its data is copied to internal structures and manipulated there </td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">status</td><td>An indication of the packet reassembly status following the processing of this fragment. Possible values are:<ul>
<li>The input fragment is not a IPv4 or IPv6 packet</li>
<li>The input fragment is not a IPv4 or IPv6 fragment packet</li>
<li>The input fragment is the first fragment of the packet</li>
<li>The input fragment is not the first or last fragment</li>
<li>The input fragment came out-of-order, meaning that wasn't the fragment that was currently expected (it's data is copied to the out-of-order fragment list)</li>
<li>The input fragment is malformed and will be ignored</li>
<li>The input fragment is the last one and the packet is now fully reassembled. In this case the return value will contain a pointer to the reassebmled packet </li>
</ul>
</td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">parseUntil</td><td>Optional parameter. Parse the reassembled packet until you reach a certain protocol (inclusive). Can be useful for cases when you need to parse only up to a certain layer and want to avoid the performance impact and memory consumption of parsing the whole packet. Default value is <a class="el" href="namespacepcpp.html#a1d761f7cf37d3b1efb1574fb1177e6eba8576597b751111eab8ec156233a7fd29">UnknownProtocol</a> which means don't take this parameter into account </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">parseUntilLayer</td><td>Optional parameter. Parse the reassembled packet until you reach a certain layer in the OSI model (inclusive). Can be useful for cases when you need to parse only up to a certain OSI layer (for example transport layer) and want to avoid the performance impact and memory consumption of parsing the whole packet. Default value is <a class="el" href="namespacepcpp.html#a69e2ee6a9dc68797612cf8dc38461025aaa1b22ad907997f669b20cc0d3b7e87f">OsiModelLayerUnknown</a> which means don't take this parameter into account </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd><ul>
<li>If the input fragment isn't an IPv4/IPv6 packet or if it isn't an IPv4/IPv6 fragment, the return value is a pointer to the input fragment</li>
<li>If the input fragment is the last one and the reassembled packet is ready - a pointer to the reassembled packet is returned. Notice it's the user's responsibility to free this pointer when done using it</li>
<li>If the reassembled packet isn't ready then NULL is returned </li>
</ul>
</dd></dl>

</div>
</div>
<a id="a97763fcf5926f60684cbbe3fda79cba4"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a97763fcf5926f60684cbbe3fda79cba4">&#9670;&nbsp;</a></span>processPacket() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classpcpp_1_1_packet.html">Packet</a>* pcpp::IPReassembly::processPacket </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classpcpp_1_1_raw_packet.html">RawPacket</a> *&#160;</td>
          <td class="paramname"><em>fragment</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classpcpp_1_1_i_p_reassembly.html#aae7f2e113808978827abf3b7cdbe91af">ReassemblyStatus</a> &amp;&#160;</td>
          <td class="paramname"><em>status</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="namespacepcpp.html#a1d761f7cf37d3b1efb1574fb1177e6eb">ProtocolType</a>&#160;</td>
          <td class="paramname"><em>parseUntil</em> = <code><a class="el" href="namespacepcpp.html#a1d761f7cf37d3b1efb1574fb1177e6eba8576597b751111eab8ec156233a7fd29">UnknownProtocol</a></code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="namespacepcpp.html#a69e2ee6a9dc68797612cf8dc38461025">OsiModelLayer</a>&#160;</td>
          <td class="paramname"><em>parseUntilLayer</em> = <code><a class="el" href="namespacepcpp.html#a69e2ee6a9dc68797612cf8dc38461025aaa1b22ad907997f669b20cc0d3b7e87f">OsiModelLayerUnknown</a></code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>The main API that drives <a class="el" href="classpcpp_1_1_i_p_reassembly.html">IPReassembly</a>. This method should be called whenever a fragment arrives. This method finds the relevant packet this fragment belongs to and runs the IPv4 reassembly logic that is described in <a class="el" href="_i_p_reassembly_8h.html">IPReassembly.h</a>. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">fragment</td><td>The fragment to process (IPv4 or IPv6). Please notice that the reassembly logic doesn't change or manipulate this object in any way. All of its data is copied to internal structures and manipulated there </td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">status</td><td>An indication of the packet reassembly status following the processing of this fragment. Possible values are:<ul>
<li>The input fragment is not a IPv4 or IPv6 packet</li>
<li>The input fragment is not a IPv4 or IPv6 fragment packet</li>
<li>The input fragment is the first fragment of the packet</li>
<li>The input fragment is not the first or last fragment</li>
<li>The input fragment came out-of-order, meaning that wasn't the fragment that was currently expected (it's data is copied to the out-of-order fragment list)</li>
<li>The input fragment is malformed and will be ignored</li>
<li>The input fragment is the last one and the packet is now fully reassembled. In this case the return value will contain a pointer to the reassebmled packet </li>
</ul>
</td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">parseUntil</td><td>Optional parameter. Parse the raw and reassembled packets until you reach a certain protocol (inclusive). Can be useful for cases when you need to parse only up to a certain layer and want to avoid the performance impact and memory consumption of parsing the whole packet. Default value is <a class="el" href="namespacepcpp.html#a1d761f7cf37d3b1efb1574fb1177e6eba8576597b751111eab8ec156233a7fd29">UnknownProtocol</a> which means don't take this parameter into account </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">parseUntilLayer</td><td>Optional parameter. Parse the raw and reassembled packets until you reach a certain layer in the OSI model (inclusive). Can be useful for cases when you need to parse only up to a certain OSI layer (for example transport layer) and want to avoid the performance impact and memory consumption of parsing the whole packet. Default value is <a class="el" href="namespacepcpp.html#a69e2ee6a9dc68797612cf8dc38461025aaa1b22ad907997f669b20cc0d3b7e87f">OsiModelLayerUnknown</a> which means don't take this parameter into account </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd><ul>
<li>If the input fragment isn't an IPv4/IPv6 packet or if it isn't an IPv4/IPv6 fragment, the return value is a pointer to a <a class="el" href="classpcpp_1_1_packet.html">Packet</a> object wrapping the input fragment <a class="el" href="classpcpp_1_1_raw_packet.html">RawPacket</a> object. It's the user responsibility to free this instance</li>
<li>If the input fragment is the last one and the reassembled packet is ready - a pointer to the reassembled packet is returned. Notice it's the user's responsibility to free this pointer when done using it</li>
<li>If the reassembled packet isn't ready then NULL is returned </li>
</ul>
</dd></dl>

</div>
</div>
<a id="a72d9dea60bb16f09caadd0b82c00afd6"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a72d9dea60bb16f09caadd0b82c00afd6">&#9670;&nbsp;</a></span>removePacket()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void pcpp::IPReassembly::removePacket </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classpcpp_1_1_i_p_reassembly_1_1_packet_key.html">PacketKey</a> &amp;&#160;</td>
          <td class="paramname"><em>key</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Remove a partially reassembled packet from all internal structures. That means that if another fragment of this packet appears it will be treated as a new packet </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">key</td><td>The identifiers of the packet to remove </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
</div><!-- contents -->
</div><!-- doc-content -->
<!-- start footer part -->
<div id="nav-path" class="navpath"><!-- id is needed for treeview function! -->
  <ul>
    <li class="navelem"><a class="el" href="namespacepcpp.html">pcpp</a></li><li class="navelem"><a class="el" href="classpcpp_1_1_i_p_reassembly.html">IPReassembly</a></li>
    <li class="footer">Generated on Mon Dec 2 2019 23:53:22 for PcapPlusPlus by
    <a href="http://www.doxygen.org/index.html">
    <img class="footer" src="doxygen.png" alt="doxygen"/></a> 1.8.16 </li>
  </ul>
</div>
</body>
</html>
