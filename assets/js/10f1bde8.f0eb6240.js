"use strict";(self.webpackChunkpcapplusplus_github_io=self.webpackChunkpcapplusplus_github_io||[]).push([[6944],{3905:(e,t,a)=>{a.d(t,{Zo:()=>c,kt:()=>u});var n=a(7294);function r(e,t,a){return t in e?Object.defineProperty(e,t,{value:a,enumerable:!0,configurable:!0,writable:!0}):e[t]=a,e}function i(e,t){var a=Object.keys(e);if(Object.getOwnPropertySymbols){var n=Object.getOwnPropertySymbols(e);t&&(n=n.filter((function(t){return Object.getOwnPropertyDescriptor(e,t).enumerable}))),a.push.apply(a,n)}return a}function l(e){for(var t=1;t<arguments.length;t++){var a=null!=arguments[t]?arguments[t]:{};t%2?i(Object(a),!0).forEach((function(t){r(e,t,a[t])})):Object.getOwnPropertyDescriptors?Object.defineProperties(e,Object.getOwnPropertyDescriptors(a)):i(Object(a)).forEach((function(t){Object.defineProperty(e,t,Object.getOwnPropertyDescriptor(a,t))}))}return e}function p(e,t){if(null==e)return{};var a,n,r=function(e,t){if(null==e)return{};var a,n,r={},i=Object.keys(e);for(n=0;n<i.length;n++)a=i[n],t.indexOf(a)>=0||(r[a]=e[a]);return r}(e,t);if(Object.getOwnPropertySymbols){var i=Object.getOwnPropertySymbols(e);for(n=0;n<i.length;n++)a=i[n],t.indexOf(a)>=0||Object.prototype.propertyIsEnumerable.call(e,a)&&(r[a]=e[a])}return r}var o=n.createContext({}),s=function(e){var t=n.useContext(o),a=t;return e&&(a="function"==typeof e?e(t):l(l({},t),e)),a},c=function(e){var t=s(e.components);return n.createElement(o.Provider,{value:t},e.children)},d={inlineCode:"code",wrapper:function(e){var t=e.children;return n.createElement(n.Fragment,{},t)}},h=n.forwardRef((function(e,t){var a=e.components,r=e.mdxType,i=e.originalType,o=e.parentName,c=p(e,["components","mdxType","originalType","parentName"]),h=s(a),u=r,k=h["".concat(o,".").concat(u)]||h[u]||d[u]||i;return a?n.createElement(k,l(l({ref:t},c),{},{components:a})):n.createElement(k,l({ref:t},c))}));function u(e,t){var a=arguments,r=t&&t.mdxType;if("string"==typeof e||r){var i=a.length,l=new Array(i);l[0]=h;var p={};for(var o in t)hasOwnProperty.call(t,o)&&(p[o]=t[o]);p.originalType=e,p.mdxType="string"==typeof e?e:r,l[1]=p;for(var s=2;s<i;s++)l[s]=a[s];return n.createElement.apply(null,l)}return n.createElement.apply(null,a)}h.displayName="MDXCreateElement"},1054:(e,t,a)=>{a.d(t,{Z:()=>i});var n=a(7294),r=a(2232);const i=function(e){let{relativePath:t,children:a}=e;return n.createElement("a",{href:(0,r.E2)()+t},a)}},2232:(e,t,a)=>{a.d(t,{E2:()=>d,K7:()=>p,Wx:()=>c,hv:()=>i,kq:()=>l,rU:()=>h,s6:()=>o,u$:()=>s,vR:()=>u});var n=a(143);const r="https://github.com/seladb/PcapPlusPlus";function i(){return r}function l(){const e=(0,n.yW)(),t=(0,n.zu)();return"Next"===t.label?e.label:t.label}function p(e){return`${r}/releases/tag/${e}`}function o(){return p(l())}function s(){return`${r}/archive/${l()}.zip`}function c(){return`${r}/archive/${l()}.tar.gz`}function d(){const e=(0,n.zu)(),t="Next"===e.label?"master":e.label;return`${r}/tree/${t}`}function h(){return`${r}/archive/master.zip`}function u(){return`${r}/archive/master.tar.gz`}},2079:(e,t,a)=>{a.r(t),a.d(t,{assets:()=>s,contentTitle:()=>p,default:()=>h,frontMatter:()=>l,metadata:()=>o,toc:()=>c});var n=a(7462),r=(a(7294),a(3905)),i=a(1054);const l={sidebar_position:5,title:"Part 5: Packet Crafting"},p="Part 5: Packet Crafting And Editing",o={unversionedId:"tutorials/packet-crafting",id:"tutorials/packet-crafting",title:"Part 5: Packet Crafting",description:"Introduction",source:"@site/docs/tutorials/packet-crafting.mdx",sourceDirName:"tutorials",slug:"/tutorials/packet-crafting",permalink:"/docs/next/tutorials/packet-crafting",draft:!1,editUrl:"https://github.com/PcapPlusPlus/pcapplusplus.github.io/edit/master/docs/tutorials/packet-crafting.mdx",tags:[],version:"current",sidebarPosition:5,frontMatter:{sidebar_position:5,title:"Part 5: Packet Crafting"},sidebar:"docs",previous:{title:"Part 4: Packet Parsing",permalink:"/docs/next/tutorials/packet-parsing"},next:{title:"Part 6: Working With DPDK",permalink:"/docs/next/tutorials/dpdk"}},s={},c=[{value:"Introduction",id:"introduction",level:2},{value:"Packet editing",id:"packet-editing",level:2},{value:"Packet Creation",id:"packet-creation",level:2},{value:"Running the code",id:"running-the-code",level:2},{value:"Option 1: Install a pre-compiled version of PcapPlusPlus",id:"option-1-install-a-pre-compiled-version-of-pcapplusplus",level:3}],d={toc:c};function h(e){let{components:t,...l}=e;return(0,r.kt)("wrapper",(0,n.Z)({},d,l,{components:t,mdxType:"MDXLayout"}),(0,r.kt)("h1",{id:"part-5-packet-crafting-and-editing"},"Part 5: Packet Crafting And Editing"),(0,r.kt)("h2",{id:"introduction"},"Introduction"),(0,r.kt)("p",null,"In the previous ",(0,r.kt)("a",{parentName:"p",href:"./packet-parsing"},"Packet parsing")," tutorial we demonstrated how PcapPlusPlus parses packets and how to read data out the various layers. In this tutorial we'll focus on editing packets - meaning change existing protocol data, add more data and add/remove layers, and also how to craft new packets from scratch."),(0,r.kt)("p",null,"Of course we won't go over all the protocols, we'll focus on a few which are popular:"),(0,r.kt)("ul",null,(0,r.kt)("li",{parentName:"ul"},"Ethernet"),(0,r.kt)("li",{parentName:"ul"},"VLAN"),(0,r.kt)("li",{parentName:"ul"},"IPv4"),(0,r.kt)("li",{parentName:"ul"},"TCP"),(0,r.kt)("li",{parentName:"ul"},"UDP"),(0,r.kt)("li",{parentName:"ul"},"HTTP"),(0,r.kt)("li",{parentName:"ul"},"DNS")),(0,r.kt)("p",null,"For further information about these protocols and the other protocols supported in PcapPlusPlus please go to the ",(0,r.kt)("a",{parentName:"p",href:"../api"},"API documentation")),(0,r.kt)("h2",{id:"packet-editing"},"Packet editing"),(0,r.kt)("p",null,"In this part of the tutorial we'll read a packet from a pcap file, let PcapPlusPlus parse it, and then see how we can edit and change the data in each layer. Let's start by writing a ",(0,r.kt)("inlineCode",{parentName:"p"},"main()")," method and add the includes that we need:"),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-cpp"},'#include <iostream>\n#include "stdlib.h"\n#include "SystemUtils.h"\n#include "Packet.h"\n#include "EthLayer.h"\n#include "VlanLayer.h"\n#include "IPv4Layer.h"\n#include "TcpLayer.h"\n#include "HttpLayer.h"\n#include "UdpLayer.h"\n#include "DnsLayer.h"\n#include "PcapFileDevice.h"\n\nint main(int argc, char* argv[])\n{\n    // We\'ll write our code here\n}\n')),(0,r.kt)("p",null,"As you can see we added an include to ",(0,r.kt)("inlineCode",{parentName:"p"},"Packet.h")," which contains the basic parsed packet structures, to ",(0,r.kt)("inlineCode",{parentName:"p"},"PcapFileDevice.h")," which contains the API for reading/writing from/to pcap files and to all of the layers which we will edit and add data from. In addition we included ",(0,r.kt)("inlineCode",{parentName:"p"},"SystemUtils.h")," for using ",(0,r.kt)("inlineCode",{parentName:"p"},"hostToNet16()")," which we'll use later."),(0,r.kt)("p",null,"Now let's read the packet from the pcap file. This pcap file contains only 1 packet, so we'll open the reader, read the packet and close the reader:"),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-cpp"},'// use the IFileReaderDevice interface to automatically identify file type (pcap/pcap-ng)\n// and create an interface instance that both readers implement\npcpp::IFileReaderDevice* reader = pcpp::IFileReaderDevice::getReader("1_http_packet.pcap");\n\n// verify that a reader interface was indeed created\nif (reader == NULL)\n{\n    std::cerr << "Cannot determine reader for file type" << std::endl;\n    return 1;\n}\n\n// open the reader for reading\nif (!reader->open())\n{\n    std::cerr << "Cannot open input.pcap for reading" << std::endl;\n    return 1;\n}\n\n// read the first (and only) packet from the file\npcpp::RawPacket rawPacket;\nif (!reader->getNextPacket(rawPacket))\n{\n    std::cerr << "Couldn\'t read the first packet in the file" << std::endl;\n    return 1;\n}\n\n// close the file reader, we don\'t need it anymore\nreader->close();\n')),(0,r.kt)("p",null,"The next step is to let PcapPlusPlus parse the packet by creating an instance of the ",(0,r.kt)("inlineCode",{parentName:"p"},"Packet")," class and giving it in the constructor a pointer to the ",(0,r.kt)("inlineCode",{parentName:"p"},"RawPacket")," instance we have:"),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-cpp"},"// parse the raw packet into a parsed packet\npcpp::Packet parsedPacket(&rawPacket);\n")),(0,r.kt)("p",null,"You may notice this is exactly the same packet as we used in the ",(0,r.kt)("a",{parentName:"p",href:"./packet-parsing"},"Packet parsing")," tutorial but this time we won't just read data from the various layers but actually change it. First thing we'll do is get the ",(0,r.kt)("strong",{parentName:"p"},"Ethernet")," layer and change it:"),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-cpp"},'// now let\'s get the Ethernet layer\npcpp::EthLayer* ethernetLayer = parsedPacket.getLayerOfType<pcpp::EthLayer>();\n// change the source dest MAC address\n// change the source dest MAC address\nethernetLayer->setDestMac(pcpp::MacAddress("aa:bb:cc:dd:ee:ff"));\n')),(0,r.kt)("p",null,"As you can see, we changed the destination MAC address to ",(0,r.kt)("inlineCode",{parentName:"p"},'"aa:bb:cc:dd:ee:ff"')," We used the ",(0,r.kt)("inlineCode",{parentName:"p"},"setDestMac()")," method exposed in ",(0,r.kt)("inlineCode",{parentName:"p"},"EthLayer")," to do that and we gave it a ",(0,r.kt)("inlineCode",{parentName:"p"},"MacAddress")," class instance we created with the new MAC address we want."),(0,r.kt)("p",null,"Ethernet layer is quite simple, let's move to a more complex layer - ",(0,r.kt)("strong",{parentName:"p"},"IPv4"),", and see what data we can change there:"),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-cpp"},'// let\'s get the IPv4 layer\npcpp::IPv4Layer* ipLayer = parsedPacket.getLayerOfType<pcpp::IPv4Layer>();\n// change source IP address\nipLayer->setSrcIPv4Address(pcpp::IPv4Address("1.1.1.1"));\n// change IP ID\nipLayer->getIPv4Header()->ipId = pcpp::hostToNet16(4000);\n// change TTL value\nipLayer->getIPv4Header()->timeToLive = 12;\n')),(0,r.kt)("p",null,"First we changed the source IPv4 address to ",(0,r.kt)("inlineCode",{parentName:"p"},'"1.1.1.1"')," using the method ",(0,r.kt)("inlineCode",{parentName:"p"},"setSrcIPv4Address()")," and provided it an instance of the class ",(0,r.kt)("inlineCode",{parentName:"p"},"IPv4Address")," with the value of ",(0,r.kt)("inlineCode",{parentName:"p"},'"1.1.1.1"'),". Then, we used the ",(0,r.kt)("inlineCode",{parentName:"p"},"getIPv4Header()")," method which casts the raw packet bytes to a struct called ",(0,r.kt)("inlineCode",{parentName:"p"},"iphdr*")," in the same way we did in the packet parsing tutorial, but this time instead of reading values we're changing them. It is very important to understand that the ",(0,r.kt)("inlineCode",{parentName:"p"},"iphdr*")," object gives access to the actual packet bytes so it can be both read and manipulated, and each change affects the actual packet data. When setting fields which are wider than 1 byte it's important to write in network order and that's why we're using ",(0,r.kt)("inlineCode",{parentName:"p"},"hostToNet16()")," to set the IP ID to 4000."),(0,r.kt)("p",null,"Let's move on to the next layer - ",(0,r.kt)("strong",{parentName:"p"},"TCP"),":"),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-cpp"},"// let's get the TCP layer\npcpp::TcpLayer* tcpLayer = parsedPacket.getLayerOfType<pcpp::TcpLayer>();\n// change source port\ntcpLayer->getTcpHeader()->portSrc = pcpp::hostToNet16(12345);\n// add URG flag\ntcpLayer->getTcpHeader()->urgFlag = 1;\n// add MSS TCP option\ntcpLayer->addTcpOptionAfter(pcpp::TcpOptionBuilder(pcpp::TCPOPT_MSS, (uint16_t)1460));\n")),(0,r.kt)("p",null,"We start by using the method ",(0,r.kt)("inlineCode",{parentName:"p"},"getTcpHeader()")," which casts the raw packet bytes to a struct ",(0,r.kt)("inlineCode",{parentName:"p"},"tpchdr*")," which contains all of the TCP fields. Again, like we saw in ",(0,r.kt)("inlineCode",{parentName:"p"},"IPv4Layer"),", this method gives access to the actual packet bytes so every change we do changes the packet. So we changed the source port to 12345 and set the URG flag."),(0,r.kt)("p",null,"Now let's take a look at the 2 bottom lines in the code snippet above. ",(0,r.kt)("inlineCode",{parentName:"p"},"TcpLayer")," exposes an API to read, add and remove TCP options. The packet we're editing already has 3 TCP options: NOP, NOP and Timestamp. We'd like to add a fourth one of type MSS with MSS value of 1460 and we want it to appear first (before the existing TCP options). So we use the ",(0,r.kt)("inlineCode",{parentName:"p"},"addTcpOptionAfter()")," method and give it a ",(0,r.kt)("inlineCode",{parentName:"p"},"TcpOptionBuilder")," object. This builder object gets in its constructor the TCP option type (which is ",(0,r.kt)("inlineCode",{parentName:"p"},"PCPP_TCPOLEN_MSS"),"), and the option value (1460) and ",(0,r.kt)("inlineCode",{parentName:"p"},"addTcpOptionAfter()")," uses it to create the TCP option object and add it to the existing list of TCP options. That's it! with 1 line of code we managed to add a new TCP option!"),(0,r.kt)("p",null,"Now let move on to the last layer in this packet: ",(0,r.kt)("strong",{parentName:"p"},"HTTP"),". Let's see the code:"),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-cpp"},'// let\'s get the HTTP layer\npcpp::HttpRequestLayer* httpRequestLayer = parsedPacket.getLayerOfType<pcpp::HttpRequestLayer&hl;();\n// change the request method from GET to TRACE\nhttpRequestLayer->getFirstLine()->setMethod(pcpp::HttpRequestLayer::HttpTRACE);\n// change host to www.google.com\nhttpRequestLayer->getFieldByName(PCPP_HTTP_HOST_FIELD)->setFieldValue("www.google.com");\n// change referer value to www.aol.com\nhttpRequestLayer->getFieldByName(PCPP_HTTP_REFERER_FIELD)->setFieldValue("www.aol.com");\n// remove cookie field\nhttpRequestLayer->removeField(PCPP_HTTP_COOKIE_FIELD);\n// add x-forwarded-for field\npcpp::HttpField* xForwardedForField = httpRequestLayer->insertField(httpRequestLayer->getFieldByName(PCPP_HTTP_HOST_FIELD), "X-Forwarded-For", "1.1.1.1");\n// add cache-control field\nhttpRequestLayer->insertField(xForwardedForField, "Cache-Control", "max-age=0");\n')),(0,r.kt)("p",null,"We already discussed the highlights of the ",(0,r.kt)("inlineCode",{parentName:"p"},"HttpLayer")," API in the ",(0,r.kt)("a",{parentName:"p",href:"./packet-parsing"},"Packet parsing")," tutorial so we won't repeat all of it again. But as you can see the API provides setters for all of the relevant data:"),(0,r.kt)("ul",null,(0,r.kt)("li",{parentName:"ul"},(0,r.kt)("inlineCode",{parentName:"li"},"HttpRequestFirstLine")," exposes is a setter for the HTTP method ",(0,r.kt)("inlineCode",{parentName:"li"},"setMethod()")," where we change it to ",(0,r.kt)("inlineCode",{parentName:"li"},"TRACE"),". Similar methods exist for the URI and version"),(0,r.kt)("li",{parentName:"ul"},"When retrieving HTTP fields, the ",(0,r.kt)("inlineCode",{parentName:"li"},"HttpField")," class exposes a method of ",(0,r.kt)("inlineCode",{parentName:"li"},"setFieldValue()")," for setting the field value (demonstrated above for ",(0,r.kt)("inlineCode",{parentName:"li"},'"Host"')," and ",(0,r.kt)("inlineCode",{parentName:"li"},'"Referer"')," fields)"),(0,r.kt)("li",{parentName:"ul"},(0,r.kt)("inlineCode",{parentName:"li"},"HttpLayer")," exposes methods for adding new fields: ",(0,r.kt)("inlineCode",{parentName:"li"},"insertField()")," and ",(0,r.kt)("inlineCode",{parentName:"li"},"addField()"),", and methods for removing existing fields: ",(0,r.kt)("inlineCode",{parentName:"li"},"removeField()"),". Here we demonstrated how to add ",(0,r.kt)("inlineCode",{parentName:"li"},'"X-Forwarded-For"')," and ",(0,r.kt)("inlineCode",{parentName:"li"},'"Cache-Control"')," header fields (and set their values) and how to remove the ",(0,r.kt)("inlineCode",{parentName:"li"},'"Cookie"')," header field")),(0,r.kt)("p",null,"So far we've seen editing of existing layers. But what about adding new layers or removing existing ones?"),(0,r.kt)("p",null,"Of course this is also possible using the ",(0,r.kt)("inlineCode",{parentName:"p"},"Packet")," class API. Let's demonstrate how to add a VLAN layer between the Ethernet and IPv4 layer:"),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-cpp"},"// create a new vlan layer\npcpp::VlanLayer newVlanLayer(123, false, 1, PCPP_ETHERTYPE_IP);\n\n// add the vlan layer to the packet after the existing Ethernet layer\nparsedPacket.insertLayer(ethernetLayer, &newVlanLayer);\n")),(0,r.kt)("p",null,"First we created a new ",(0,r.kt)("inlineCode",{parentName:"p"},"VlanLayer")," instance and gave it the necessary parameters which are VLAN ID (123), CFI (false), priority (1) and the Ether type for the next layer (IPv4). Then we added this layer to the packet right after the Ethernet layer using ",(0,r.kt)("inlineCode",{parentName:"p"},"insertLayer()")," method. Nice and simple :)"),(0,r.kt)("p",null,"In the same way we added a new layer we can also remove layers from the packet using the ",(0,r.kt)("inlineCode",{parentName:"p"},"Packet::removeLayer()")," method."),(0,r.kt)("p",null,"We've made quite a lot of changes to the packet. Let's save it to a pcap file and view the result in Wireshark. But before doing that let's first instruct the packet to re-calculate all of the layers' calculated fields:"),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-cpp"},'// compute all calculated fields\nparsedPacket.computeCalculateFields();\n\n// write the modified packet to a pcap file\npcpp::PcapFileWriterDevice writer("1_modified_packet.pcap");\nwriter.open();\nwriter.writePacket(*(parsedPacket.getRawPacket()));\nwriter.close();\n')),(0,r.kt)("p",null,"Now let's open ",(0,r.kt)("inlineCode",{parentName:"p"},'"1_modified_packet.pcap"')," in Wireshark and view the result:"),(0,r.kt)("p",null,(0,r.kt)("img",{alt:"Packet Edit 1",src:a(6778).Z,width:"843",height:"466"})),(0,r.kt)("p",null,(0,r.kt)("img",{alt:"Packet Edit 2",src:a(1290).Z,width:"875",height:"669"})),(0,r.kt)("p",null,(0,r.kt)("img",{alt:"Packet Edit 3",src:a(8395).Z,width:"832",height:"382"})),(0,r.kt)("h2",{id:"packet-creation"},"Packet Creation"),(0,r.kt)("p",null,"In this part of the tutorial we'll build a packet from scratch, create the different layers one by one and eventually save it to a pcap file to verify packet data is the same as expected."),(0,r.kt)("p",null,"Let's start by creating the first layer - an ",(0,r.kt)("strong",{parentName:"p"},"Ethernet")," layer:"),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-cpp"},'// create a new Ethernet layer\npcpp::EthLayer newEthernetLayer(pcpp::MacAddress("00:50:43:11:22:33"), pcpp::MacAddress("aa:bb:cc:dd:ee:ff"));\n')),(0,r.kt)("p",null,"What we did here is create a new instance of the ",(0,r.kt)("inlineCode",{parentName:"p"},"EthLayer")," class and give it the necessary parameters which are source and dest MAC addresses (both are instances of the ",(0,r.kt)("inlineCode",{parentName:"p"},"MacAddress")," class instantiated with the MAC address string). Rather easy right?"),(0,r.kt)("p",null,"Now let's move on to the second layer - ",(0,r.kt)("strong",{parentName:"p"},"IPv4"),":"),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-cpp"},'// create a new IPv4 layer\npcpp::IPv4Layer newIPLayer(pcpp::IPv4Address("192.168.1.1"), pcpp::IPv4Address("10.0.0.1"));\nnewIPLayer.getIPv4Header()->ipId = pcpp::hostToNet16(2000);\nnewIPLayer.getIPv4Header()->timeToLive = 64;\n')),(0,r.kt)("p",null,"Here we created a new instance of the ",(0,r.kt)("inlineCode",{parentName:"p"},"IPv4Layer")," and gave it the necessary parameters which are source and dest IP addresses (both are instances of the ",(0,r.kt)("inlineCode",{parentName:"p"},"IPv4Address")," class instantiated with the IP address string). Next, we wanted to set the IP ID and TTL values of this layer. As you can see we do that using the same API we used in the ",(0,r.kt)("a",{parentName:"p",href:"#packet-editing"},"Packet editing")," part: call the ",(0,r.kt)("inlineCode",{parentName:"p"},"getIPv4Header()")," method to get an instance of the ",(0,r.kt)("inlineCode",{parentName:"p"},"iphdr*")," struct (which is actually a pointer to the packet raw data cast to ",(0,r.kt)("inlineCode",{parentName:"p"},"iphdr*"),") and set the IP ID and TTL values. Since IP ID is 2-bytes long we use ",(0,r.kt)("inlineCode",{parentName:"p"},"hostToNet16()")," to convert from host to network order."),(0,r.kt)("p",null,"Now let's move on to the third layer - ",(0,r.kt)("strong",{parentName:"p"},"UDP"),":"),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-cpp"},"// create a new UDP layer\npcpp::UdpLayer newUdpLayer(12345, 53);\n")),(0,r.kt)("p",null,"As you can see, this is quite straight forward: we created a new instance of ",(0,r.kt)("inlineCode",{parentName:"p"},"UdpLayer")," and gave it in the constructor the source and dest UDP ports."),(0,r.kt)("p",null,"Let's move on to the fourth and last layer - ",(0,r.kt)("strong",{parentName:"p"},"DNS"),":"),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-cpp"},'// create a new DNS layer\npcpp::DnsLayer newDnsLayer;\nnewDnsLayer.addQuery("www.ebay.com", pcpp::DNS_TYPE_A, pcpp::DNS_CLASS_IN);\n')),(0,r.kt)("p",null,"Here we first created an instance of ",(0,r.kt)("inlineCode",{parentName:"p"},"DnsLayer")," with the default constructor (without any parameters). Then we added a DNS query record to the layer using the ",(0,r.kt)("inlineCode",{parentName:"p"},"addQuery()"),' method and gave it the query parameters which are: query name ("',(0,r.kt)("a",{parentName:"p",href:"http://www.ebay.com%22"},'www.ebay.com"'),"), query type (type A means IPv4 address) and query class (class IN means Internet)."),(0,r.kt)("p",null,"That's it! we created 4 layers, now let's add them to a new packet. Let's first create a new ",(0,r.kt)("inlineCode",{parentName:"p"},"Packet")," instance:"),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-cpp"},"// create a packet with initial capacity of 100 bytes (will grow automatically if needed)\npcpp::Packet newPacket(100);\n")),(0,r.kt)("p",null,"The value 100 we gave in the constructor is the expected length of the packet (in bytes). When we give this number a buffer of size 100 is automatically created and will be used to store the packet raw data. Of course, if our packet exceeds 100 bytes this buffer will be automatically extended, but this has a performance cost, so in applications that require high performance it's better to allocate this buffer in advanced (meaning setting the buffer size in the constructor). Now it's time to add all the layers we created to the packet, we'll use the ",(0,r.kt)("inlineCode",{parentName:"p"},"addLayer()")," method for that:"),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-cpp"},"// add all the layers we created\nnewPacket.addLayer(&newEthernetLayer);\nnewPacket.addLayer(&newIPLayer);\nnewPacket.addLayer(&newUdpLayer);\nnewPacket.addLayer(&newDnsLayer);\n")),(0,r.kt)("p",null,"We're almost done. All that is left is to call the ",(0,r.kt)("inlineCode",{parentName:"p"},"computeCalculateFields()")," method to calculate the layers' calculated fields:"),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-cpp"},"// compute all calculated fields\nnewPacket.computeCalculateFields();\n")),(0,r.kt)("p",null,"Our packet is ready! Now let's save it to a pcap file and open this file in Wireshark to verify the packet looks exactly like we built it:"),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-cpp"},'// write the new packet to a pcap file\npcpp::PcapFileWriterDevice writer2("1_new_packet.pcap");\nwriter2.open();\nwriter2.writePacket(*(newPacket.getRawPacket()));\nwriter2.close();\n')),(0,r.kt)("p",null,"Now let's compile the code, run it and open the ",(0,r.kt)("inlineCode",{parentName:"p"},'"1_new_packet.pcap"')," file in Wireshark:"),(0,r.kt)("p",null,(0,r.kt)("img",{alt:"New Packet",src:a(2610).Z,width:"915",height:"650"})),(0,r.kt)("p",null,"As you can see, the packet looks exactly as expected."),(0,r.kt)("h2",{id:"running-the-code"},"Running the code"),(0,r.kt)("p",null,"All code that was covered in this tutorial can be found ",(0,r.kt)(i.Z,{relativePath:"/Examples/Tutorials/Tutorial-PacketCraftAndEdit",mdxType:"CodeLink"},"here"),". In order to compile and run the code please choose one of these options:"),(0,r.kt)("h3",{id:"option-1-install-a-pre-compiled-version-of-pcapplusplus"},"Option 1: Install a pre-compiled version of PcapPlusPlus"),(0,r.kt)("p",null,"You can download and install PcapPlusPlus using one of the options mentioned in the ",(0,r.kt)("a",{parentName:"p",href:"../install"},"installation page"),"."),(0,r.kt)("p",null,"Once installed, download all of the files in the ",(0,r.kt)(i.Z,{relativePath:"/Examples/Tutorials/Tutorial-PacketCraftAndEdit",mdxType:"CodeLink"},"tutorial folder")," and run CMake:"),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-shell"},"cmake -S . -B build\ncmake --build build\n")),(0,r.kt)("p",null,"The executable will be created in the same directory."),(0,r.kt)("admonition",{title:"Notes:",type:"tip"},(0,r.kt)("ol",{parentName:"admonition"},(0,r.kt)("li",{parentName:"ol"},"If you're running on Windows with MinGW you need to run cmake with ",(0,r.kt)("inlineCode",{parentName:"li"},'-G "MinGW Makefiles"')),(0,r.kt)("li",{parentName:"ol"},"If PcapPlusPlus is ",(0,r.kt)("strong",{parentName:"li"},"NOT")," installed in the default directory you may need to specify ",(0,r.kt)("inlineCode",{parentName:"li"},"CMAKE_PREFIX_PATH"),", for example:",(0,r.kt)("pre",{parentName:"li"},(0,r.kt)("code",{parentName:"pre",className:"language-shell"},"CMAKE_PREFIX_PATH=/my/pcapplusplus/path cmake -S . -B build\n")),"Or on Windows:",(0,r.kt)("pre",{parentName:"li"},(0,r.kt)("code",{parentName:"pre",className:"language-shell"},"set CMAKE_PREFIX_PATH=C:\\my\\pcapplusplus\\path\ncmake -S . -B build\n"))),(0,r.kt)("li",{parentName:"ol"},"On Windows you may also need to specify Npcap/WinPcap path in ",(0,r.kt)("inlineCode",{parentName:"li"},"CMAKE_PREFIX_PATH"),", for example:",(0,r.kt)("pre",{parentName:"li"},(0,r.kt)("code",{parentName:"pre",className:"language-shell"},"set CMAKE_PREFIX_PATH=C:\\my\\pcapplusplus\\path;C:\\my\\npcap\\path\ncmake -S . -B build\n")),":::")),(0,r.kt)("h3",{parentName:"admonition",id:"option-2-build-the-tutorials-with-pcapplusplus"},"Option 2: build the tutorials with PcapPlusPlus"),(0,r.kt)("p",{parentName:"admonition"},"If you're building PcapPlusPlus from source and would like to build the tutorials as well you can use the ",(0,r.kt)("inlineCode",{parentName:"p"},"-DPCAPPP_BUILD_TUTORIALS=ON")," option.\nPlease refer to the ",(0,r.kt)("a",{parentName:"p",href:"../install#build-from-source"},"build from source page")," for more details (choose your platform page).")))}h.isMDXComponent=!0},2610:(e,t,a)=>{a.d(t,{Z:()=>n});const n=a.p+"assets/images/NewPacket-2f8931f78cc00e944c6d5080e43e6b85.png"},6778:(e,t,a)=>{a.d(t,{Z:()=>n});const n=a.p+"assets/images/PacketEdit1-eddc6e4dce2cb091a612908922eb57f4.png"},1290:(e,t,a)=>{a.d(t,{Z:()=>n});const n=a.p+"assets/images/PacketEdit2-b3e0a9658b43290ccd20a26388d57645.png"},8395:(e,t,a)=>{a.d(t,{Z:()=>n});const n=a.p+"assets/images/PacketEdit3-5ee85201ffe6b6b2c6e733e1f4c182c7.png"}}]);